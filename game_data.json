{"name": "De Morgan's game", "version": "1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "De Morgan's game-1.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "lemma", "text": "5", "lean": "lemma example1 (P : Prop) (p : P) : P :=\n", "sideBar": true, "firstProofLineNumber": 72, "lastProofLineNumber": 74, "textBefore": "import tactic --hide\n\n/-\n\n#Logical statements \n\nYou've seen logical statements already, these are statements that can be true or false, for example: \n\n-The sum of two odd numbers is an even number\n\n-$36$ is divisible by $3$\n\n-$x > 2$\n\n\nLets see how one does this a computer, specifically in lean. In lean, logical staments live in a \nworld called `Prop`. So for example if we write `P : Prop` we mean \"$P$ is a logical statement.\" \nThink of the `:` symbol as saying $P$  is a resident of `Prop` world (in maths this would be denoted\nby something like `P \u2208 Prop`).\n\n#Truth Values\n\nThe truth value of a logical statement (i.e. some `P : Prop`) is whether the statement is true or \nfalse.  For example, the truth value of the statement: \"For all integers $x \u2208 \u2124$,  $0 \u2264 x^2$\" \nis *true* while  \"For all integers $x \u2208 \u2124$,  $0 \u2264 x^3$\" is *false*. \n\nIn lean we assign truth values as follows: We first think of a proposition $P$ as a set with \n*at most* one element.  If this set is empty, then we say `P` is *false*. Otherwise, if this set has \nan element, lets call it $p$ (we will usually use upper case letters for logical statements, \nand lower case for their proofs), then this  statement is *true* and $p$ is the proof. \n\nSo to recap, if $P$ is the true/false statement (the statement of proposition), and $p$ is its proof.\nIt's like thinking $P$ being the set and $p$ being the element. Just as above, where we had \n`P : Prop` to mean $P$  is a proposition, we write `p : P` to mean \"$p$ is a proof of $P$\".\n\nThe aim of this game is to learn how to manipulate logical statements and their proofs. \nLets start with a super basic example of how a lemma looks like in lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, \non the right you will  see the following: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere the first two lines are our assumptions and the thing after the `\u22a2` symbol is what we are \nbeing asked to prove. \n\nNow, in this game our \"moves\" or, as we call them in lean, *Tactics*, are what will allow us to \nmanipulate our statement and produce proofs.\n\nThe first tactic we will look at is called *exact* and what it does is, if you need to prove a \nstatement $P$ and you have proof of it, say, `p: P`, then `exact p` will prove it. \n\nNote that at the end of each line we write we need to have a comma `,` to tell lean that this is the \nend of our move. \n\nSo if below you change the `sorry` for \"`exact p,`\" (don't forget the comma!) you'll see that on the \nright it will change to say `Proof complete!`. \n\n-/\n\n\n/- Lemma\nLets try and prove that if $P$ is a logical stament (i.e. `P : Prop`) and $p$ is a proof of $P$ \n(i.e. `p : P`) then $P$ is true.\n-/\nlemma example1 (P : Prop) (p : P) : P :=\nbegin\n", "proof": "  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : exact\n## Summary \nIf the goal is `\u22a2 P` then `exact p` will close the goal if\nand only if `p` is a proof of `P` (i.e. `p : P`) \n## Details\nSay $P$, $Q$ and $R$ are logical staments\nand the local context looks like this: \n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n`exact j(h(p)),`\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n-/", "height": 3, "editorText": "sorry", "lineOffset": 71, "name": "example1", "statement": "(P : Prop) (p : P) : P"}, {"type": "tactic", "content": "6", "name": "exact", "sideBar": true}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "7", "hidden": true}, {"type": "lemma", "text": "8", "lean": "lemma example2 (P Q : Prop) (p : P) (q : Q) : Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 10, "textBefore": "import tactic --hide \n\n/-Lemma\nNow try the following one:\n-/\nlemma example2 (P Q : Prop) (p : P) (q : Q) : Q :=\nbegin\n", "proof": "  exact q,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 3, "editorText": "sorry", "lineOffset": 7, "name": "example2", "statement": "(P Q : Prop) (p : P) (q : Q) : Q"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "9", "hidden": true}, {"type": "text", "content": "10"}, {"type": "lemma", "text": "11", "lean": "lemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\n", "sideBar": true, "firstProofLineNumber": 44, "lastProofLineNumber": 47, "textBefore": "import tactic --hide \n\n/-\n\n#Combining logical statements\n\nNow, we can take these statements and create new ones. For example if we have two statements \n`P Q : Prop` we can write ` P \u2192 Q` to mean $P$ implies $Q$. Similarly, we can write `\u00acP` for the \nstatement \"Not $P$\". \n\nSay we have the following lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nThis asks us to prove: If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ \n(i.e. we have `p : P`). Then $Q$ is true (i.e. we have a proof of `Q`). \n\nHere we have given the name $h$ to the implication ` P \u2192 Q`. We think of $h$ as a map between \nstatements in `Prop` world. \n\nNow this lemma is asking us to take a proof of $P$ and turn it into a proof of $Q$. Since we know \nthat $P$ implies $Q$ then we know that if $P$ is true then so is $Q$. So we can use our map in \n`Prop` world to transform our proof of $P$ into a proof of $Q$. \n\nIf we write `exact h(p)` below we get what we want.\n\nNote that it has to be lower case $p$, since $P$ is the logical statement, but what we want to \ntransform is the proof.\n\n\n\n-/\n\n/- Lemma\nIf $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ (i.e. we have `p : P`). \nThen $Q$ is true (i.e. we have a proof of `Q`)\n-/\nlemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\nbegin\n", "proof": "  exact h(p),\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 43, "name": "implications_one", "statement": "(P Q : Prop) (h : P \u2192 Q) (p : P) : Q"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "12", "hidden": true}, {"type": "lemma", "text": "13", "lean": "lemma implications_two (P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R :=\n", "sideBar": true, "firstProofLineNumber": 9, "lastProofLineNumber": 11, "textBefore": "import tactic --hide\n\n\n/-Lemma\nNow try the following one: \n-/\nlemma implications_two (P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R :=\nbegin\n", "proof": "  exact h2 (h1 (p)),\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 3, "editorText": "sorry", "lineOffset": 8, "name": "implications_two", "statement": "(P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R"}]}]}, {"name": "14", "levels": [{"name": "15", "problemIndex": -1, "objects": [{"type": "lean", "content": "16", "hidden": true}, {"type": "text", "content": "17"}]}, {"name": "18", "problemIndex": 3, "objects": [{"type": "lean", "content": "19", "hidden": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "text", "content": "21"}, {"type": "lemma", "text": "22", "lean": "lemma implies_self (P : Prop) : P \u2192 P :=\n", "sideBar": false, "firstProofLineNumber": 38, "lastProofLineNumber": 41, "textBefore": "import tactic --hide\n\nuniverse u --hide\n\n-- Level name : intro\n\n/-\n\nLets look at an example that needs the `intro` tactic: \n\nIf your goal is to prove `P \u2192 Q` (i.e. that $P\\implies Q$)\nthen `intro p`, meaning \"assume $p$ is a proof of $P$\", will make progress.\nTo solve the goal below, you have to come up with a function from\n`P` (thought of as the set of proofs of $P$!) to itself. Start with\n`intro p,`\n(i.e. \"let $p$ be a proof of $P$\") and note that our\nlocal context now looks like this:\n```\nP : Prop,\np : P\n\u22a2 P\n```\nOur job now is to construct a proof of $P$. But $p$ is a proof of $P$.\nSo\n`exact p,`\nwill close the goal. Note that `exact P` will not work -- don't\nconfuse a true/false statement (which could be false!) with a proof.\nWe will stick with the convention of capital letters for propositions\nand small letters for proofs.\n-/ \n\n\n/- Lemma : no-side-bar\nIf $P$ is a proposition then $P\\implies P$.\n-/\nlemma implies_self (P : Prop) : P \u2192 P :=\nbegin\n", "proof": "  intro p,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : intro\n\n## The `intro` tactic.\n\nIf your goal is\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill turn your tactic state into\n\n```\nhP : P\n\u22a2 Q\n```\n\nVariant: `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 <something else>`.\n\n-/", "height": 4, "editorText": "sorry", "lineOffset": 37, "name": "implies_self", "statement": "(P : Prop) : P \u2192 P"}, {"type": "tactic", "content": "23", "name": "intro", "sideBar": true}]}, {"name": "24", "problemIndex": 3, "objects": [{"type": "lean", "content": "25", "hidden": true}, {"type": "lean", "content": "26", "hidden": true}, {"type": "text", "content": "27"}, {"type": "lemma", "text": "28", "lean": "lemma implications_one_again (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 26, "textBefore": "import tactic --hide\n\nuniverse u --hide\n\n-- Level name : apply tactic\n\n/-\nLets look at using the apply tactic:\n\nHere's an example we have already done, but try and do it using the apply tactic:\n\n-/\n\n\n/- Lemma\nLets try and prove that if `P` implies `Q` (which is written ` P \u2192 Q`) and we have a proof of `P` \n(i.e. we have `p : P`). Then `Q` is true (i.e. we have a proof of `Q`)\n-/\n\nlemma implications_one_again (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\nbegin\n", "proof": "  apply h,\n  exact p,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : apply\n\n## The `apply` tactic\n\nIf your tactic state is\n\n```\nhPQ : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic\n\n`apply hPQ,`\n\nwill change it to\n\n```\nhPQ : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n-/", "height": 5, "editorText": "sorry", "lineOffset": 21, "name": "implications_one_again", "statement": "(P Q : Prop) (h : P \u2192 Q) (p : P) : Q"}, {"type": "tactic", "content": "29", "name": "apply", "sideBar": true}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "30", "hidden": true}, {"type": "lemma", "text": "31", "lean": "lemma lemma1 (P Q : Prop) (hQ : Q) : P \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 13, "textBefore": "import tactic -- hide\n\n/-Lemma\nAssume `Q` is true. Prove that `P \u2192 Q`. \n-/\nlemma lemma1 (P Q : Prop) (hQ : Q) : P \u2192 Q :=\nbegin\n", "proof": "  intro fish,\n  exact hQ,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 7, "name": "lemma1", "statement": "(P Q : Prop) (hQ : Q) : P \u2192 Q"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "32", "hidden": true}, {"type": "text", "content": "33"}, {"type": "lemma", "text": "34", "lean": "lemma lemma2 (P Q : Prop) : P \u2192 Q \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 27, "textBefore": "import tactic -- hide\n\n/-\nNote that implies `\u2192` is not associative: in general `P \u2192 (Q \u2192 R)` and `(P \u2192 Q) \u2192 R`\nmight not be equivalent. This is like subtraction on numbers -- in general\n`a - (b - c)` and `(a - b) - c` might not be equal.\nSo if we write `P \u2192 Q \u2192 R` then we'd better know what this means.\nThe convention in Lean is that it means `P \u2192 (Q \u2192 R)`. If you think\nabout it, this means that to deduce `R` you will need to prove both `P`\nand `Q`. \n\nIn general to prove `P1 \u2192 P2 \u2192 P3 \u2192 ... Pn` you can assume\n`P1`, `P2`,...,`P(n-1)` and then you have to prove `Pn`. \nSo the next level is asking you prove that `P \u2192 (Q \u2192 P)`.\n-/\n\n/-Lemma \nProve $P$ implies $(P \\implies Q)$\n-/\nlemma lemma2 (P Q : Prop) : P \u2192 Q \u2192 P :=\nbegin\n", "proof": "  intro hP,\n  intro hQ,\n  exact hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 21, "name": "lemma2", "statement": "(P Q : Prop) : P \u2192 Q \u2192 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "35", "hidden": true}, {"type": "lemma", "text": "36", "lean": "lemma Modus_Ponens (P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 15, "textBefore": "import tactic -- hide\n\n\n/- Lemma  \nIf we know `P`, and we also know `P \u2192 Q`, we can deduce `Q`. \nThis is called \"Modus Ponens\" by logicians.\n-/\nlemma Modus_Ponens (P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q :=\nbegin\n", "proof": "  intros hP hPQ,\n  apply hPQ,\n  exact hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 9, "name": "Modus_Ponens", "statement": "(P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "37", "hidden": true}, {"type": "lemma", "text": "38", "lean": "lemma implicationss_are_transitive (P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R) :=\n", "sideBar": true, "firstProofLineNumber": 9, "lastProofLineNumber": 15, "textBefore": "import tactic --hide\n\n/-Lemma  \nLets show that implications are transitive. That is, if `P \u2192 Q` and `Q \u2192 R` are true, then\nso is `P \u2192 R`.\n-/\nlemma implicationss_are_transitive (P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R) :=\nbegin\n", "proof": "  intros hPQ hQR hP,\n  apply hQR,\n  apply hPQ,\n  exact hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 8, "name": "implicationss_are_transitive", "statement": "(P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R)"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "39", "hidden": true}, {"type": "text", "content": "40"}, {"type": "lemma", "text": "41", "lean": "lemma lemma5 (P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R) :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 30, "textBefore": "import tactic --hide\n\n\n/-\nFor the next one you might need to note the following:\n\nIf we have the assumption `h : P \u2192 Q \u2192 R` with goal `\u22a2 R` and you `apply h`, then you'll get\ntwo goals! \n\nNote that tactics operate on only the first goal. So you'll have to first prove the \nfirst goal and then move onto the second. \n\nTip:  If you have multiple goals and you want to work on one that isnt the first one you can \nwrite `sorry,` to skip a proving a goal (although you will need to come back to it \neventually to complete the proof!)\n-/\n\n/-Lemma \nProve $(P \\implies Q \\implies R) \\implies ((P \\implies Q) \\implies (P \\implies R)$\n-/\nlemma lemma5 (P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R) :=\nbegin\n", "proof": "  intros hPQR hPQ hP,\n  apply hPQR,\n  { exact hP },\n  { apply hPQ,\n    exact hP }\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 8, "editorText": "sorry", "lineOffset": 22, "name": "lemma5", "statement": "(P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R)"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "42", "hidden": true}, {"type": "text", "content": "43"}, {"type": "lemma", "text": "44", "lean": "lemma lemma6 (P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T :=\n", "sideBar": true, "firstProofLineNumber": 13, "lastProofLineNumber": 20, "textBefore": "import tactic --hide\n\n/-\nLets try some harder ones\n-/\n\n\n/-Lemma \nThis isn't so bad\n-/\nlemma lemma6 (P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T :=\nbegin\n", "proof": "  intros hPR hSQ hRT hQR hS,\n  apply hRT,\n  apply hQR,\n  apply hSQ,\n  exact hS,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 8, "editorText": "sorry", "lineOffset": 12, "name": "lemma6", "statement": "(P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "45", "hidden": true}, {"type": "lemma", "text": "46", "lean": "lemma lemma7 (P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-Lemma \nMore nested implications:\n-/\nlemma lemma7 (P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q :=\nbegin\n", "proof": "  intros hPQ hPQP,\n  apply hPQ,\n  apply hPQP,\n  exact hPQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 7, "name": "lemma7", "statement": "(P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "47", "hidden": true}, {"type": "lemma", "text": "48", "lean": "lemma lemma8 (P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 16, "textBefore": "import tactic --hide\n\n/-Lemma\nEven more nested implications\n-/\nlemma lemma8 (P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P :=\nbegin\n", "proof": "  intros h1 h2 h3,\n  apply h2,\n  intro hQ,\n  apply h1,\n  intro hP,\n  exact hQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 7, "name": "lemma8", "statement": "(P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "49", "hidden": true}, {"type": "lemma", "text": "50", "lean": "lemma lemma9 (P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 16, "textBefore": "import tactic --hide\n\n/-Lemma\nThis is getting silly now\n-/\nlemma lemma9 (P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P :=\nbegin\n", "proof": "  intros h1 h2 h3,\n  apply h1,\n  intro hQ,\n  apply h3,\n  apply h2,\n  exact hQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 7, "name": "lemma9", "statement": "(P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "51", "hidden": true}, {"type": "lemma", "text": "52", "lean": "lemma lemma10 (P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q) :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-Lemma\nHow hard could it be?\n-/\nlemma lemma10 (P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q) :=\nbegin\n", "proof": "  intros h1 hP,\n  apply h1,\n  intro hPQ,\n  exact hPQ hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 7, "name": "lemma10", "statement": "(P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q)"}]}, {"name": "53", "problemIndex": 1, "objects": [{"type": "lean", "content": "54", "hidden": true}, {"type": "lemma", "text": "55", "lean": "lemma boss_lemma_1 (P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 22, "textBefore": "import tactic --hide\n\n-- Level name : Boss fight 1\n\n\n/-Lemma\nTime for a boss fight!\n-/\nlemma boss_lemma_1 (P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R :=\nbegin\n", "proof": "  intros h1 h2 h3,\n  apply h2,\n  intros h1 hP h2,\n  apply h1,\n  intro hP,\n  exact h2,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 13, "name": "boss_lemma_1", "statement": "(P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R"}]}], "parents": [0]}, {"name": "56", "levels": [{"name": "57", "problemIndex": -1, "objects": [{"type": "lean", "content": "58", "hidden": true}, {"type": "text", "content": "59"}, {"type": "lean", "content": "60", "hidden": false}, {"type": "tactic", "content": "61", "name": "split", "sideBar": true}, {"type": "tactic", "content": "62", "name": "left and right", "sideBar": true}, {"type": "tactic", "content": "63", "name": "cases", "sideBar": true}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "64", "hidden": true}, {"type": "text", "content": "65"}, {"type": "lemma", "text": "66", "lean": "lemma and_symmetric (P Q : Prop) : P \u2227 Q \u2194 Q \u2227 P :=\n", "sideBar": true, "firstProofLineNumber": 12, "lastProofLineNumber": 23, "textBefore": "import tactic --hide\n\n/-\nLets start with something easy. Lets prove that $P \u2227 Q$ iff $Q \u2227 P$\n-/\n\n/-Lemma\nProving `\u2227` is symmetric\n-/\nlemma and_symmetric (P Q : Prop) : P \u2227 Q \u2194 Q \u2227 P :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h,\n  split,\n  exact h_right,\n  exact h_left,\n  intro h,\n  split,\n  exact h.2,\n  exact h.1,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 12, "editorText": "sorry", "lineOffset": 11, "name": "and_symmetric", "statement": "(P Q : Prop) : P \u2227 Q \u2194 Q \u2227 P"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "67", "hidden": true}, {"type": "text", "content": "68"}, {"type": "lemma", "text": "69", "lean": "lemma and_symmetric (P Q R : Prop) :  P \u2228 Q \u2192 (P \u2192 R) \u2192 (Q \u2192 R) \u2192 R :=\n", "sideBar": true, "firstProofLineNumber": 12, "lastProofLineNumber": 17, "textBefore": "import tactic --hide\n\n/-\nOk lets mix things up a bit:\n-/\n\n/-Lemma\nLets prove that $P \u2227 Q$ implies that $(P \\implies R) \\implies (Q \\implies R) \\implies R$ \n-/\nlemma and_symmetric (P Q R : Prop) :  P \u2228 Q \u2192 (P \u2192 R) \u2192 (Q \u2192 R) \u2192 R :=\nbegin\n", "proof": "  intros hPoQ hPR hQR,\n  cases hPoQ with hP hQ,\n  { apply hPR,\n    exact hP },\n  { exact hQR hQ }\n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 11, "name": "and_symmetric", "statement": "(P Q R : Prop) :  P \u2228 Q \u2192 (P \u2192 R) \u2192 (Q \u2192 R) \u2192 R"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "70", "hidden": true}, {"type": "text", "content": "71"}, {"type": "lemma", "text": "72", "lean": "lemma and_transitive (P Q R: Prop) : (P \u2227 Q) \u2192 (Q \u2227 R) \u2192 (P \u2227 R)  :=\n", "sideBar": true, "firstProofLineNumber": 12, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-\nLet now show that `\u2227` is transitive\n-/\n\n/-Lemma\nProving `\u2227` is transitive\n-/\nlemma and_transitive (P Q R: Prop) : (P \u2227 Q) \u2192 (Q \u2227 R) \u2192 (P \u2227 R)  :=\nbegin\n", "proof": "  rintro \u27e8hP, hQ\u27e9 \u27e8-, hR\u27e9,\n  exact \u27e8hP, hR\u27e9,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 3, "editorText": "sorry", "lineOffset": 11, "name": "and_transitive", "statement": "(P Q R: Prop) : (P \u2227 Q) \u2192 (Q \u2227 R) \u2192 (P \u2227 R)"}]}, {"name": "73", "problemIndex": 1, "objects": [{"type": "lean", "content": "74", "hidden": true}, {"type": "lemma", "text": "75", "lean": "lemma absorption_one (P Q : Prop) : P \u2227 (P \u2228 Q) \u2194 P :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 18, "textBefore": "import tactic --hide\n\n-- Level name : absorpsion laws pt 1\n\n/-Lemma\nLets try and prove that $P \u2227 (P \u2228 Q)$ is equivalent to $P$\n-/\nlemma absorption_one (P Q : Prop) : P \u2227 (P \u2228 Q) \u2194 P :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with hP hPQ,\n  exact hP,\n  intro h,\n  split,\n  exact h,\n  left,\n  exact h,  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 9, "editorText": "sorry", "lineOffset": 9, "name": "absorption_one", "statement": "(P Q : Prop) : P \u2227 (P \u2228 Q) \u2194 P"}]}, {"name": "76", "problemIndex": 1, "objects": [{"type": "lean", "content": "77", "hidden": true}, {"type": "lemma", "text": "78", "lean": "lemma absorption_two (P Q : Prop) : P \u2228 (P \u2227 Q) \u2194 P :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 18, "textBefore": "import tactic --hide\n\n-- Level name : absorpsion laws pt 2\n\n/-Lemma\nLets try and prove that $P \u2228 (P \u2227 Q)$ is equivalent to $P$\n-/\nlemma absorption_two (P Q : Prop) : P \u2228 (P \u2227 Q) \u2194 P :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h,\n  exact h,\n  cases h,\n  exact h_left,\n  intro h,\n  left,\n  exact h,", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 9, "name": "absorption_two", "statement": "(P Q : Prop) : P \u2228 (P \u2227 Q) \u2194 P"}]}, {"name": "79", "problemIndex": 1, "objects": [{"type": "lean", "content": "80", "hidden": true}, {"type": "lemma", "text": "81", "lean": "lemma associativity_one (P Q R : Prop) : P \u2227 (Q \u2227 R) \u2194 (P \u2227 Q) \u2227 R :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 27, "textBefore": "import tactic --hide\n\n-- Level name : Associative laws pt 1\n\n/-Lemma\nLets prove that $P \u2227 (Q \u2227 R)$ is equivalent to $(P \u2227 Q) \u2227 R$\n-/\nlemma associativity_one (P Q R : Prop) : P \u2227 (Q \u2227 R) \u2194 (P \u2227 Q) \u2227 R :=\nbegin\n", "proof": "  split,\n  intro h,\n  split,\n  cases h with hl hr,\n  split,\n  exact hl,\n  cases hr,\n  exact hr_left,\n  cases h with h1 h2,\n  cases h2 with h2 h3,\n  exact h3,\n  intro h,\n  split,\n  cases h,\n  exact h_left.1,\n  split,\n  exact h.1.2,\n  exact h.2,", "proof_hint": "sorry", "textAfter": "\nend", "height": 18, "editorText": "sorry", "lineOffset": 9, "name": "associativity_one", "statement": "(P Q R : Prop) : P \u2227 (Q \u2227 R) \u2194 (P \u2227 Q) \u2227 R"}]}, {"name": "82", "problemIndex": 1, "objects": [{"type": "lean", "content": "83", "hidden": true}, {"type": "lemma", "text": "84", "lean": "lemma associativity_two (P Q R : Prop) : P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 32, "textBefore": "import tactic --hide\n\n-- Level name : Associative laws pt 2\n\n/-Lemma\nLets prove that $P \u2228 (Q \u2228 R)$ is equivalent to $(P \u2228 Q) \u2228 R$\n-/\nlemma associativity_two (P Q R : Prop) : P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with h1 h2,\n  left,\n  left,\n  exact h1,\n  cases h2 with h2 h3,\n  left,\n  right,\n  exact h2,\n  right,\n  exact h3,\n  intro h,\n  cases h with h1 h2,\n  cases h1 with h1 h3,\n  left,\n  exact h1,\n  right,\n  left,\n  exact h3,\n  right,\n  right,\n  exact h2,", "proof_hint": "sorry", "textAfter": "\nend", "height": 23, "editorText": "sorry", "lineOffset": 9, "name": "associativity_two", "statement": "(P Q R : Prop) : P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R"}]}, {"name": "85", "problemIndex": 1, "objects": [{"type": "lean", "content": "86", "hidden": true}, {"type": "lemma", "text": "87", "lean": "lemma distributivity_one (P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R) :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 31, "textBefore": "import tactic --hide\n\n-- Level name : Distributive laws 1\n\n/-Lemma\nLets prove that $P \u2227 (Q \u2228 R)$ is equivalent to $(P \u2227 Q) \u2228 (P \u2227 R)$\n-/\nlemma distributivity_one (P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R) :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with h1 h2,\n  cases h2 with h2 h3,\n  left,\n  split,\n  exact h1,\n  exact h2,\n  right,\n  split,\n  exact h1,\n  exact h3,\n  intro h,\n  cases h with h1 h2,\n  split,\n  exact h1.1,\n  left,\n  exact h1.2,\n  split,\n  exact h2.1,\n  right,\n  exact h2.2,", "proof_hint": "sorry", "textAfter": "\nend ", "height": 22, "editorText": "sorry", "lineOffset": 9, "name": "distributivity_one", "statement": "(P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R)"}]}, {"name": "88", "problemIndex": 1, "objects": [{"type": "lean", "content": "89", "hidden": true}, {"type": "lemma", "text": "90", "lean": "lemma distributivity_two (P Q R : Prop) : P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R) :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 34, "textBefore": "import tactic --hide\n\n-- Level name : Distributive laws 1\n\n/-Lemma\nLets prove that $P \u2228 (Q \u2227 R)$ is equivalent to $(P \u2228 Q) \u2227 (P \u2228 R)$\n-/\nlemma distributivity_two (P Q R : Prop) : P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R) :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h,\n  split,\n  left,\n  exact h,\n  left,\n  exact h,\n  split,\n  right,\n  exact h.1,\n  right,\n  exact h.2,\n  intro h,\n  cases h,\n  cases h_left with h1 h2,\n  left,\n  exact h1,\n  cases h_right with h4 h5,\n  left,\n  exact h4,\n  right,\n  split,\n  exact h2,\n  exact h5,", "proof_hint": "sorry", "textAfter": "\nend", "height": 25, "editorText": "sorry", "lineOffset": 9, "name": "distributivity_two", "statement": "(P Q R : Prop) : P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R)"}]}], "parents": [1]}, {"name": "91", "levels": [{"name": "", "problemIndex": 5, "objects": [{"type": "axiom", "content": "92", "name": "not_iff_imp_false (P : Prop) :", "sideBar": true}, {"type": "text", "content": "93"}, {"type": "lean", "content": "94", "hidden": true}, {"type": "text", "content": "95"}, {"type": "hint", "content": "96", "title": "97"}, {"type": "lemma", "text": "98", "lean": "lemma contrapositive (P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P) :=\n", "sideBar": true, "firstProofLineNumber": 42, "lastProofLineNumber": 51, "textBefore": "/- Axiom : not_iff_imp_false (P : Prop) :\n\u00ac P \u2194 P \u2192 false\n-/\n\n/-\nThere is a false proposition `false`, with no proof. It is\neasy to check that $\\lnot Q$ is equivalent to $Q\\implies {\\tt false}$. Lets call this\n\n`not_iff_imp_false (P : Prop) : \u00ac P \u2194 (P \u2192 false)`\n\n-/\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n/-\n\nIn order to use it, lets look at a new tactic.\n\n## The `rw` tactic\n\nThe `rw` tactic or ``rewrite`` is a tactic that allows you to substitute in things. For example, if we have the\nassumption `h: P \u2194 Q`, then `rw h` will replace the `P`'s in the goal with `Q`'s. If instead you would like to \nturn all of the `Q`'s in your goal to `P`'s then using `rw \u2190h` will do this. (To get the `\u2190` arrow, type `\\l`)\n\n\n(This also works for equalities, but we won't see them in this game).\n\n\nUsing `rw` and `not_iff_imp_false`, try to prove the following:\n\n-/\n\n/- Hint : using rw\n Start by using `rw not_iff_imp_false,` and see what changes.\n-/\n\n\n/- Lemma \nIf $P$ and $Q$ are propositions, and $P\\implies Q$, then\n$\\lnot Q\\implies \\lnot P$. \n-/\nlemma contrapositive (P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P) :=\nbegin\n", "proof": "  rw not_iff_imp_false,\n  rw not_iff_imp_false,\n  intro f,\n  intro h,\n  intro p,\n  apply h,\n  apply f,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n\n\n-/\n\n\n/- Tactic : rw \n\nThe `rw` tactic or ``rewrite`` is a tactic that allows you to substitute in things. For example, if we have the\nassumption `h: P \u2194 Q`, then `rw h` will replace the `P`'s in the goal with `Q`'s. If instead you would like to \nturn all of the `Q`'s in your goal to `P`'s then using `rw \u2190h` will do this. (To get the `\u2190` arrow, type `\\l`)\n\n-/", "height": 10, "editorText": "sorry", "lineOffset": 41, "name": "contrapositive", "statement": "(P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)"}, {"type": "text", "content": "99"}, {"type": "tactic", "content": "100", "name": "rw", "sideBar": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "101", "hidden": true}, {"type": "lean", "content": "102", "hidden": true}, {"type": "text", "content": "103"}, {"type": "lemma", "text": "104", "lean": "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 32, "textBefore": "\nimport tactic --hide\n\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n\n/-\n##  `exfalso` and proof by contradiction. \nIt's certainly true that $P\\land(\\lnot P)\\implies Q$ for any propositions $P$\nand $Q$, because the left hand side of the implication is false. But how do\nwe prove that `false` implies any proposition $Q$? A cheap way of doing it in\nLean is using the `exfalso` tactic, which changes any goal at all to `false`. \nYou might think this is a step backwards, but if you have a hypothesis `h : \u00ac P`\nthen after `rw not_iff_imp_false at h,` you can `apply h,` to make progress. \nTry solving this level using `exfalso.\n-/\n\n\n\n/- Lemma \nIf $P$ and $Q$ are true/false statements, then\n$$(P\\land(\\lnot P))\\implies Q.$$\n-/\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q :=\nbegin\n", "proof": "  intro h,\n  cases h with p np,\n  rw not_iff_imp_false at np,\n  exfalso,\n  apply np,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-Tactic : exofalso\nThis changes any goal to `false`.\n-/", "height": 8, "editorText": "sorry", "lineOffset": 24, "name": "contra", "statement": "(P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q"}, {"type": "tactic", "content": "105", "name": "exofalso", "sideBar": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "106", "hidden": true}, {"type": "lean", "content": "107", "hidden": true}, {"type": "lean", "content": "108", "hidden": true}, {"type": "text", "content": "109"}, {"type": "hint", "content": "110", "title": "111"}, {"type": "lemma", "text": "112", "lean": "lemma contrapositive2 (P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q) :=\n", "sideBar": false, "firstProofLineNumber": 54, "lastProofLineNumber": 74, "textBefore": "\nimport tactic --hide\n\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n\n/-\nWe proved earlier that `(P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)`. The converse,\nthat `(\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q)` is certainly true, but trying to prove\nit using what we've learnt so far is impossible (because it is not provable in\nconstructive logic). For example, after\n```\nintro h,\nintro p,\nrepeat {rw not_iff_imp_false at h},\n```\nin the below, you are left with\n```\nP Q : Prop,\nh : (Q \u2192 false) \u2192 P \u2192 false\np : P\n\u22a2 Q\n```\nThe tools you have are not sufficient to continue. But you can just\nprove this, and any other basic lemmas of this form like `\u00ac \u00ac P \u2192 P`,\nusing the `by_cases` tactic. Instead of starting with all the `intro`s,\ntry this instead:\n`by_cases p : P; by_cases q : Q,`\n**Note the semicolon**! It means \"do the next tactic to all the goals, not just the top one\".\nAfter it, there are four goals, one for each of the four possibilities PQ=TT, TF, FT, FF.\nYou can see that `p` is a proof of `P` in some of the goals, and a proof of `\u00ac P` in others.\nSimilar comments apply to `q`. \n\nNote that using `by_cases` is the same as doing a truth table for the result you want to prove.\n\nYou may also want to use some of the previous results we have used, for example the `contra` lemma we proved\nin the previous level. To use this try something like `apply contra P Q`. Alternatively, there is a tactic \n`contradiction` that will look at your assumptions and try and close the goal for you.\n\n\n-/\n\n/-Hint : Hint\nAlong with `by_cases p : P; by_cases q : Q,` you may also want to use `apply contra P false`\n-/\n\n\n/- Lemma : no-side-bar\nIf $P$ and $Q$ are true/false statements, then\n$$(\\lnot Q\\implies \\lnot P)\\implies(P\\implies Q).$$ \n-/\nlemma contrapositive2 (P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q) :=\nbegin\n", "proof": "  by_cases p : P; by_cases q : Q,\n  intros h hh,\n  exact q,\n  intros h hh,\n  exfalso,\n  apply contra P false,\n  split,\n  exact hh,\n  apply h,\n  exact q,\n  intros h hh,\n  exact q,\n  intros h hh,\n  exfalso,\n  apply contra P false,\n  split,\n  exact hh,\n  apply h,\n  exact q,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nThis approach assumed that `P \u2228 \u00ac P` was true; the `by_cases` tactic just does `cases` on\nthis result. This is called the law of the excluded middle, and it cannot be proved just\nusing tactics such as `intro` and `apply`.\n-/\n\n/-Tactic : by_cases\n\nAll propositional logic problems can in theory be solved by just throwing a truth table at them. \nThe ``by_cases`` tactic is a simple truth table tactic: ``by_cases P`` turns one goal into two goals, \nwith ``P`` is assumed in the first, and ``\u00c2\u00acP`` in the second.\n\nExamples\n--------\n\n1) If ``P`` is a proposition, then ``by_cases P`` turns your goal into two goals, \nand in each of your new tactic states you have one extra hypothesis. \nIn the first one you have a new hypothesis ``h : P`` and in the second you have a new hypothesis ``h : \u00acP``.\n\n2) If you already have a hypothesis ``h`` then this can get a bit confusing, \nso you can also do ``by_cases hP : P``; then your new hypotheses will be ``hP : P`` and ``hP : \u00acP``.\n-/", "height": 21, "editorText": "sorry", "lineOffset": 53, "name": "contrapositive2", "statement": "(P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q)"}, {"type": "text", "content": "113"}, {"type": "tactic", "content": "114", "name": "by_cases", "sideBar": true}]}], "parents": [1, 2]}, {"name": "115", "levels": [{"name": "116", "problemIndex": 7, "objects": [{"type": "lean", "content": "117", "hidden": true}, {"type": "lean", "content": "118", "hidden": true}, {"type": "lean", "content": "119", "hidden": true}, {"type": "text", "content": "120"}, {"type": "hint", "content": "121", "title": "122"}, {"type": "hint", "content": "123", "title": "124"}, {"type": "hint", "content": "125", "title": "126"}, {"type": "lemma", "text": "127", "lean": "lemma DeMorgan_one (P Q : Prop) : \u00ac (P \u2228 Q) \u2194 \u00ac P \u2227 \u00ac Q :=\n", "sideBar": true, "firstProofLineNumber": 37, "lastProofLineNumber": 50, "textBefore": "import tactic --hide\n\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n\n-- Level name : De Morgan's laws, First Boss\n\n/-\nOk time to use everything we have leaned to prove the first of De Morgans laws.\n\n-/\n\n/-Hint : First hint\n\nYou can do this only using `split`, `intro`, `apply`, `left`, `right`.\n\n-/\n\n/- Hint : Second hint\n\nNote that if you have a goal `\u00acP` then `intro h` will turn your goal into `false`.\n\n-/\n\n/- Hint : Last hint\n\nNote that if you have a goal `false` and an assumption `h : \u00acP`, then `apply h` will turn your goal into `P`.\n\n-/\n\n/-Lemma\nNot $P$ or $Q$ is equivalent to $\u00ac P$ and $\u00acQ$.\n-/\n\nlemma DeMorgan_one (P Q : Prop) : \u00ac (P \u2228 Q) \u2194 \u00ac P \u2227 \u00ac Q :=\nbegin\n", "proof": "  split,\n  { intro h,\n    split,\n    { intro hP,\n      apply h,\n      left, \n      exact hP },\n    { intro hQ,\n      apply h,\n      right,\n      exact hQ } },\n  { rintro \u27e8hnP, hnQ\u27e9 (hP | hQ),\n    { apply hnP, exact hP },\n    { exact hnQ hQ } }", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 14, "editorText": "sorry", "lineOffset": 36, "name": "DeMorgan_one", "statement": "(P Q : Prop) : \u00ac (P \u2228 Q) \u2194 \u00ac P \u2227 \u00ac Q"}]}, {"name": "128", "problemIndex": 3, "objects": [{"type": "lean", "content": "129", "hidden": true}, {"type": "lean", "content": "130", "hidden": true}, {"type": "lean", "content": "131", "hidden": true}, {"type": "lemma", "text": "132", "lean": "lemma DeMorgan_two (P Q : Prop) :  \u00ac (P \u2227 Q) \u2194 \u00ac P \u2228 \u00ac Q :=\n", "sideBar": true, "firstProofLineNumber": 15, "lastProofLineNumber": 29, "textBefore": "import tactic --hide\n\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n\n\n-- Level name : De Morgan's laws, Final Boss\n\n/-Lemma\nNot $P$ and $Q$ is equivalent to $\u00ac P$ or $\u00acQ$.\n-/\n\nlemma DeMorgan_two (P Q : Prop) :  \u00ac (P \u2227 Q) \u2194 \u00ac P \u2228 \u00ac Q :=\nbegin\n", "proof": "  split,\n  { intro h,\n    by_cases hP : P,\n    { right,\n      intro hQ,\n      apply h,\n      exact \u27e8hP, hQ\u27e9 },\n    { left,\n      exact hP } },\n  { rintro (hnP | hnQ) \u27e8hP, hQ\u27e9,\n    { apply contra P false,\n      split,\n      exact hP,\n      exact hnP, },\n    { apply hnQ, exact hQ } }", "proof_hint": "sorry", "textAfter": "\nend", "height": 15, "editorText": "sorry", "lineOffset": 14, "name": "DeMorgan_two", "statement": "(P Q : Prop) :  \u00ac (P \u2227 Q) \u2194 \u00ac P \u2228 \u00ac Q"}]}], "parents": [0, 1, 2, 3]}], "texts": [["De Morgan's game", "# Captain De Morgan's logic Game\n\n## By Chris Birkbeck and Niki Kalaydzhieva\n\nLearn some logic yo\n\n# What is this game?\n\nThis is a game to teach you some mathematical logic using Lean.\n\nHave fun!\n\n# Credits\n\nSome levels have been shamelessly borrowed from Kevin Buzzard's and Mohammad Pedramfar's \n\"Natural Numbers Game\" as well as  Kevin Buzzard's \"Formalizing mathematics\" course at \nImperial College. \n\n\n", "Tutorial", "import tactic --hide\n", "\n#Logical statements \n\nYou've seen logical statements already, these are statements that can be true or false, for example: \n\n-The sum of two odd numbers is an even number\n\n-$36$ is divisible by $3$\n\n-$x > 2$\n\n\nLets see how one does this a computer, specifically in lean. In lean, logical staments live in a \nworld called `Prop`. So for example if we write `P : Prop` we mean \"$P$ is a logical statement.\" \nThink of the `:` symbol as saying $P$  is a resident of `Prop` world (in maths this would be denoted\nby something like `P \u2208 Prop`).\n\n#Truth Values\n\nThe truth value of a logical statement (i.e. some `P : Prop`) is whether the statement is true or \nfalse.  For example, the truth value of the statement: \"For all integers $x \u2208 \u2124$,  $0 \u2264 x^2$\" \nis *true* while  \"For all integers $x \u2208 \u2124$,  $0 \u2264 x^3$\" is *false*. \n\nIn lean we assign truth values as follows: We first think of a proposition $P$ as a set with \n*at most* one element.  If this set is empty, then we say `P` is *false*. Otherwise, if this set has \nan element, lets call it $p$ (we will usually use upper case letters for logical statements, \nand lower case for their proofs), then this  statement is *true* and $p$ is the proof. \n\nSo to recap, if $P$ is the true/false statement (the statement of proposition), and $p$ is its proof.\nIt's like thinking $P$ being the set and $p$ being the element. Just as above, where we had \n`P : Prop` to mean $P$  is a proposition, we write `p : P` to mean \"$p$ is a proof of $P$\".\n\nThe aim of this game is to learn how to manipulate logical statements and their proofs. \nLets start with a super basic example of how a lemma looks like in lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, \non the right you will  see the following: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere the first two lines are our assumptions and the thing after the `\u22a2` symbol is what we are \nbeing asked to prove. \n\nNow, in this game our \"moves\" or, as we call them in lean, *Tactics*, are what will allow us to \nmanipulate our statement and produce proofs.\n\nThe first tactic we will look at is called *exact* and what it does is, if you need to prove a \nstatement $P$ and you have proof of it, say, `p: P`, then `exact p` will prove it. \n\nNote that at the end of each line we write we need to have a comma `,` to tell lean that this is the \nend of our move. \n\nSo if below you change the `sorry` for \"`exact p,`\" (don't forget the comma!) you'll see that on the \nright it will change to say `Proof complete!`. \n\n", "Lets try and prove that if $P$ is a logical stament (i.e. `P : Prop`) and $p$ is a proof of $P$ \n(i.e. `p : P`) then $P$ is true.\n", "## Summary \nIf the goal is `\u22a2 P` then `exact p` will close the goal if\nand only if `p` is a proof of `P` (i.e. `p : P`) \n## Details\nSay $P$, $Q$ and $R$ are logical staments\nand the local context looks like this: \n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n`exact j(h(p)),`\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n", "import tactic --hide \n", "Now try the following one:\n", "import tactic --hide \n", "\n#Combining logical statements\n\nNow, we can take these statements and create new ones. For example if we have two statements \n`P Q : Prop` we can write ` P \u2192 Q` to mean $P$ implies $Q$. Similarly, we can write `\u00acP` for the \nstatement \"Not $P$\". \n\nSay we have the following lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nThis asks us to prove: If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ \n(i.e. we have `p : P`). Then $Q$ is true (i.e. we have a proof of `Q`). \n\nHere we have given the name $h$ to the implication ` P \u2192 Q`. We think of $h$ as a map between \nstatements in `Prop` world. \n\nNow this lemma is asking us to take a proof of $P$ and turn it into a proof of $Q$. Since we know \nthat $P$ implies $Q$ then we know that if $P$ is true then so is $Q$. So we can use our map in \n`Prop` world to transform our proof of $P$ into a proof of $Q$. \n\nIf we write `exact h(p)` below we get what we want.\n\nNote that it has to be lower case $p$, since $P$ is the logical statement, but what we want to \ntransform is the proof.\n\n\n\n", "If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ (i.e. we have `p : P`). \nThen $Q$ is true (i.e. we have a proof of `Q`)\n", "import tactic --hide\n", "Now try the following one: \n", "Logical statements", "Tactics", "import tactic --hide\n", "\n## Tactics for Level 1\n\n## The `intro` tactic.\n\nIf your goal is\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill turn your tactic state into\n\n```\nhP : P\n\u22a2 Q\n```\n\nVariant: `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 <something else>`.\n\n## The `exact` tactic (we have already seen this)\n\nIf your tactic state is\n\n```\nhP : P\n\u22a2 P\n```\n\nthen the tactic\n\n`exact hP,`\n\nwill close your goal.\n\nNote: `exact P` does not work. Don't confuse\nthe *statement* `P` with its *proof* `hP`.\n\nVariant: The `assumption` tactic closes a goal if its proof is any one of the assumptions\nin the tactic state. \n\n## The `apply` tactic\n\nIf your tactic state is\n\n```\nhPQ : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic\n\n`apply hPQ,`\n\nwill change it to\n\n```\nhPQ : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n\n", "intro", "import tactic --hide\n", "universe u --hide\n", "\nLets look at an example that needs the `intro` tactic: \n\nIf your goal is to prove `P \u2192 Q` (i.e. that $P\\implies Q$)\nthen `intro p`, meaning \"assume $p$ is a proof of $P$\", will make progress.\nTo solve the goal below, you have to come up with a function from\n`P` (thought of as the set of proofs of $P$!) to itself. Start with\n`intro p,`\n(i.e. \"let $p$ be a proof of $P$\") and note that our\nlocal context now looks like this:\n```\nP : Prop,\np : P\n\u22a2 P\n```\nOur job now is to construct a proof of $P$. But $p$ is a proof of $P$.\nSo\n`exact p,`\nwill close the goal. Note that `exact P` will not work -- don't\nconfuse a true/false statement (which could be false!) with a proof.\nWe will stick with the convention of capital letters for propositions\nand small letters for proofs.\n", "If $P$ is a proposition then $P\\implies P$.\n", "\n## The `intro` tactic.\n\nIf your goal is\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill turn your tactic state into\n\n```\nhP : P\n\u22a2 Q\n```\n\nVariant: `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 <something else>`.\n\n", "apply tactic", "import tactic --hide\n", "universe u --hide\n", "Lets look at using the apply tactic:\n\nHere's an example we have already done, but try and do it using the apply tactic:\n\n", "Lets try and prove that if `P` implies `Q` (which is written ` P \u2192 Q`) and we have a proof of `P` \n(i.e. we have `p : P`). Then `Q` is true (i.e. we have a proof of `Q`)\n", "\n## The `apply` tactic\n\nIf your tactic state is\n\n```\nhPQ : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic\n\n`apply hPQ,`\n\nwill change it to\n\n```\nhPQ : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n", "import tactic -- hide\n", "Assume `Q` is true. Prove that `P \u2192 Q`. \n", "import tactic -- hide\n", "Note that implies `\u2192` is not associative: in general `P \u2192 (Q \u2192 R)` and `(P \u2192 Q) \u2192 R`\nmight not be equivalent. This is like subtraction on numbers -- in general\n`a - (b - c)` and `(a - b) - c` might not be equal.\nSo if we write `P \u2192 Q \u2192 R` then we'd better know what this means.\nThe convention in Lean is that it means `P \u2192 (Q \u2192 R)`. If you think\nabout it, this means that to deduce `R` you will need to prove both `P`\nand `Q`. \n\nIn general to prove `P1 \u2192 P2 \u2192 P3 \u2192 ... Pn` you can assume\n`P1`, `P2`,...,`P(n-1)` and then you have to prove `Pn`. \nSo the next level is asking you prove that `P \u2192 (Q \u2192 P)`.\n", "Prove $P$ implies $(P \\implies Q)$\n", "import tactic -- hide\n", "If we know `P`, and we also know `P \u2192 Q`, we can deduce `Q`. \nThis is called \"Modus Ponens\" by logicians.\n", "import tactic --hide\n", "Lets show that implications are transitive. That is, if `P \u2192 Q` and `Q \u2192 R` are true, then\nso is `P \u2192 R`.\n", "import tactic --hide\n", "For the next one you might need to note the following:\n\nIf we have the assumption `h : P \u2192 Q \u2192 R` with goal `\u22a2 R` and you `apply h`, then you'll get\ntwo goals! \n\nNote that tactics operate on only the first goal. So you'll have to first prove the \nfirst goal and then move onto the second. \n\nTip:  If you have multiple goals and you want to work on one that isnt the first one you can \nwrite `sorry,` to skip a proving a goal (although you will need to come back to it \neventually to complete the proof!)\n", "Prove $(P \\implies Q \\implies R) \\implies ((P \\implies Q) \\implies (P \\implies R)$\n", "import tactic --hide\n", "Lets try some harder ones\n", "This isn't so bad\n", "import tactic --hide\n", "More nested implications:\n", "import tactic --hide\n", "Even more nested implications\n", "import tactic --hide\n", "This is getting silly now\n", "import tactic --hide\n", "How hard could it be?\n", "Boss fight 1", "import tactic --hide\n", "Time for a boss fight!\n", "Distributivity, Associativity and Absorption", "and what?", "import tactic --hide\n", "Lets now look at making some more complicated logical statements. Recall that if we have two\nstatements $P,Q$ then we can form $P \u2227 Q$ which is true iff both $P$ and $Q$ are true.#check\n\nTo help us with this, lets introduce some new tactics.\n\n\n## Tactics for Level 2\n\n## The `split` tactic\n\nIf your goal is an \"and\" goal:\n\n```\n\u22a2 P \u2227 Q\n```\n\nthen the `split` tactic will turn it\ninto *two* goals\n\n\n```\n\u22a2 P\n```\n\nand\n\n```\n\u22a2 Q\n```\n\nIt is best practice to indicate when you are working with two goals, either by using squiggly \nbrackets like this:\n\n```\n...\nsplit,\n{ working on P,\n  end of proof of P },\n{ working on Q,\n  end of proof of Q },\n```\n\nor by using indentation like this:\n\n```\nsplit,\n  working on P,\n  end of proof of P,\nworking on Q,\n...\n```\n\nMoreover, if you have an iff `\u2194` then splitting it will give you two goals, `\u2192` and `\u2190` to prove.\n\n## `left` and `right`\n\nIf your goal is\n\n```\n\u22a2 P \u2228 Q\n```\n\nthen `left` changes the goal to `\u22a2 P`. The logic is that `P` implies `P \u2228 Q`\nso we can `apply` this implication. Similarly `right` changes the goal to `\u22a2 Q`\n\n## The `cases` tactic\n\n`cases` is a very general-purpose tactic for \"deconstructing\" hypotheses.\nIf `h` is a hypothesis which somehow \"bundles up\" two pieces of information,\nthen `cases h with h1 h2` will make hypothesis `h` vanish and will replace it\nwith the two \"components\" which made the proof of `h` in the first place.\nAn example of this occurring in logic sheet 4 is `h : P \u2227 Q` which is a\nbundling of a proof of `P` and a proof of `Q`.\n\n### Example\n\nIf you have a hypothesis\n\n```\nhPaQ : P \u2227 Q\n```\n\nthen\n\n`cases hPaQ with hP hQ,`\n\nwill delete `hPaQ` and replace it with\n\n```\nhP : P\nhQ : Q\n```\n\nYou can also use it for \"or's\". Specifically, if you have `h : P \u2228 Q` then `cases h` will\ngive you two goals, one where `P` is true and one where `Q` is true.\n\n\n", "example (P Q : Prop) (p : P) : P \u2228 Q :=\nbegin\n  left,\n  exact p,\nend\nexample (P Q : Prop) (p : P) (q : Q) : P \u2227 Q :=\nbegin\n  split,\n  exact p,\n  exact q,\nend\nexample (P : Prop) : P \u2194 P :=\nbegin\n  split,\n  intro p,\n  exact p,\n  intro p,\n  exact p,\nend\nexample (P Q : Prop) (hPQ: P \u2227 Q) : P :=\nbegin \n  cases hPQ with hP hQ,\n  exact hP,\nend\nexample (P : Prop) (hp : P \u2228 P) : P :=\nbegin\n  cases hp,\n  exact hp,\n  exact hp,\nend\n", "\nIf your goal is an \"and\" goal:\n\n```\n\u22a2 P \u2227 Q\n```\n\nthen the `split` tactic will turn it\ninto *two* goals\n\n\n```\n\u22a2 P\n```\n\nand\n\n```\n\u22a2 Q\n```\nMoreover, if you have an iff `\u2194` then splitting it will give you two goals, `\u2192` and `\u2190` to prove.\n\n", "\nIf your goal is\n\n```\n\u22a2 P \u2228 Q\n```\n\nthen `left` changes the goal to `\u22a2 P`. The logic is that `P` implies `P \u2228 Q`\nso we can `apply` this implication. Similarly `right` changes the goal to `\u22a2 Q`\n\n", "\nIf you have a hypothesis\n\n```\nhPaQ : P \u2227 Q\n```\n\nthen\n\n`cases hPaQ with hP hQ,`\n\nwill delete `hPaQ` and replace it with\n\n```\nhP : P\nhQ : Q\n```\n\nYou can also use it for \"or's\". Specifically, if you have `h : P \u2228 Q` then `cases h` will\ngive you two goals, one where `P` is true and one where `Q` is true.\n\n", "import tactic --hide\n", "Lets start with something easy. Lets prove that $P \u2227 Q$ iff $Q \u2227 P$\n", "Proving `\u2227` is symmetric\n", "import tactic --hide\n", "Ok lets mix things up a bit:\n", "Lets prove that $P \u2227 Q$ implies that $(P \\implies R) \\implies (Q \\implies R) \\implies R$ \n", "import tactic --hide\n", "Let now show that `\u2227` is transitive\n", "Proving `\u2227` is transitive\n", "absorpsion laws pt 1", "import tactic --hide\n", "Lets try and prove that $P \u2227 (P \u2228 Q)$ is equivalent to $P$\n", "absorpsion laws pt 2", "import tactic --hide\n", "Lets try and prove that $P \u2228 (P \u2227 Q)$ is equivalent to $P$\n", "Associative laws pt 1", "import tactic --hide\n", "Lets prove that $P \u2227 (Q \u2227 R)$ is equivalent to $(P \u2227 Q) \u2227 R$\n", "Associative laws pt 2", "import tactic --hide\n", "Lets prove that $P \u2228 (Q \u2228 R)$ is equivalent to $(P \u2228 Q) \u2228 R$\n", "Distributive laws 1", "import tactic --hide\n", "Lets prove that $P \u2227 (Q \u2228 R)$ is equivalent to $(P \u2227 Q) \u2228 (P \u2227 R)$\n", "Distributive laws 1", "import tactic --hide\n", "Lets prove that $P \u2228 (Q \u2227 R)$ is equivalent to $(P \u2228 Q) \u2227 (P \u2228 R)$\n", "Not logic", "\u00ac P \u2194 P \u2192 false\n", "There is a false proposition `false`, with no proof. It is\neasy to check that $\\lnot Q$ is equivalent to $Q\\implies {\\tt false}$. Lets call this\n\n`not_iff_imp_false (P : Prop) : \u00ac P \u2194 (P \u2192 false)`\n\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "\nIn order to use it, lets look at a new tactic.\n\n## The `rw` tactic\n\nThe `rw` tactic or ``rewrite`` is a tactic that allows you to substitute in things. For example, if we have the\nassumption `h: P \u2194 Q`, then `rw h` will replace the `P`'s in the goal with `Q`'s. If instead you would like to \nturn all of the `Q`'s in your goal to `P`'s then using `rw \u2190h` will do this. (To get the `\u2190` arrow, type `\\l`)\n\n\n(This also works for equalities, but we won't see them in this game).\n\n\nUsing `rw` and `not_iff_imp_false`, try to prove the following:\n\n", " Start by using `rw not_iff_imp_false,` and see what changes.\n", "using rw", "If $P$ and $Q$ are propositions, and $P\\implies Q$, then\n$\\lnot Q\\implies \\lnot P$. \n", "\n\n", "\nThe `rw` tactic or ``rewrite`` is a tactic that allows you to substitute in things. For example, if we have the\nassumption `h: P \u2194 Q`, then `rw h` will replace the `P`'s in the goal with `Q`'s. If instead you would like to \nturn all of the `Q`'s in your goal to `P`'s then using `rw \u2190h` will do this. (To get the `\u2190` arrow, type `\\l`)\n\n", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "##  `exfalso` and proof by contradiction. \nIt's certainly true that $P\\land(\\lnot P)\\implies Q$ for any propositions $P$\nand $Q$, because the left hand side of the implication is false. But how do\nwe prove that `false` implies any proposition $Q$? A cheap way of doing it in\nLean is using the `exfalso` tactic, which changes any goal at all to `false`. \nYou might think this is a step backwards, but if you have a hypothesis `h : \u00ac P`\nthen after `rw not_iff_imp_false at h,` you can `apply h,` to make progress. \nTry solving this level using `exfalso.\n", "If $P$ and $Q$ are true/false statements, then\n$$(P\\land(\\lnot P))\\implies Q.$$\n", "This changes any goal to `false`.\n", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "We proved earlier that `(P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)`. The converse,\nthat `(\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q)` is certainly true, but trying to prove\nit using what we've learnt so far is impossible (because it is not provable in\nconstructive logic). For example, after\n```\nintro h,\nintro p,\nrepeat {rw not_iff_imp_false at h},\n```\nin the below, you are left with\n```\nP Q : Prop,\nh : (Q \u2192 false) \u2192 P \u2192 false\np : P\n\u22a2 Q\n```\nThe tools you have are not sufficient to continue. But you can just\nprove this, and any other basic lemmas of this form like `\u00ac \u00ac P \u2192 P`,\nusing the `by_cases` tactic. Instead of starting with all the `intro`s,\ntry this instead:\n`by_cases p : P; by_cases q : Q,`\n**Note the semicolon**! It means \"do the next tactic to all the goals, not just the top one\".\nAfter it, there are four goals, one for each of the four possibilities PQ=TT, TF, FT, FF.\nYou can see that `p` is a proof of `P` in some of the goals, and a proof of `\u00ac P` in others.\nSimilar comments apply to `q`. \n\nNote that using `by_cases` is the same as doing a truth table for the result you want to prove.\n\nYou may also want to use some of the previous results we have used, for example the `contra` lemma we proved\nin the previous level. To use this try something like `apply contra P Q`. Alternatively, there is a tactic \n`contradiction` that will look at your assumptions and try and close the goal for you.\n\n\n", "Along with `by_cases p : P; by_cases q : Q,` you may also want to use `apply contra P false`\n", "Hint", "If $P$ and $Q$ are true/false statements, then\n$$(\\lnot Q\\implies \\lnot P)\\implies(P\\implies Q).$$ \n", "This approach assumed that `P \u2228 \u00ac P` was true; the `by_cases` tactic just does `cases` on\nthis result. This is called the law of the excluded middle, and it cannot be proved just\nusing tactics such as `intro` and `apply`.\n", "\nAll propositional logic problems can in theory be solved by just throwing a truth table at them. \nThe ``by_cases`` tactic is a simple truth table tactic: ``by_cases P`` turns one goal into two goals, \nwith ``P`` is assumed in the first, and ``\u00c2\u00acP`` in the second.\n\nExamples\n--------\n\n1) If ``P`` is a proposition, then ``by_cases P`` turns your goal into two goals, \nand in each of your new tactic states you have one extra hypothesis. \nIn the first one you have a new hypothesis ``h : P`` and in the second you have a new hypothesis ``h : \u00acP``.\n\n2) If you already have a hypothesis ``h`` then this can get a bit confusing, \nso you can also do ``by_cases hP : P``; then your new hypotheses will be ``hP : P`` and ``hP : \u00acP``.\n", "De Morgan's laws", "De Morgan's laws, First Boss", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "Ok time to use everything we have leaned to prove the first of De Morgans laws.\n\n", "\nYou can do this only using `split`, `intro`, `apply`, `left`, `right`.\n\n", "First hint", "\nNote that if you have a goal `\u00acP` then `intro h` will turn your goal into `false`.\n\n", "Second hint", "\nNote that if you have a goal `false` and an assumption `h : \u00acP`, then `apply h` will turn your goal into `P`.\n\n", "Last hint", "Not $P$ or $Q$ is equivalent to $\u00ac P$ and $\u00acQ$.\n", "De Morgan's laws, Final Boss", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "Not $P$ and $Q$ is equivalent to $\u00ac P$ or $\u00acQ$.\n"]]}