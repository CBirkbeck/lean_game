{"name": "De Morgan's game", "version": "1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "De Morgan's game-1.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "lemma", "text": "5", "lean": "lemma example1 (P : Prop) (p : P) : P :=\n", "sideBar": true, "firstProofLineNumber": 72, "lastProofLineNumber": 74, "textBefore": "import tactic --hide\n\n/-\n\n#Logical statements \n\nYou've seen logical statements already, these are statements that can be true or false, for example: \n\n-The sum of two odd numbers is an even number\n\n-$36$ is divisible by $3$\n\n-$x > 2$\n\n\nLets see how one does this a computer, specifically in lean. In lean, logical staments live in a \nworld called `Prop`. So for example if we write `P : Prop` we mean \"$P$ is a logical statement.\" \nThink of the `:` symbol as saying $P$  is a resident of `Prop` world (in maths this would be denoted\nby something like `P \u2208 Prop`).\n\n#Truth Values\n\nThe truth value of a logical statement (i.e. some `P : Prop`) is whether the statement is true or \nfalse.  For example, the truth value of the statement: \"For all integers $x \u2208 \u2124$,  $0 \u2264 x^2$\" \nis *true* while  \"For all integers $x \u2208 \u2124$,  $0 \u2264 x^3$\" is *false*. \n\nIn lean we assign truth values as follows: We first think of a proposition $P$ as a set with \n*at most* one element.  If this set is empty, then we say `P` is *false*. Otherwise, if this set has \nan element, lets call it $p$ (we will usually use upper case letters for logical statements, \nand lower case for their proofs), then this  statement is *true* and $p$ is the proof. \n\nSo to recap, if $P$ is the true/false statement (the statement of proposition), and $p$ is its proof.\nIt's like thinking $P$ being the set and $p$ being the element. Just as above, where we had \n`P : Prop` to mean $P$  is a proposition, we write `p : P` to mean \"$p$ is a proof of $P$\".\n\nThe aim of this game is to learn how to manipulate logical statements and their proofs. \nLets start with a super basic example of how a lemma looks like in lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, \non the right you will  see the following: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere the first two lines are our assumptions and the thing after the `\u22a2` symbol is what we are \nbeing asked to prove. \n\nNow, in this game our \"moves\" or, as we call them in lean, *Tactics*, are what will allow us to \nmanipulate our statement and produce proofs.\n\nThe first tactic we will look at is called *exact* and what it does is, if you need to prove a \nstatement $P$ and you have proof of it, say, `p: P`, then `exact p` will prove it. \n\nNote that at the end of each line we write we need to have a comma `,` to tell lean that this is the \nend of our move. \n\nSo if below you change the `sorry` for \"`exact p,`\" (don't forget the comma!) you'll see that on the \nright it will change to say `Proof complete!`. \n\n-/\n\n\n/- Lemma\nLets try and prove that if $P$ is a logical stament (i.e. `P : Prop`) and $p$ is a proof of $P$ \n(i.e. `p : P`) then $P$ is true.\n-/\nlemma example1 (P : Prop) (p : P) : P :=\nbegin\n", "proof": "  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : exact\n## Summary \nIf the goal is `\u22a2 P` then `exact p` will close the goal if\nand only if `p` is a proof of `P` (i.e. `p : P`) \n## Details\nSay $P$, $Q$ and $R$ are logical staments\nand the local context looks like this: \n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n`exact j(h(p)),`\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n-/", "height": 3, "editorText": "sorry", "lineOffset": 71, "name": "example1", "statement": "(P : Prop) (p : P) : P"}, {"type": "tactic", "content": "6", "name": "exact", "sideBar": true}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "7", "hidden": true}, {"type": "lemma", "text": "8", "lean": "lemma example2 (P Q : Prop) (p : P) (q : Q) : Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 10, "textBefore": "import tactic --hide \n\n/-Lemma\nNow try the following one:\n-/\nlemma example2 (P Q : Prop) (p : P) (q : Q) : Q :=\nbegin\n", "proof": "  exact q,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 3, "editorText": "sorry", "lineOffset": 7, "name": "example2", "statement": "(P Q : Prop) (p : P) (q : Q) : Q"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "9", "hidden": true}, {"type": "text", "content": "10"}, {"type": "lemma", "text": "11", "lean": "lemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\n", "sideBar": true, "firstProofLineNumber": 44, "lastProofLineNumber": 47, "textBefore": "import tactic --hide \n\n/-\n\n#Combining logical statements\n\nNow, we can take these statements and create new ones. For example if we have two statements \n`P Q : Prop` we can write ` P \u2192 Q` to mean $P$ implies $Q$. Similarly, we can write `\u00acP` for the \nstatement \"Not $P$\". \n\nSay we have the following lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nThis asks us to prove: If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ \n(i.e. we have `p : P`). Then $Q$ is true (i.e. we have a proof of `Q`). \n\nHere we have given the name $h$ to the implication ` P \u2192 Q`. We think of $h$ as a map between \nstatements in `Prop` world. \n\nNow this lemma is asking us to take a proof of $P$ and turn it into a proof of $Q$. Since we know \nthat $P$ implies $Q$ then we know that if $P$ is true then so is $Q$. So we can use our map in \n`Prop` world to transform our proof of $P$ into a proof of $Q$. \n\nIf we write `exact h(p)` below we get what we want.\n\nNote that it has to be lower case $p$, since $P$ is the logical statement, but what we want to \ntransform is the proof.\n\n\n\n-/\n\n/- Lemma\nIf $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ (i.e. we have `p : P`). \nThen $Q$ is true (i.e. we have a proof of `Q`)\n-/\nlemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\nbegin\n", "proof": "  exact h(p),\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 43, "name": "implications_one", "statement": "(P Q : Prop) (h : P \u2192 Q) (p : P) : Q"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "12", "hidden": true}, {"type": "lemma", "text": "13", "lean": "lemma implications_two (P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R :=\n", "sideBar": true, "firstProofLineNumber": 9, "lastProofLineNumber": 11, "textBefore": "import tactic --hide\n\n\n/-Lemma\nNow try the following one: \n-/\nlemma implications_two (P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R :=\nbegin\n", "proof": "  exact h2 (h1 (p)),\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 3, "editorText": "sorry", "lineOffset": 8, "name": "implications_two", "statement": "(P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R"}]}]}, {"name": "14", "levels": [{"name": "15", "problemIndex": -1, "objects": [{"type": "lean", "content": "16", "hidden": true}, {"type": "text", "content": "17"}]}, {"name": "18", "problemIndex": 3, "objects": [{"type": "lean", "content": "19", "hidden": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "text", "content": "21"}, {"type": "lemma", "text": "22", "lean": "lemma implies_self (P : Prop) : P \u2192 P :=\n", "sideBar": false, "firstProofLineNumber": 38, "lastProofLineNumber": 41, "textBefore": "import tactic --hide\n\nuniverse u --hide\n\n-- Level name : intro\n\n/-\n\nLets look at an example that needs the `intro` tactic: \n\nIf your goal is to prove `P \u2192 Q` (i.e. that $P\\implies Q$)\nthen `intro p`, meaning \"assume $p$ is a proof of $P$\", will make progress.\nTo solve the goal below, you have to come up with a function from\n`P` (thought of as the set of proofs of $P$!) to itself. Start with\n`intro p,`\n(i.e. \"let $p$ be a proof of $P$\") and note that our\nlocal context now looks like this:\n```\nP : Prop,\np : P\n\u22a2 P\n```\nOur job now is to construct a proof of $P$. But $p$ is a proof of $P$.\nSo\n`exact p,`\nwill close the goal. Note that `exact P` will not work -- don't\nconfuse a true/false statement (which could be false!) with a proof.\nWe will stick with the convention of capital letters for propositions\nand small letters for proofs.\n-/ \n\n\n/- Lemma : no-side-bar\nIf $P$ is a proposition then $P\\implies P$.\n-/\nlemma implies_self (P : Prop) : P \u2192 P :=\nbegin\n", "proof": "  intro p,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : intro\n\n## The `intro` tactic.\n\nIf your goal is\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill turn your tactic state into\n\n```\nhP : P\n\u22a2 Q\n```\n\nVariant: `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 <something else>`.\n\n-/", "height": 4, "editorText": "sorry", "lineOffset": 37, "name": "implies_self", "statement": "(P : Prop) : P \u2192 P"}, {"type": "tactic", "content": "23", "name": "intro", "sideBar": true}]}, {"name": "24", "problemIndex": 3, "objects": [{"type": "lean", "content": "25", "hidden": true}, {"type": "lean", "content": "26", "hidden": true}, {"type": "text", "content": "27"}, {"type": "lemma", "text": "28", "lean": "lemma implications_one_again (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 26, "textBefore": "import tactic --hide\n\nuniverse u --hide\n\n-- Level name : apply tactic\n\n/-\nLets look at using the apply tactic:\n\nHere's an example we have already done, but try and do it using the apply tactic:\n\n-/\n\n\n/- Lemma\nLets try and prove that if `P` implies `Q` (which is written ` P \u2192 Q`) and we have a proof of `P` \n(i.e. we have `p : P`). Then `Q` is true (i.e. we have a proof of `Q`)\n-/\n\nlemma implications_one_again (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\nbegin\n", "proof": "  apply h,\n  exact p,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : apply\n\n## The `apply` tactic\n\nIf your tactic state is\n\n```\nhPQ : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic\n\n`apply hPQ,`\n\nwill change it to\n\n```\nhPQ : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n-/", "height": 5, "editorText": "sorry", "lineOffset": 21, "name": "implications_one_again", "statement": "(P Q : Prop) (h : P \u2192 Q) (p : P) : Q"}, {"type": "tactic", "content": "29", "name": "apply", "sideBar": true}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "30", "hidden": true}, {"type": "lemma", "text": "31", "lean": "lemma lemma1 (P Q : Prop) (hQ : Q) : P \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 13, "textBefore": "import tactic -- hide\n\n/-Lemma\nAssume `Q` is true. Prove that `P \u2192 Q`. \n-/\nlemma lemma1 (P Q : Prop) (hQ : Q) : P \u2192 Q :=\nbegin\n", "proof": "  intro fish,\n  exact hQ,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 7, "name": "lemma1", "statement": "(P Q : Prop) (hQ : Q) : P \u2192 Q"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "32", "hidden": true}, {"type": "text", "content": "33"}, {"type": "lemma", "text": "34", "lean": "lemma lemma2 (P Q : Prop) : P \u2192 Q \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 27, "textBefore": "import tactic -- hide\n\n/-\nNote that implies `\u2192` is not associative: in general `P \u2192 (Q \u2192 R)` and `(P \u2192 Q) \u2192 R`\nmight not be equivalent. This is like subtraction on numbers -- in general\n`a - (b - c)` and `(a - b) - c` might not be equal.\nSo if we write `P \u2192 Q \u2192 R` then we'd better know what this means.\nThe convention in Lean is that it means `P \u2192 (Q \u2192 R)`. If you think\nabout it, this means that to deduce `R` you will need to prove both `P`\nand `Q`. \n\nIn general to prove `P1 \u2192 P2 \u2192 P3 \u2192 ... Pn` you can assume\n`P1`, `P2`,...,`P(n-1)` and then you have to prove `Pn`. \nSo the next level is asking you prove that `P \u2192 (Q \u2192 P)`.\n-/\n\n/-Lemma \nProve $P$ implies $(P \\implies Q)$\n-/\nlemma lemma2 (P Q : Prop) : P \u2192 Q \u2192 P :=\nbegin\n", "proof": "  intro hP,\n  intro hQ,\n  exact hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 21, "name": "lemma2", "statement": "(P Q : Prop) : P \u2192 Q \u2192 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "35", "hidden": true}, {"type": "lemma", "text": "36", "lean": "lemma Modus_Ponens (P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 15, "textBefore": "import tactic -- hide\n\n\n/- Lemma  \nIf we know `P`, and we also know `P \u2192 Q`, we can deduce `Q`. \nThis is called \"Modus Ponens\" by logicians.\n-/\nlemma Modus_Ponens (P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q :=\nbegin\n", "proof": "  intros hP hPQ,\n  apply hPQ,\n  exact hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 9, "name": "Modus_Ponens", "statement": "(P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "37", "hidden": true}, {"type": "lemma", "text": "38", "lean": "lemma implicationss_are_transitive (P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R) :=\n", "sideBar": true, "firstProofLineNumber": 9, "lastProofLineNumber": 15, "textBefore": "import tactic --hide\n\n/-Lemma  \nLets show that implications are transitive. That is, if `P \u2192 Q` and `Q \u2192 R` are true, then\nso is `P \u2192 R`.\n-/\nlemma implicationss_are_transitive (P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R) :=\nbegin\n", "proof": "  intros hPQ hQR hP,\n  apply hQR,\n  apply hPQ,\n  exact hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 8, "name": "implicationss_are_transitive", "statement": "(P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R)"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "39", "hidden": true}, {"type": "text", "content": "40"}, {"type": "lemma", "text": "41", "lean": "lemma lemma5 (P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R) :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 30, "textBefore": "import tactic --hide\n\n\n/-\nFor the next one you might need to note the following:\n\nIf we have the assumption `h : P \u2192 Q \u2192 R` with goal `\u22a2 R` and you `apply h`, then you'll get\ntwo goals! \n\nNote that tactics operate on only the first goal. So you'll have to first prove the \nfirst goal and then move onto the second. \n\nTip:  If you have multiple goals and you want to work on one that isnt the first one you can \nwrite `sorry,` to skip a proving a goal (although you will need to come back to it \neventually to complete the proof!)\n-/\n\n/-Lemma \nProve $(P \\implies Q \\implies R) \\implies ((P \\implies Q) \\implies (P \\implies R)$\n-/\nlemma lemma5 (P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R) :=\nbegin\n", "proof": "  intros hPQR hPQ hP,\n  apply hPQR,\n  { exact hP },\n  { apply hPQ,\n    exact hP }\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 8, "editorText": "sorry", "lineOffset": 22, "name": "lemma5", "statement": "(P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R)"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "42", "hidden": true}, {"type": "text", "content": "43"}, {"type": "lemma", "text": "44", "lean": "lemma lemma6 (P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T :=\n", "sideBar": true, "firstProofLineNumber": 13, "lastProofLineNumber": 20, "textBefore": "import tactic --hide\n\n/-\nLets try some harder ones\n-/\n\n\n/-Lemma \nThis isn't so bad\n-/\nlemma lemma6 (P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T :=\nbegin\n", "proof": "  intros hPR hSQ hRT hQR hS,\n  apply hRT,\n  apply hQR,\n  apply hSQ,\n  exact hS,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 8, "editorText": "sorry", "lineOffset": 12, "name": "lemma6", "statement": "(P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "45", "hidden": true}, {"type": "lemma", "text": "46", "lean": "lemma lemma7 (P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-Lemma \nMore nested implications:\n-/\nlemma lemma7 (P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q :=\nbegin\n", "proof": "  intros hPQ hPQP,\n  apply hPQ,\n  apply hPQP,\n  exact hPQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 7, "name": "lemma7", "statement": "(P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "47", "hidden": true}, {"type": "lemma", "text": "48", "lean": "lemma lemma8 (P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 16, "textBefore": "import tactic --hide\n\n/-Lemma\nEven more nested implications\n-/\nlemma lemma8 (P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P :=\nbegin\n", "proof": "  intros h1 h2 h3,\n  apply h2,\n  intro hQ,\n  apply h1,\n  intro hP,\n  exact hQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 7, "name": "lemma8", "statement": "(P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "49", "hidden": true}, {"type": "lemma", "text": "50", "lean": "lemma lemma9 (P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 16, "textBefore": "import tactic --hide\n\n/-Lemma\nThis is getting silly now\n-/\nlemma lemma9 (P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P :=\nbegin\n", "proof": "  intros h1 h2 h3,\n  apply h1,\n  intro hQ,\n  apply h3,\n  apply h2,\n  exact hQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 7, "name": "lemma9", "statement": "(P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "51", "hidden": true}, {"type": "lemma", "text": "52", "lean": "lemma lemma10 (P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q) :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-Lemma\nHow hard could it be?\n-/\nlemma lemma10 (P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q) :=\nbegin\n", "proof": "  intros h1 hP,\n  apply h1,\n  intro hPQ,\n  exact hPQ hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 7, "name": "lemma10", "statement": "(P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q)"}]}, {"name": "53", "problemIndex": 1, "objects": [{"type": "lean", "content": "54", "hidden": true}, {"type": "lemma", "text": "55", "lean": "lemma boss_lemma_1 (P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 22, "textBefore": "import tactic --hide\n\n-- Level name : Boss fight 1\n\n\n/-Lemma\nTime for a boss fight!\n-/\nlemma boss_lemma_1 (P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R :=\nbegin\n", "proof": "  intros h1 h2 h3,\n  apply h2,\n  intros h1 hP h2,\n  apply h1,\n  intro hP,\n  exact h2,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 13, "name": "boss_lemma_1", "statement": "(P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R"}]}], "parents": [0]}, {"name": "56", "levels": [{"name": "57", "problemIndex": -1, "objects": [{"type": "lean", "content": "58", "hidden": true}, {"type": "text", "content": "59"}, {"type": "lean", "content": "60", "hidden": false}, {"type": "tactic", "content": "61", "name": "split", "sideBar": true}, {"type": "tactic", "content": "62", "name": "left and right", "sideBar": true}, {"type": "tactic", "content": "63", "name": "cases", "sideBar": true}]}, {"name": "64", "problemIndex": 1, "objects": [{"type": "lean", "content": "65", "hidden": true}, {"type": "lemma", "text": "66", "lean": "lemma absorption_one (P Q : Prop) : P \u2227 (P \u2228 Q) \u2194 P :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 18, "textBefore": "import tactic --hide\n\n-- Level name : absorpsion laws pt 1\n\n/-Lemma\nLets try and prove that $P \u2227 (P \u2228 Q)$ is equivalent to $P$\n-/\nlemma absorption_one (P Q : Prop) : P \u2227 (P \u2228 Q) \u2194 P :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with hP hPQ,\n  exact hP,\n  intro h,\n  split,\n  exact h,\n  left,\n  exact h,  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 9, "editorText": "sorry", "lineOffset": 9, "name": "absorption_one", "statement": "(P Q : Prop) : P \u2227 (P \u2228 Q) \u2194 P"}]}, {"name": "67", "problemIndex": 1, "objects": [{"type": "lean", "content": "68", "hidden": true}, {"type": "lemma", "text": "69", "lean": "lemma absorption_two (P Q : Prop) : P \u2228 (P \u2227 Q) \u2194 P :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 18, "textBefore": "import tactic --hide\n\n-- Level name : absorpsion laws pt 2\n\n/-Lemma\nLets try and prove that $P \u2228 (P \u2227 Q)$ is equivalent to $P$\n-/\nlemma absorption_two (P Q : Prop) : P \u2228 (P \u2227 Q) \u2194 P :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h,\n  exact h,\n  cases h,\n  exact h_left,\n  intro h,\n  left,\n  exact h,", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 9, "name": "absorption_two", "statement": "(P Q : Prop) : P \u2228 (P \u2227 Q) \u2194 P"}]}, {"name": "70", "problemIndex": 1, "objects": [{"type": "lean", "content": "71", "hidden": true}, {"type": "lemma", "text": "72", "lean": "lemma associativity_one (P Q R : Prop) : P \u2227 (Q \u2227 R) \u2194 (P \u2227 Q) \u2227 R :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 27, "textBefore": "import tactic --hide\n\n-- Level name : Associative laws pt 1\n\n/-Lemma\nLets prove that $P \u2227 (Q \u2227 R)$ is equivalent to $(P \u2227 Q) \u2227 R$\n-/\nlemma associativity_one (P Q R : Prop) : P \u2227 (Q \u2227 R) \u2194 (P \u2227 Q) \u2227 R :=\nbegin\n", "proof": "  split,\n  intro h,\n  split,\n  cases h with hl hr,\n  split,\n  exact hl,\n  cases hr,\n  exact hr_left,\n  cases h with h1 h2,\n  cases h2 with h2 h3,\n  exact h3,\n  intro h,\n  split,\n  cases h,\n  exact h_left.1,\n  split,\n  exact h.1.2,\n  exact h.2,", "proof_hint": "sorry", "textAfter": "\nend", "height": 18, "editorText": "sorry", "lineOffset": 9, "name": "associativity_one", "statement": "(P Q R : Prop) : P \u2227 (Q \u2227 R) \u2194 (P \u2227 Q) \u2227 R"}]}, {"name": "73", "problemIndex": 1, "objects": [{"type": "lean", "content": "74", "hidden": true}, {"type": "lemma", "text": "75", "lean": "lemma associativity_two (P Q R : Prop) : P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 32, "textBefore": "import tactic --hide\n\n-- Level name : Associative laws pt 2\n\n/-Lemma\nLets prove that $P \u2228 (Q \u2228 R)$ is equivalent to $(P \u2228 Q) \u2228 R$\n-/\nlemma associativity_two (P Q R : Prop) : P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with h1 h2,\n  left,\n  left,\n  exact h1,\n  cases h2 with h2 h3,\n  left,\n  right,\n  exact h2,\n  right,\n  exact h3,\n  intro h,\n  cases h with h1 h2,\n  cases h1 with h1 h3,\n  left,\n  exact h1,\n  right,\n  left,\n  exact h3,\n  right,\n  right,\n  exact h2,", "proof_hint": "sorry", "textAfter": "\nend", "height": 23, "editorText": "sorry", "lineOffset": 9, "name": "associativity_two", "statement": "(P Q R : Prop) : P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R"}]}, {"name": "76", "problemIndex": 1, "objects": [{"type": "lean", "content": "77", "hidden": true}, {"type": "lemma", "text": "78", "lean": "lemma distributivity_one (P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R) :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 31, "textBefore": "import tactic --hide\n\n-- Level name : Distributive laws 1\n\n/-Lemma\nLets prove that $P \u2227 (Q \u2228 R)$ is equivalent to $(P \u2227 Q) \u2228 (P \u2227 R)$\n-/\nlemma distributivity_one (P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R) :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with h1 h2,\n  cases h2 with h2 h3,\n  left,\n  split,\n  exact h1,\n  exact h2,\n  right,\n  split,\n  exact h1,\n  exact h3,\n  intro h,\n  cases h with h1 h2,\n  split,\n  exact h1.1,\n  left,\n  exact h1.2,\n  split,\n  exact h2.1,\n  right,\n  exact h2.2,", "proof_hint": "sorry", "textAfter": "\nend ", "height": 22, "editorText": "sorry", "lineOffset": 9, "name": "distributivity_one", "statement": "(P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R)"}]}, {"name": "79", "problemIndex": 1, "objects": [{"type": "lean", "content": "80", "hidden": true}, {"type": "lemma", "text": "81", "lean": "lemma distributivity_two (P Q R : Prop) : P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R) :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 34, "textBefore": "import tactic --hide\n\n-- Level name : Distributive laws 1\n\n/-Lemma\nLets prove that $P \u2228 (Q \u2227 R)$ is equivalent to $(P \u2228 Q) \u2227 (P \u2228 R)$\n-/\nlemma distributivity_two (P Q R : Prop) : P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R) :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h,\n  split,\n  left,\n  exact h,\n  left,\n  exact h,\n  split,\n  right,\n  exact h.1,\n  right,\n  exact h.2,\n  intro h,\n  cases h,\n  cases h_left with h1 h2,\n  left,\n  exact h1,\n  cases h_right with h4 h5,\n  left,\n  exact h4,\n  right,\n  split,\n  exact h2,\n  exact h5,", "proof_hint": "sorry", "textAfter": "\nend", "height": 25, "editorText": "sorry", "lineOffset": 9, "name": "distributivity_two", "statement": "(P Q R : Prop) : P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R)"}]}], "parents": [0, 1]}], "texts": [["De Morgan's game", "# Captain De Morgan's logic Game\n\n## By Chris Birkbeck and Niki Kalaydzhieva\n\nLearn some logic yo\n\n# What is this game?\n\nThis is a game to teach you some mathematical logic using Lean.\n\nHave fun!\n\n# Credits\n\nSome levels have been shamelessly borrowed from Kevin Buzzard's and Mohammad Pedramfar's \n\"Natural Numbers Game\" as well as  Kevin Buzzard's \"Formalizing mathematics\" course at \nImperial College. \n\n\n", "Tutorial", "import tactic --hide\n", "\n#Logical statements \n\nYou've seen logical statements already, these are statements that can be true or false, for example: \n\n-The sum of two odd numbers is an even number\n\n-$36$ is divisible by $3$\n\n-$x > 2$\n\n\nLets see how one does this a computer, specifically in lean. In lean, logical staments live in a \nworld called `Prop`. So for example if we write `P : Prop` we mean \"$P$ is a logical statement.\" \nThink of the `:` symbol as saying $P$  is a resident of `Prop` world (in maths this would be denoted\nby something like `P \u2208 Prop`).\n\n#Truth Values\n\nThe truth value of a logical statement (i.e. some `P : Prop`) is whether the statement is true or \nfalse.  For example, the truth value of the statement: \"For all integers $x \u2208 \u2124$,  $0 \u2264 x^2$\" \nis *true* while  \"For all integers $x \u2208 \u2124$,  $0 \u2264 x^3$\" is *false*. \n\nIn lean we assign truth values as follows: We first think of a proposition $P$ as a set with \n*at most* one element.  If this set is empty, then we say `P` is *false*. Otherwise, if this set has \nan element, lets call it $p$ (we will usually use upper case letters for logical statements, \nand lower case for their proofs), then this  statement is *true* and $p$ is the proof. \n\nSo to recap, if $P$ is the true/false statement (the statement of proposition), and $p$ is its proof.\nIt's like thinking $P$ being the set and $p$ being the element. Just as above, where we had \n`P : Prop` to mean $P$  is a proposition, we write `p : P` to mean \"$p$ is a proof of $P$\".\n\nThe aim of this game is to learn how to manipulate logical statements and their proofs. \nLets start with a super basic example of how a lemma looks like in lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, \non the right you will  see the following: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere the first two lines are our assumptions and the thing after the `\u22a2` symbol is what we are \nbeing asked to prove. \n\nNow, in this game our \"moves\" or, as we call them in lean, *Tactics*, are what will allow us to \nmanipulate our statement and produce proofs.\n\nThe first tactic we will look at is called *exact* and what it does is, if you need to prove a \nstatement $P$ and you have proof of it, say, `p: P`, then `exact p` will prove it. \n\nNote that at the end of each line we write we need to have a comma `,` to tell lean that this is the \nend of our move. \n\nSo if below you change the `sorry` for \"`exact p,`\" (don't forget the comma!) you'll see that on the \nright it will change to say `Proof complete!`. \n\n", "Lets try and prove that if $P$ is a logical stament (i.e. `P : Prop`) and $p$ is a proof of $P$ \n(i.e. `p : P`) then $P$ is true.\n", "## Summary \nIf the goal is `\u22a2 P` then `exact p` will close the goal if\nand only if `p` is a proof of `P` (i.e. `p : P`) \n## Details\nSay $P$, $Q$ and $R$ are logical staments\nand the local context looks like this: \n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n`exact j(h(p)),`\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n", "import tactic --hide \n", "Now try the following one:\n", "import tactic --hide \n", "\n#Combining logical statements\n\nNow, we can take these statements and create new ones. For example if we have two statements \n`P Q : Prop` we can write ` P \u2192 Q` to mean $P$ implies $Q$. Similarly, we can write `\u00acP` for the \nstatement \"Not $P$\". \n\nSay we have the following lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nThis asks us to prove: If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ \n(i.e. we have `p : P`). Then $Q$ is true (i.e. we have a proof of `Q`). \n\nHere we have given the name $h$ to the implication ` P \u2192 Q`. We think of $h$ as a map between \nstatements in `Prop` world. \n\nNow this lemma is asking us to take a proof of $P$ and turn it into a proof of $Q$. Since we know \nthat $P$ implies $Q$ then we know that if $P$ is true then so is $Q$. So we can use our map in \n`Prop` world to transform our proof of $P$ into a proof of $Q$. \n\nIf we write `exact h(p)` below we get what we want.\n\nNote that it has to be lower case $p$, since $P$ is the logical statement, but what we want to \ntransform is the proof.\n\n\n\n", "If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ (i.e. we have `p : P`). \nThen $Q$ is true (i.e. we have a proof of `Q`)\n", "import tactic --hide\n", "Now try the following one: \n", "Logical statements", "Tactics", "import tactic --hide\n", "\n## Tactics for Level 1\n\n## The `intro` tactic.\n\nIf your goal is\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill turn your tactic state into\n\n```\nhP : P\n\u22a2 Q\n```\n\nVariant: `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 <something else>`.\n\n## The `exact` tactic (we have already seen this)\n\nIf your tactic state is\n\n```\nhP : P\n\u22a2 P\n```\n\nthen the tactic\n\n`exact hP,`\n\nwill close your goal.\n\nNote: `exact P` does not work. Don't confuse\nthe *statement* `P` with its *proof* `hP`.\n\nVariant: The `assumption` tactic closes a goal if its proof is any one of the assumptions\nin the tactic state. \n\n## The `apply` tactic\n\nIf your tactic state is\n\n```\nhPQ : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic\n\n`apply hPQ,`\n\nwill change it to\n\n```\nhPQ : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n\n", "intro", "import tactic --hide\n", "universe u --hide\n", "\nLets look at an example that needs the `intro` tactic: \n\nIf your goal is to prove `P \u2192 Q` (i.e. that $P\\implies Q$)\nthen `intro p`, meaning \"assume $p$ is a proof of $P$\", will make progress.\nTo solve the goal below, you have to come up with a function from\n`P` (thought of as the set of proofs of $P$!) to itself. Start with\n`intro p,`\n(i.e. \"let $p$ be a proof of $P$\") and note that our\nlocal context now looks like this:\n```\nP : Prop,\np : P\n\u22a2 P\n```\nOur job now is to construct a proof of $P$. But $p$ is a proof of $P$.\nSo\n`exact p,`\nwill close the goal. Note that `exact P` will not work -- don't\nconfuse a true/false statement (which could be false!) with a proof.\nWe will stick with the convention of capital letters for propositions\nand small letters for proofs.\n", "If $P$ is a proposition then $P\\implies P$.\n", "\n## The `intro` tactic.\n\nIf your goal is\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill turn your tactic state into\n\n```\nhP : P\n\u22a2 Q\n```\n\nVariant: `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 <something else>`.\n\n", "apply tactic", "import tactic --hide\n", "universe u --hide\n", "Lets look at using the apply tactic:\n\nHere's an example we have already done, but try and do it using the apply tactic:\n\n", "Lets try and prove that if `P` implies `Q` (which is written ` P \u2192 Q`) and we have a proof of `P` \n(i.e. we have `p : P`). Then `Q` is true (i.e. we have a proof of `Q`)\n", "\n## The `apply` tactic\n\nIf your tactic state is\n\n```\nhPQ : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic\n\n`apply hPQ,`\n\nwill change it to\n\n```\nhPQ : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n", "import tactic -- hide\n", "Assume `Q` is true. Prove that `P \u2192 Q`. \n", "import tactic -- hide\n", "Note that implies `\u2192` is not associative: in general `P \u2192 (Q \u2192 R)` and `(P \u2192 Q) \u2192 R`\nmight not be equivalent. This is like subtraction on numbers -- in general\n`a - (b - c)` and `(a - b) - c` might not be equal.\nSo if we write `P \u2192 Q \u2192 R` then we'd better know what this means.\nThe convention in Lean is that it means `P \u2192 (Q \u2192 R)`. If you think\nabout it, this means that to deduce `R` you will need to prove both `P`\nand `Q`. \n\nIn general to prove `P1 \u2192 P2 \u2192 P3 \u2192 ... Pn` you can assume\n`P1`, `P2`,...,`P(n-1)` and then you have to prove `Pn`. \nSo the next level is asking you prove that `P \u2192 (Q \u2192 P)`.\n", "Prove $P$ implies $(P \\implies Q)$\n", "import tactic -- hide\n", "If we know `P`, and we also know `P \u2192 Q`, we can deduce `Q`. \nThis is called \"Modus Ponens\" by logicians.\n", "import tactic --hide\n", "Lets show that implications are transitive. That is, if `P \u2192 Q` and `Q \u2192 R` are true, then\nso is `P \u2192 R`.\n", "import tactic --hide\n", "For the next one you might need to note the following:\n\nIf we have the assumption `h : P \u2192 Q \u2192 R` with goal `\u22a2 R` and you `apply h`, then you'll get\ntwo goals! \n\nNote that tactics operate on only the first goal. So you'll have to first prove the \nfirst goal and then move onto the second. \n\nTip:  If you have multiple goals and you want to work on one that isnt the first one you can \nwrite `sorry,` to skip a proving a goal (although you will need to come back to it \neventually to complete the proof!)\n", "Prove $(P \\implies Q \\implies R) \\implies ((P \\implies Q) \\implies (P \\implies R)$\n", "import tactic --hide\n", "Lets try some harder ones\n", "This isn't so bad\n", "import tactic --hide\n", "More nested implications:\n", "import tactic --hide\n", "Even more nested implications\n", "import tactic --hide\n", "This is getting silly now\n", "import tactic --hide\n", "How hard could it be?\n", "Boss fight 1", "import tactic --hide\n", "Time for a boss fight!\n", "Distributivity, Associativity and Absorption", "and what?", "import tactic --hide\n", "Lets now look at making some more complicated logical statements. Recall that if we have two\nstatements $P,Q$ then we can form $P \u2227 Q$ which is true iff both $P$ and $Q$ are true.#check\n\nTo help us with this, lets introduce some new tactics.\n\n\n## Tactics for Level 2\n\n## The `split` tactic\n\nIf your goal is an \"and\" goal:\n\n```\n\u22a2 P \u2227 Q\n```\n\nthen the `split` tactic will turn it\ninto *two* goals\n\n\n```\n\u22a2 P\n```\n\nand\n\n```\n\u22a2 Q\n```\n\nIt is best practice to indicate when you are working with two goals, either by using squiggly \nbrackets like this:\n\n```\n...\nsplit,\n{ working on P,\n  end of proof of P },\n{ working on Q,\n  end of proof of Q },\n```\n\nor by using indentation like this:\n\n```\nsplit,\n  working on P,\n  end of proof of P,\nworking on Q,\n...\n```\n\nMoreover, if you have an iff `\u2194` then splitting it will give you two goals, `\u2192` and `\u2190` to prove.\n\n## `left` and `right`\n\nIf your goal is\n\n```\n\u22a2 P \u2228 Q\n```\n\nthen `left` changes the goal to `\u22a2 P`. The logic is that `P` implies `P \u2228 Q`\nso we can `apply` this implication. Similarly `right` changes the goal to `\u22a2 Q`\n\n## The `cases` tactic\n\n`cases` is a very general-purpose tactic for \"deconstructing\" hypotheses.\nIf `h` is a hypothesis which somehow \"bundles up\" two pieces of information,\nthen `cases h with h1 h2` will make hypothesis `h` vanish and will replace it\nwith the two \"components\" which made the proof of `h` in the first place.\nAn example of this occurring in logic sheet 4 is `h : P \u2227 Q` which is a\nbundling of a proof of `P` and a proof of `Q`.\n\n### Example\n\nIf you have a hypothesis\n\n```\nhPaQ : P \u2227 Q\n```\n\nthen\n\n`cases hPaQ with hP hQ,`\n\nwill delete `hPaQ` and replace it with\n\n```\nhP : P\nhQ : Q\n```\n\nYou can also use it for \"or's\". Specifically, if you have `h : P \u2228 Q` then `cases h` will\ngive you two goals, one where `P` is true and one where `Q` is true.\n\n\n", "example (P Q : Prop) (p : P) : P \u2228 Q :=\nbegin\n  left,\n  exact p,\nend\nexample (P Q : Prop) (p : P) (q : Q) : P \u2227 Q :=\nbegin\n  split,\n  exact p,\n  exact q,\nend\nexample (P : Prop) : P \u2194 P :=\nbegin\n  split,\n  intro p,\n  exact p,\n  intro p,\n  exact p,\nend\nexample (P Q : Prop) (hPQ: P \u2227 Q) : P :=\nbegin \n  cases hPQ with hP hQ,\n  exact hP,\nend\nexample (P : Prop) (hp : P \u2228 P) : P :=\nbegin\n  cases hp,\n  exact hp,\n  exact hp,\nend\n", "\nIf your goal is an \"and\" goal:\n\n```\n\u22a2 P \u2227 Q\n```\n\nthen the `split` tactic will turn it\ninto *two* goals\n\n\n```\n\u22a2 P\n```\n\nand\n\n```\n\u22a2 Q\n```\nMoreover, if you have an iff `\u2194` then splitting it will give you two goals, `\u2192` and `\u2190` to prove.\n\n", "\nIf your goal is\n\n```\n\u22a2 P \u2228 Q\n```\n\nthen `left` changes the goal to `\u22a2 P`. The logic is that `P` implies `P \u2228 Q`\nso we can `apply` this implication. Similarly `right` changes the goal to `\u22a2 Q`\n\n", "\nIf you have a hypothesis\n\n```\nhPaQ : P \u2227 Q\n```\n\nthen\n\n`cases hPaQ with hP hQ,`\n\nwill delete `hPaQ` and replace it with\n\n```\nhP : P\nhQ : Q\n```\n\nYou can also use it for \"or's\". Specifically, if you have `h : P \u2228 Q` then `cases h` will\ngive you two goals, one where `P` is true and one where `Q` is true.\n\n", "absorpsion laws pt 1", "import tactic --hide\n", "Lets try and prove that $P \u2227 (P \u2228 Q)$ is equivalent to $P$\n", "absorpsion laws pt 2", "import tactic --hide\n", "Lets try and prove that $P \u2228 (P \u2227 Q)$ is equivalent to $P$\n", "Associative laws pt 1", "import tactic --hide\n", "Lets prove that $P \u2227 (Q \u2227 R)$ is equivalent to $(P \u2227 Q) \u2227 R$\n", "Associative laws pt 2", "import tactic --hide\n", "Lets prove that $P \u2228 (Q \u2228 R)$ is equivalent to $(P \u2228 Q) \u2228 R$\n", "Distributive laws 1", "import tactic --hide\n", "Lets prove that $P \u2227 (Q \u2228 R)$ is equivalent to $(P \u2227 Q) \u2228 (P \u2227 R)$\n", "Distributive laws 1", "import tactic --hide\n", "Lets prove that $P \u2228 (Q \u2227 R)$ is equivalent to $(P \u2228 Q) \u2227 (P \u2228 R)$\n"]]}