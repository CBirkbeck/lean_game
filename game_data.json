{"name": "De Morgan's game", "version": "1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "De Morgan's game-1.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "lemma", "text": "5", "lean": "lemma example_one (P : Prop) (p : P) : P :=\n", "sideBar": true, "firstProofLineNumber": 74, "lastProofLineNumber": 76, "textBefore": "import tactic --hide\n\n/-\n\n#Logical statements \n\nIn Logic, a *statement* is a sentence that is either true of false, for example: \n\n```md\n1. The sum of two odd numbers is an even number\n2. 36 is divisible by 3\n3. x > 2\n```\n\nOne of the goals of this game is to show you how to work with logical statements on a computer, \nspecifically using a computer language called Lean. In Lean, logical staments live in a \nplace called `Prop` (which is short for \"Propositions\"). For example, if we write  <mark style =\"background-color :   #ebdef0 \">`P : Prop`</mark> \nwe mean \"`P` is a logical statement.\"  Think of the \"`:`\" symbol as saying `P` lives in `Prop` \n(in Maths this would be denoted by `P \u2208 Prop`, to mean `P` is an element of `Prop`).\n\n#Truth Values\n\nThe *truth value* of a logical statement (i.e. some `P : Prop` is whether the statement is true or \nfalse. For example, the truth value of the statement: \"For all integers $x \u2208 \u2124$, $0 \u2264 x^2$\" \nis *true*, while \"For all integers $x \u2208 \u2124$, $0 \u2264 x^3$\" is *false*. \n\nIn Lean we assign truth values as follows: We first think of a proposition $P$ as a set with \n*at most* one element. If this set is empty, then we say `P` is *false*. Otherwise, if this set has \nan element, lets call it `p`, then this statement is *true* and `p` is the proof. We will usually \nuse upper case letters for logical statements, and lower case for their proofs.\n\nTo recap, we write `P : Prop` to mean `P` is a \nproposition and we write  <mark style =\"background-color : #ebdef0 \">`p : P`</mark>  to mean \"`p` is a \nproof of `P`\".\n\nThe aim of this game is to learn how to prove logical statements, which we call *lemmas* through a\nseries of manipulations which we call *tactics*. \n \nLets start with a simple example of how a lemma looks like in Lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, \non the right you will see the following state: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere, the first two lines are our assumptions, where the first line `P : Prop` says \"$P$ is a \nlogical statement\" and the second line `p : P` says `p` is the proof of `P`.\n\nThe thing after the `\u22a2` symbol is what we need to prove to win the level (i.e. prove the lemma).\n\nIn this game our \"moves\" or, as we call them in Lean, *tactics*, are what will allow us to \nmanipulate our statements and produce proofs.\n\nThe first tactic we will use is called *exact*. It is used when you need to prove a \nstatement $P$ and you have the proof of it. In the example above we have `p : P` and we need to\nprove `P`, then typing <mark style =\"background-color :   #ebdef0 \">`exact p,`</mark>  will prove it. \n\n**Note:  We end each line with a comma `,` to tell Lean that this is the end of our move.** \n\nTry it for yourself now and see what happens!\n\n-/\n\n\n/- Lemma\nIf $P$ is a logical stament and $p$ is a proof of $P$ then $P$ is true.\n-/\nlemma example_one (P : Prop) (p : P) : P :=\nbegin\n", "proof": "  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : exact\n## Summary \nIf the goal is `\u22a2 P` then `exact p,` will close the goal if\nand only if `p` is a proof of `P` (i.e. `p : P`) \n## Details\nSay $P$, $Q$ and $R$ are logical staments\nand your lemma looks like this: \n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\nThen you can solve the level by using `exact j(h(p)),`\n-/\n", "height": 3, "editorText": "sorry", "lineOffset": 73, "name": "example_one", "statement": "(P : Prop) (p : P) : P"}, {"type": "tactic", "content": "6", "name": "exact", "sideBar": true}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "7", "hidden": true}, {"type": "lemma", "text": "8", "lean": "lemma example_two (P Q : Prop) (p : P) (q : Q) : Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 10, "textBefore": "import tactic --hide \n\n/-Lemma\nIf $P,Q$ are logical statements with respective proofs $p,q$, then $Q$ is true.\n-/\nlemma example_two (P Q : Prop) (p : P) (q : Q) : Q :=\nbegin\n", "proof": "  exact q,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 7, "name": "example_two", "statement": "(P Q : Prop) (p : P) (q : Q) : Q"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "9", "hidden": true}, {"type": "text", "content": "10"}, {"type": "lemma", "text": "11", "lean": "lemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\n", "sideBar": true, "firstProofLineNumber": 45, "lastProofLineNumber": 48, "textBefore": "import tactic --hide \n\n/-\n\n#Combining logical statements\n\nWe can combine basic statements to create new ones. For example, we can write `\u00acP` for the \nstatement \"Not `P`\" and if we have two statements `P Q : Prop` \nwe can write `P \u2192 Q` to mean `P` implies `Q`. \n\nSay we have the following state of our lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nAs in level one, the first line says `P` and `Q` are logical statements and the third line says\nthat `P` has a proof `p`.\n\nIn the second line we have the implication `P \u2192 Q`, \nwhich we have called `h`. We think of `h`  as a one-way road from the statement `P` to the \nstatement `Q` in `Prop`. In Maths, we would call `h` a function or a map. \n\nFinally, our goal is to prove `Q` is true.\n\nUsing <mark style =\"background-color :  #ebdef0 \">`exact h(p),`</mark> will prove our lemma.\n\nWhy does this work? We know that `P` is true, since we have a proof of it `p` and `h` tells us that\nif `P` is true then `Q` is true. So combining `h` and `p` results in a proof of `Q`.\n\n**Note: We use `h(p)` rather than `h(P)`, because we want to transform the proof of `P` into \na proof of `Q`.**\n\n\n\n-/\n\n/- Lemma\nLet $P,Q$ be logical statements and $P$ implies $Q$. If $P$ is true, then so is $Q$.\n-/\nlemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\nbegin\n", "proof": "  exact h(p),\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 44, "name": "implications_one", "statement": "(P Q : Prop) (h : P \u2192 Q) (p : P) : Q"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "12", "hidden": true}, {"type": "lemma", "text": "13", "lean": "lemma implications_two (P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 12, "textBefore": "import tactic --hide\n\n\n/-Lemma\nLet $P,Q,R$ be logical statements with $P$ implies $Q$ and $Q$ implies $R$. If $P$ is true, then so \nis $R$. \n-/\nlemma implications_two (P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R :=\nbegin\n", "proof": "  exact h2 (h1 (p)),\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 3, "editorText": "sorry", "lineOffset": 9, "name": "implications_two", "statement": "(P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R"}]}]}, {"name": "14", "levels": [{"name": "15", "problemIndex": 3, "objects": [{"type": "lean", "content": "16", "hidden": true}, {"type": "lean", "content": "17", "hidden": true}, {"type": "text", "content": "18"}, {"type": "lemma", "text": "19", "lean": "lemma implications_one_again (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\n", "sideBar": true, "firstProofLineNumber": 40, "lastProofLineNumber": 44, "textBefore": "import tactic --hide\n\nuniverse u --hide\n\n-- Level name : apply tactic\n\n/-\n\n## The `apply` tactic\n\nIf your lemma has the following state: \n\n```\nh : P \u2192 Q\n\u22a2 Q\n```\n\nHere, we assume that `P` implies `Q` and our goal is to prove `Q`. Then the tactic  <mark style =\"background-color : #ebdef0 \">`apply h,`</mark> \nwill change our goal to `P` and leave our assumptions unchanged, i.e. your new state will be\n\n```\nh : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n\nHere's an example we have already done, but try and do it using the `apply` tactic:\n\n-/\n\n\n/- Lemma\nLet $P,Q$ be logical statements. If $P$ implies $Q$ and $P$ is true, then $Q$ is true. \n-/\n\nlemma implications_one_again (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\nbegin\n", "proof": "  apply h,\n  exact p,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : apply\n\n## The `apply` tactic\n\nIf your lemma looks like\n\n```\nh : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic `apply h,` will change it to\n\n```\nh : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n\n\n-/", "height": 5, "editorText": "sorry", "lineOffset": 39, "name": "implications_one_again", "statement": "(P Q : Prop) (h : P \u2192 Q) (p : P) : Q"}, {"type": "tactic", "content": "20", "name": "apply", "sideBar": true}]}, {"name": "21", "problemIndex": 5, "objects": [{"type": "lean", "content": "22", "hidden": true}, {"type": "lean", "content": "23", "hidden": true}, {"type": "text", "content": "24"}, {"type": "hint", "content": "25", "title": "26"}, {"type": "hint", "content": "27", "title": "28"}, {"type": "lemma", "text": "29", "lean": "lemma implies_self (P : Prop) : P \u2192 P :=\n", "sideBar": false, "firstProofLineNumber": 49, "lastProofLineNumber": 52, "textBefore": "import tactic --hide\n\nuniverse u --hide\n\n-- Level name : intro\n\n/-\n\n## The `intro` tactic.\n\nIf your goal is \n\n```\n\u22a2 P \u2192 Q\n```\n\nmeaning we need to prove the `P` implies `Q` then the tactic <mark style =\"background-color : #ebdef0 \">`intro hp,`</mark> \nwill take `P` as true with proof `hp` and add `hp : P` to the assumptions. In addition, \nit turn your goal into `\u22a2 Q`. \n\nIn other words the state of the lemma becomes:  \n\n```\nhp : P\n\u22a2 Q\n```\n\nLets look at an example that needs the `intro` tactic: \n\n\n-/ \n\n\n/-Hint : Hint\nStart with `intro p`.\n-/\n\n/-Hint : Tip\n `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hp hq` if your goal is `P \u2192 Q \u2192 R`.\n-/\n\n/- Lemma : no-side-bar\nIf $P$ is a logical statement then $P\\implies P$.\n-/\nlemma implies_self (P : Prop) : P \u2192 P :=\nbegin\n", "proof": "  intro p,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : intro\n\n## The `intro` tactic.\n\nIf your goal is to prove the implication\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill add `hp : P` as an assumption (i.e. `hp` is the proof of `P`) and turn your goal into `\u22a2 Q`. \nIn other words we get: \n\n```\nhP : P\n\u22a2 Q\n```\n\nTip : `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 R`.\n\n-/", "height": 4, "editorText": "sorry", "lineOffset": 48, "name": "implies_self", "statement": "(P : Prop) : P \u2192 P"}, {"type": "tactic", "content": "30", "name": "intro", "sideBar": true}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "31", "hidden": true}, {"type": "lemma", "text": "32", "lean": "lemma lemma_1 (P Q : Prop) (hQ : Q) : P \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 13, "textBefore": "import tactic -- hide\n\n/-Lemma\nLet $P,Q$ be logical statement and assume $Q$ is true, then $P$ implies $Q$. \n-/\nlemma lemma_1 (P Q : Prop) (hQ : Q) : P \u2192 Q :=\nbegin\n", "proof": "  intro fish,\n  exact hQ,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-Hint : Why is this true?\nThis works because the implication `P \u2192 Q` is true unless `Q` is false and `P` is true. In this case\nwe are given that `Q` is always true, so the implication holds regardless of the truth value of `P`. \n-/\n", "height": 6, "editorText": "sorry", "lineOffset": 7, "name": "lemma_1", "statement": "(P Q : Prop) (hQ : Q) : P \u2192 Q"}, {"type": "hint", "content": "33", "title": "34"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "35", "hidden": true}, {"type": "lemma", "text": "36", "lean": "lemma lemma_2 (P Q : Prop) : P \u2192 Q \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 9, "lastProofLineNumber": 14, "textBefore": "import tactic -- hide\n\n\n/-Lemma \nIf $P,Q$ are logical statements, then $P$ implies $(Q \\implies P)$\n-/\nlemma lemma_2 (P Q : Prop) : P \u2192 Q \u2192 P :=\nbegin\n", "proof": "  intro hP,\n  intro hQ,\n  exact hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-Hint : Caution\n\nNote that implies `\u2192` is not associative: in general `P \u2192 (Q \u2192 R)` and `(P \u2192 Q) \u2192 R`\nmight not be equivalent. This is like subtraction on numbers -- in general\n`a - (b - c)` and `(a - b) - c` might not be equal.\nSo if we write `P \u2192 Q \u2192 R` then we'd better know what this means.\nThe convention in Lean is that it means `P \u2192 (Q \u2192 R)`. If you think\nabout it, this means that to deduce `R` you will need to prove both `P`\nand `Q`. \n-/", "height": 6, "editorText": "sorry", "lineOffset": 8, "name": "lemma_2", "statement": "(P Q : Prop) : P \u2192 Q \u2192 P"}, {"type": "hint", "content": "37", "title": "38"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "39", "hidden": true}, {"type": "text", "content": "40"}, {"type": "lemma", "text": "41", "lean": "lemma Modus_Ponens (P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 13, "lastProofLineNumber": 18, "textBefore": "import tactic -- hide\n\n/-\nIf we know `P`, and we also know `P \u2192 Q`, we can deduce `Q`. \nThis is called \"Modus Ponens\" by logicians.\n-/\n\n/- Lemma  \nIf $P$ is true and $P \\implies Q$ is true, then $Q$ is true.\n-/\nlemma Modus_Ponens (P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q :=\nbegin\n", "proof": "  intros hP hPQ,\n  apply hPQ,\n  exact hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 12, "name": "Modus_Ponens", "statement": "(P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q"}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "42", "hidden": true}, {"type": "text", "content": "43"}, {"type": "hint", "content": "44", "title": "45"}, {"type": "lemma", "text": "46", "lean": "lemma implicationss_are_transitive (P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 24, "textBefore": "import tactic --hide\n\n/-\nThe goal for this level is to show that implications are transitive. \nThat is, if `P \u2192 Q` and `Q \u2192 R` are true, then so is `P \u2192 R`.\n-/\n\n/- Hint: Hint\nIt might be useful to start by using `intros hPQ hQR hP`.\n-/\n\n\n/-Lemma  \nIf $P,Q,R$ are logical statements and $P \\implies Q$ and $Q \\implies R$ then $P \\implies R$.\n-/\nlemma implicationss_are_transitive (P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R) :=\nbegin\n", "proof": "  intros hPQ hQR hP,\n  apply hQR,\n  apply hPQ,\n  exact hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 17, "name": "implicationss_are_transitive", "statement": "(P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R)"}]}, {"name": "47", "problemIndex": 4, "objects": [{"type": "lean", "content": "48", "hidden": true}, {"type": "hint", "content": "49", "title": "50"}, {"type": "hint", "content": "51", "title": "52"}, {"type": "hint", "content": "53", "title": "54"}, {"type": "lemma", "text": "55", "lean": "lemma lemma_5 (P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R) :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 35, "textBefore": "import tactic --hide\n\n-- Level name : Boss level\n\n/- Hint : Hint 1\n Notice we have three implications, so we need to introduce all of them using `intros`.\n\n-/\n\n/-Hint : Hint 2\nWhen using `apply` we need to make sure that we use an assumption that contains our goal.\n\n-/\n\n/-Hint : Hint 3\nIf we have more than one goal to prove, then we need to do them in order. By default the lean \napplies the tactics to the first goal until complete and then moves on to the next.  \n\n-/\n\n\n/-Lemma \nIf $P,Q,R$ are logical statements and\n $(P \\implies Q \\implies R)$  then $((P \\implies Q) \\implies (P \\implies R)$.\n-/\nlemma lemma_5 (P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R) :=\nbegin\n", "proof": "  intros hPQR hPQ hP,\n  apply hPQR,\n  { exact hP },\n  { apply hPQ,\n    exact hP }\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Hint : Tip\nTo skip proving a goal you can  write `sorry,`. But don't forget to go back and prove it to solve the\nlevel.  \n\n-/", "height": 8, "editorText": "sorry", "lineOffset": 27, "name": "lemma_5", "statement": "(P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R)"}, {"type": "hint", "content": "56", "title": "57"}]}], "parents": [0]}, {"name": "58", "levels": [{"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "59", "hidden": true}, {"type": "text", "content": "60"}, {"type": "lemma", "text": "61", "lean": "lemma true_is_true : true :=\n", "sideBar": true, "firstProofLineNumber": 32, "lastProofLineNumber": 32, "textBefore": "import tactic --hide \n\n/-\n##  True and False\n\n `Prop` has two special inhabitants, the logical statements <mark style =\"background-color : #ebdef0 \">`true`</mark>,\nwith truth value true and <mark style =\"background-color : #ebdef0 \">`false`</mark> with truth value\nfalse.\n\n\nIn the following levels we will work with logical statements combining `true` and `false`.\n\nTo help us we need to introduce a new tactic:\n\n## The `triv` tactic\n\nIf your lemma has the goal: \n\n```\n\u22a2 true\n```\n\nthen <mark style =\"background-color : #ebdef0 \">`triv`</mark> will complete the proof for you. Try it out below:\n\n-/\n\n/-Lemma\nThe logical statement `true` is true.\n-/\nlemma true_is_true : true :=\nbegin \n", "proof": "  triv,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-Tactic : triv\n\nIf your lemma has the goal: \n\n```\n\u22a2 true\n```\nthen `triv` will complete the proof for you.\n\n-/", "height": 1, "editorText": "sorry", "lineOffset": 31, "name": "true_is_true", "statement": "true"}, {"type": "tactic", "content": "62", "name": "triv", "sideBar": true}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "63", "hidden": true}, {"type": "lemma", "text": "64", "lean": "lemma true_imp_true : true \u2192 true :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 9, "textBefore": "import tactic --hide\n\n/-Lemma\nTrue implies true.\n-/\nlemma true_imp_true : true \u2192 true :=\nbegin\n", "proof": "  intro t,\n  triv,", "proof_hint": "sorry", "textAfter": "\nend", "height": 2, "editorText": "sorry", "lineOffset": 7, "name": "true_imp_true", "statement": "true \u2192 true"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "65", "hidden": true}, {"type": "lemma", "text": "66", "lean": "lemma false_imp_true : false \u2192 true :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 9, "textBefore": "import tactic --hide\n\n/-Lemma\nFalse implies true.\n-/\nlemma false_imp_true : false \u2192 true :=\nbegin\n", "proof": "  intro t,\n  triv,", "proof_hint": "sorry", "textAfter": "\nend", "height": 2, "editorText": "sorry", "lineOffset": 7, "name": "false_imp_true", "statement": "false \u2192 true"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "67", "hidden": true}, {"type": "lemma", "text": "68", "lean": "lemma false_imp_false : false \u2192 false :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 12, "textBefore": "import tactic --hide\n\n/-Lemma\nFalse implies false.\n-/\nlemma false_imp_false : false \u2192 false :=\nbegin\n", "proof": "  intro f,\n  exact f,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 5, "editorText": "sorry", "lineOffset": 7, "name": "false_imp_false", "statement": "false \u2192 false"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "69", "hidden": true}, {"type": "lemma", "text": "70", "lean": "lemma true_false_false : (true \u2192 false) \u2192 false :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 13, "textBefore": "import tactic --hide\n\n/-Lemma\n$(\\mathrm{true} \\implies \\mathrm{false}) \\implies \\mathrm{false}$.\n-/\nlemma true_false_false : (true \u2192 false) \u2192 false :=\nbegin\n", "proof": "  intro f,\n  apply f,\n  triv,\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 7, "name": "true_false_false", "statement": "(true \u2192 false) \u2192 false"}]}], "parents": [1]}, {"name": "71", "levels": [{"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "72", "hidden": true}, {"type": "text", "content": "73"}, {"type": "hint", "content": "74", "title": "75"}, {"type": "lemma", "text": "76", "lean": "lemma split_example_one (P Q : Prop) (p : P) (q : Q) : P \u2227 Q :=\n", "sideBar": true, "firstProofLineNumber": 47, "lastProofLineNumber": 49, "textBefore": "import tactic --hide\n\n/-\n## The `split` tactic\n\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2227 Q\n```\n\nthen the  <mark style =\"background-color : #ebdef0 \">`split`</mark>  tactic will turn it\ninto *two* goals `\u22a2 P` and `\u22a2 Q`.\n\n-/\n\n/-Hint : Tip\nIt is best practice to indicate when you are working with two goals, either by using squiggly \nbrackets like this:\n\n```\n...\nsplit,\n{ working on P,\n  end of proof of P },\n{ working on Q,\n  end of proof of Q },\n```\n\nor by using indentation like this:\n\n```\nsplit,\n  working on P,\n  end of proof of P,\nworking on Q,\n...\n```\n-/\n\n/- Lemma\nLet $P,Q$ be logical statements and assume that they are both true, then $P \u2227 Q$ is \ntrue.\n-/\nlemma split_example_one (P Q : Prop) (p : P) (q : Q) : P \u2227 Q :=\nbegin\n", "proof": "  split,\n  exact p,\n  exact q,", "proof_hint": "sorry", "textAfter": "\nend", "height": 3, "editorText": "sorry", "lineOffset": 46, "name": "split_example_one", "statement": "(P Q : Prop) (p : P) (q : Q) : P \u2227 Q"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "77", "hidden": true}, {"type": "text", "content": "78"}, {"type": "lemma", "text": "79", "lean": "lemma split_examle_two (P : Prop) : P \u2194 P :=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 23, "textBefore": "import tactic --hide\n\n\n/-\n`split` can also be used for if and only if statements. For example, if you have `\u22a2 P \u2194 Q` and apply\n`split`, then your goal will change from \n\n```\n\u22a2 P \u2194 Q\n```\nto two goals, `\u22a2 P \u2192 Q` and `\u22a2 Q \u2192 P`.\n-/\n\n/- Lemma\nLet $P$ be a logical statement, then $P$ is true if and only if $P$ is true.\n-/\nlemma split_examle_two (P : Prop) : P \u2194 P :=\nbegin\n", "proof": "  split,\n  intro p,\n  exact p,\n  intro p,\n  exact p,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : split\n\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2227 Q\n```\n\nthen the  `split` tactic will turn it into *two* goals `\u22a2 P` and `\u22a2 Q`.\n\nMoreover, if you have an iff `P \u2194 Q` then splitting it will give you two goals, `P \u2192 Q` \n(i.e \"`P` only if `Q`\") and `P \u2190 Q ` (i.e \"`P` if `Q`\") to prove.\n\n-/", "height": 5, "editorText": "sorry", "lineOffset": 18, "name": "split_examle_two", "statement": "(P : Prop) : P \u2194 P"}, {"type": "tactic", "content": "80", "name": "split", "sideBar": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "81", "hidden": true}, {"type": "text", "content": "82"}, {"type": "hint", "content": "83", "title": "84"}, {"type": "lemma", "text": "85", "lean": "lemma left_example (P Q : Prop) (p : P) : P \u2228 Q :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 28, "textBefore": "import tactic --hide\n\n/-\n## `left` and `right`\n\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2228 Q\n```\n\nthen   <mark style =\"background-color : #ebdef0 \">`left`</mark>  changes the goal to `\u22a2 P`. \nSimilarly,  <mark style =\"background-color : #ebdef0 \">`right`</mark>  changes the goal to `\u22a2 Q`.\n-/\n\n/-Hint : Why does this work?\nThe logic is that `P` implies `P \u2228 Q` so it is enough to prove `P`. \n\n-/\n\n\n/-Lemma\nLet $P,Q$ be logical statements and assume $P$ is true, then $P \u2228 Q$ is true.\n-/\nlemma left_example (P Q : Prop) (p : P) : P \u2228 Q :=\nbegin\n", "proof": "  left,\n  exact p,", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n/- Tactic : left and right\n\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2228 Q\n```\n\nthen `left` changes the goal to `\u22a2 P`. Similarly `right` changes the goal to `\u22a2 Q`.\n\n-/", "height": 2, "editorText": "sorry", "lineOffset": 26, "name": "left_example", "statement": "(P Q : Prop) (p : P) : P \u2228 Q"}, {"type": "tactic", "content": "86", "name": "left and right", "sideBar": true}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "87", "hidden": true}, {"type": "text", "content": "88"}, {"type": "lemma", "text": "89", "lean": "lemma cases_and_example (P Q : Prop) (h : P \u2227 Q) : P :=\n", "sideBar": true, "firstProofLineNumber": 42, "lastProofLineNumber": 43, "textBefore": "import tactic --hide\n\n/-\n## The `cases` tactic\n\n`cases` is a very general-purpose tactic for \"deconstructing\" hypotheses.\nIf `h` is an assumption which somehow \"bundles up\" two pieces of information,\nthen  <mark style =\"background-color : #ebdef0 \">`cases h with h1 h2`</mark>  will make the \nassumption `h` vanish and will replace it with the two \"components\" which made the proof of `h` in the first place.\nAn example of this occurring is if you have the assumption `h : P \u2227 Q` which contains a \nproof of `P` and a proof of `Q`.\n\n\n\nFor example, if you have an assumption\n\n```\nh : P \u2227 Q\n```\n\nthen\n\n`cases h with hP hQ,`\n\nwill delete `h` and replace it with\n\n```\nhP : P\nhQ : Q\n```\nTry it out below.\n\n-/\n\n\n/- Lemma\nIf $P,Q$ are logical statements and $P \u2227 Q$ is true then so is $P$.\n-/\n\nlemma cases_and_example (P Q : Prop) (h : P \u2227 Q) : P :=\nbegin \n", "proof": "  cases h with hP hQ,\n  exact hP,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : cases\n\nIf you have a hypothesis\n\n```\nh : P \u2227 Q\n```\n\nthen\n\n`cases h with hP hQ,`\n\nwill delete `h` and replace it with\n\n```\nhP : P\nhQ : Q\n```\n\nYou can also use it for \"or's\". Specifically, if you have `h : P \u2228 Q` then `cases h` will\ngive you two goals, one where `P` is true and one where `Q` is true.\n\n-/", "height": 2, "editorText": "sorry", "lineOffset": 41, "name": "cases_and_example", "statement": "(P Q : Prop) (h : P \u2227 Q) : P"}, {"type": "tactic", "content": "90", "name": "cases", "sideBar": true}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "91", "hidden": true}, {"type": "text", "content": "92"}, {"type": "lemma", "text": "93", "lean": "lemma cases_or_example (P : Prop) (hp : P \u2228 P) : P :=\n", "sideBar": true, "firstProofLineNumber": 37, "lastProofLineNumber": 39, "textBefore": "import tactic --hide\n\n\n/-\nYou can also use `cases` when working with the `\u2228` (\"or\") connective. For example, if you have\nthe assumption\n\n```\nh : P \u2228 Q\n``` \n\nthen `cases h with hp hq` will convert your state into the following two states:\n\n```\nP : Prop\nhp : P\n\u22a2 P\n```\nand\n\n```\nP : Prop\nhq : Q\n\u22a2 Q\n```\none where `P` is true and one where `Q` is true.\n\nTry this in the lemma below.\n-/\n\n/- Lemma\nIf $P$ is a logical statement and $P$ or $P$ is true, then $P$ is true.\n-/\n\nlemma cases_or_example (P : Prop) (hp : P \u2228 P) : P :=\nbegin\n", "proof": "  cases hp with hp hp,\n  exact hp,\n  exact hp,", "proof_hint": "sorry", "textAfter": "\nend", "height": 3, "editorText": "sorry", "lineOffset": 36, "name": "cases_or_example", "statement": "(P : Prop) (hp : P \u2228 P) : P"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "94", "hidden": true}, {"type": "text", "content": "95"}, {"type": "lemma", "text": "96", "lean": "lemma and_commutative (P Q : Prop) : P \u2227 Q \u2194 Q \u2227 P :=\n", "sideBar": true, "firstProofLineNumber": 12, "lastProofLineNumber": 23, "textBefore": "import tactic --hide\n\n/-\nThis level proves that `\u2227` is a commutative operator. \n-/\n\n/-Lemma\nLet $P,Q$ be logical statements, then $P \u2227 Q$ is true iff $Q \u2227 P$ is true.\n-/\nlemma and_commutative (P Q : Prop) : P \u2227 Q \u2194 Q \u2227 P :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h,\n  split,\n  exact h_right,\n  exact h_left,\n  intro h,\n  split,\n  exact h.2,\n  exact h.1,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 12, "editorText": "sorry", "lineOffset": 11, "name": "and_commutative", "statement": "(P Q : Prop) : P \u2227 Q \u2194 Q \u2227 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "97", "hidden": true}, {"type": "lemma", "text": "98", "lean": "lemma and_implication (P Q R : Prop) :  P \u2228 Q \u2192 (P \u2192 R) \u2192 (Q \u2192 R) \u2192 R :=\n", "sideBar": true, "firstProofLineNumber": 9, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-Lemma\nIf $P,Q,R$ are logical statements then $P \u2227 Q$ implies that \n$(P \\implies R) \\implies (Q \\implies R) \\implies R$ \n-/\nlemma and_implication (P Q R : Prop) :  P \u2228 Q \u2192 (P \u2192 R) \u2192 (Q \u2192 R) \u2192 R :=\nbegin\n", "proof": "  intros hPoQ hPR hQR,\n  cases hPoQ with hP hQ,\n  { apply hPR,\n    exact hP },\n  { exact hQR hQ }\n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 8, "name": "and_implication", "statement": "(P Q R : Prop) :  P \u2228 Q \u2192 (P \u2192 R) \u2192 (Q \u2192 R) \u2192 R"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "99", "hidden": true}, {"type": "text", "content": "100"}, {"type": "lemma", "text": "101", "lean": "lemma and_transitive (P Q R: Prop) : (P \u2227 Q) \u2192 (Q \u2227 R) \u2192 (P \u2227 R)  :=\n", "sideBar": true, "firstProofLineNumber": 12, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-\nThis level will show that `\u2227` is *transitive*.\n-/\n\n/-Lemma\nIf $P,Q,R$ are logical statements, then $P \u2227 Q$ and $Q \u2227 R$ imples $P \u2227 R$.\n-/\nlemma and_transitive (P Q R: Prop) : (P \u2227 Q) \u2192 (Q \u2227 R) \u2192 (P \u2227 R)  :=\nbegin\n", "proof": "  rintro \u27e8hP, hQ\u27e9 \u27e8-, hR\u27e9,\n  exact \u27e8hP, hR\u27e9,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 3, "editorText": "sorry", "lineOffset": 11, "name": "and_transitive", "statement": "(P Q R: Prop) : (P \u2227 Q) \u2192 (Q \u2227 R) \u2192 (P \u2227 R)"}]}], "parents": [1]}, {"name": "102", "levels": [{"name": "103", "problemIndex": 2, "objects": [{"type": "lean", "content": "104", "hidden": true}, {"type": "text", "content": "105"}, {"type": "lemma", "text": "106", "lean": "lemma absorption_one (P Q : Prop) : P \u2227 (P \u2228 Q) \u2194 P :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 25, "textBefore": "import tactic --hide\n\n-- Level name : absorption laws pt 1\n\n/-\nThis level proves the first *absorption* law.\n-/\n\n/-Lemma\nIf $P,Q$ are logical statements then $P \u2227 (P \u2228 Q)$ is true if and only if $P$ is true.\n-/\nlemma absorption_one (P Q : Prop) : P \u2227 (P \u2228 Q) \u2194 P :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with hP hPQ,\n  exact hP,\n  intro h,\n  split,\n  exact h,\n  left,\n  exact h,  \n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 12, "editorText": "sorry", "lineOffset": 13, "name": "absorption_one", "statement": "(P Q : Prop) : P \u2227 (P \u2228 Q) \u2194 P"}]}, {"name": "107", "problemIndex": 2, "objects": [{"type": "lean", "content": "108", "hidden": true}, {"type": "text", "content": "109"}, {"type": "lemma", "text": "110", "lean": "lemma absorption_two (P Q : Prop) : P \u2228 (P \u2227 Q) \u2194 P :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 22, "textBefore": "import tactic --hide\n\n-- Level name : absorpsion laws pt 2\n\n/-\nThis level proves the second absorption law.\n-/\n\n/-Lemma\nIf $P,Q$ are logical statements then $P \u2228 (P \u2227 Q)$ is true if and only if $P$ is true.\n-/\nlemma absorption_two (P Q : Prop) : P \u2228 (P \u2227 Q) \u2194 P :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h,\n  exact h,\n  cases h,\n  exact h_left,\n  intro h,\n  left,\n  exact h,", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 9, "editorText": "sorry", "lineOffset": 13, "name": "absorption_two", "statement": "(P Q : Prop) : P \u2228 (P \u2227 Q) \u2194 P"}]}, {"name": "111", "problemIndex": 2, "objects": [{"type": "lean", "content": "112", "hidden": true}, {"type": "text", "content": "113"}, {"type": "lemma", "text": "114", "lean": "lemma associativity_one (P Q R : Prop) : P \u2227 (Q \u2227 R) \u2194 (P \u2227 Q) \u2227 R :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 31, "textBefore": "import tactic --hide\n\n-- Level name : Associative laws pt 1\n\n/-\nThis level proves that `\u2227` is *associative*.\n-/\n\n/-Lemma\nIf $P,Q,R$ are logical statements, then $P \u2227 (Q \u2227 R)$ is true iff $(P \u2227 Q) \u2227 R$ is true.\n-/\nlemma associativity_one (P Q R : Prop) : P \u2227 (Q \u2227 R) \u2194 (P \u2227 Q) \u2227 R :=\nbegin\n", "proof": "  split,\n  intro h,\n  split,\n  cases h with hl hr,\n  split,\n  exact hl,\n  cases hr,\n  exact hr_left,\n  cases h with h1 h2,\n  cases h2 with h2 h3,\n  exact h3,\n  intro h,\n  split,\n  cases h,\n  exact h_left.1,\n  split,\n  exact h.1.2,\n  exact h.2,", "proof_hint": "sorry", "textAfter": "\nend", "height": 18, "editorText": "sorry", "lineOffset": 13, "name": "associativity_one", "statement": "(P Q R : Prop) : P \u2227 (Q \u2227 R) \u2194 (P \u2227 Q) \u2227 R"}]}, {"name": "115", "problemIndex": 2, "objects": [{"type": "lean", "content": "116", "hidden": true}, {"type": "text", "content": "117"}, {"type": "lemma", "text": "118", "lean": "lemma associativity_two (P Q R : Prop) : P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 36, "textBefore": "import tactic --hide\n\n-- Level name : Associative laws pt 2\n\n/-\nThis level proves that `\u2228` is associative.\n-/\n\n/-Lemma\nIf $P,Q,R$ are logical statements then $P \u2228 (Q \u2228 R)$ is true iff $(P \u2228 Q) \u2228 R$ is true.\n-/\nlemma associativity_two (P Q R : Prop) : P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with h1 h2,\n  left,\n  left,\n  exact h1,\n  cases h2 with h2 h3,\n  left,\n  right,\n  exact h2,\n  right,\n  exact h3,\n  intro h,\n  cases h with h1 h2,\n  cases h1 with h1 h3,\n  left,\n  exact h1,\n  right,\n  left,\n  exact h3,\n  right,\n  right,\n  exact h2,", "proof_hint": "sorry", "textAfter": "\nend", "height": 23, "editorText": "sorry", "lineOffset": 13, "name": "associativity_two", "statement": "(P Q R : Prop) : P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R"}]}, {"name": "119", "problemIndex": 2, "objects": [{"type": "lean", "content": "120", "hidden": true}, {"type": "text", "content": "121"}, {"type": "lemma", "text": "122", "lean": "lemma distributivity_one (P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R) :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 35, "textBefore": "import tactic --hide\n\n-- Level name : Distributive laws 1\n\n/-\nThis level proves the *distributivity* of `\u2227` over `\u2228`.\n-/\n\n/-Lemma\nIf $P,Q,R$ are logical statements then $P \u2227 (Q \u2228 R)$ is true iff $(P \u2227 Q) \u2228 (P \u2227 R)$ is true.\n-/\nlemma distributivity_one (P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R) :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with h1 h2,\n  cases h2 with h2 h3,\n  left,\n  split,\n  exact h1,\n  exact h2,\n  right,\n  split,\n  exact h1,\n  exact h3,\n  intro h,\n  cases h with h1 h2,\n  split,\n  exact h1.1,\n  left,\n  exact h1.2,\n  split,\n  exact h2.1,\n  right,\n  exact h2.2,", "proof_hint": "sorry", "textAfter": "\nend ", "height": 22, "editorText": "sorry", "lineOffset": 13, "name": "distributivity_one", "statement": "(P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R)"}]}, {"name": "123", "problemIndex": 2, "objects": [{"type": "lean", "content": "124", "hidden": true}, {"type": "text", "content": "125"}, {"type": "lemma", "text": "126", "lean": "lemma distributivity_two (P Q R : Prop) : P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R) :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 40, "textBefore": "import tactic --hide\n\n-- Level name : Distributive laws 2\n\n/-\nThis level proves the distributivity of `\u2228` over `\u2227`.\n-/\n\n/-Lemma\nIf $P,Q,R$ are logical statements then $P \u2228 (Q \u2227 R)$ is true iff $(P \u2228 Q) \u2227 (P \u2228 R)$ is true.\n-/\nlemma distributivity_two (P Q R : Prop) : P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R) :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h,\n  split,\n  left,\n  exact h,\n  left,\n  exact h,\n  split,\n  right,\n  exact h.1,\n  right,\n  exact h.2,\n  intro h,\n  cases h,\n  cases h_left with h1 h2,\n  left,\n  exact h1,\n  cases h_right with h4 h5,\n  left,\n  exact h4,\n  right,\n  split,\n  exact h2,\n  exact h5,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 27, "editorText": "sorry", "lineOffset": 13, "name": "distributivity_two", "statement": "(P Q R : Prop) : P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R)"}]}], "parents": [3]}, {"name": "127", "levels": [{"name": "", "problemIndex": 5, "objects": [{"type": "axiom", "content": "128", "name": "not_iff_imp_false (P : Prop) :", "sideBar": true}, {"type": "text", "content": "129"}, {"type": "lean", "content": "130", "hidden": true}, {"type": "text", "content": "131"}, {"type": "hint", "content": "132", "title": "133"}, {"type": "lemma", "text": "134", "lean": "lemma contrapositive (P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P) :=\n", "sideBar": true, "firstProofLineNumber": 43, "lastProofLineNumber": 52, "textBefore": "/- Axiom : not_iff_imp_false (P : Prop) :\n\u00ac P \u2194 P \u2192 false\n-/\n\n/-\n\n\nBy definition `\u00acQ` is equivalent to `Q \u2192 false`. Lets call this result\n\n`not_iff_imp_false (P : Prop) : \u00ac P \u2194 (P \u2192 false)`\n\n-/\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false :=iff.rfl-- hide\n/-\n\nYou can convince yourself this is true by writting out the truth table for `\u00ac P` and `P \u2192 false`.\n\n\nIn order to use it, lets look at a new tactic.\n\n## The `rw` tactic\n\nThe <mark style =\"background-color : #ebdef0 \">`rw`</mark> tactic (short for <mark style =\"background-color : #ebdef0 \">`rewrite`</mark>) \nis a tactic that allows you to do a substitution. For example, if we have the\nassumption `h : P \u2194 Q`, then `rw h` will replace the (first) `P` in the goal with `Q`. If instead you would like to \nturn the first `Q` in your goal to `P` then use `rw \u2190h`. (To get the `\u2190` arrow, type `\\l`).\n\nCombining `rw` and `not_iff_imp_false`, try to prove the following:\n\n-/\n\n/- Hint : Hint\n Start by using `rw not_iff_imp_false,` and see what changes.\n-/\n\n\n/- Lemma \nIf $P$ and $Q$ are propositions, and $P\\implies Q$, then\n$\\lnot Q\\implies \\lnot P$. \n-/\nlemma contrapositive (P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P) :=\nbegin\n", "proof": "  rw not_iff_imp_false,\n  rw not_iff_imp_false,\n  intro f,\n  intro h,\n  intro p,\n  apply h,\n  apply f,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-Hint : Tip\nIf you want to use the `rw` tactic on one of your assumptions then this can be done.\n\nFor example, if we have `h1 : P \u2194 Q` and `h2` is the assumption we want to change, then\n `rw h1 at h2` will substitute the first `P` in `h2` to `Q`. \n\n-/\n\n\n/- Tactic : rw \n\nThe `rw` tactic is a tactic that allows you to substitute in things. For example, if we have the\nassumption `h: P \u2194 Q`, then `rw h` will replace the `P`'s in the goal with `Q`'s. If instead you would like to \nturn all of the `Q`'s in your goal to `P`'s then using `rw \u2190h` will do this. (To get the `\u2190` arrow, type `\\l`).\n\nMoreover, if we have `h1 : P \u2194 Q` and `h2` is the assumption we want to change, then\n `rw h1 at h2` will substitute the first `P` in `h2` to `Q`. \n\n-/", "height": 10, "editorText": "sorry", "lineOffset": 42, "name": "contrapositive", "statement": "(P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)"}, {"type": "hint", "content": "135", "title": "136"}, {"type": "tactic", "content": "137", "name": "rw", "sideBar": true}]}, {"name": "138", "problemIndex": 3, "objects": [{"type": "lean", "content": "139", "hidden": true}, {"type": "text", "content": "140"}, {"type": "hint", "content": "141", "title": "142"}, {"type": "lemma", "text": "143", "lean": "lemma false_imp_P (P : Prop) : false \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 30, "textBefore": "import tactic --hide\n\n-- Level name : The `exfalso` tactic.\n\n/-\nIn this level we want to prove prove that `false` implies any proposition `P`.\n\n-/\n\n\n/-Hint : Hint\nYou can do this using only `intro` and `cases`.\n-/\n\n/-Lemma\nIf $P$ is a logical statement then $\\mathrm{false}$ implies $P$.\n-/\nlemma false_imp_P (P : Prop) : false \u2192 P :=\nbegin\n", "proof": " intro h,\n cases h,\n\n\n \n \n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n/-Hint : What is going on here?\nOne way to solve this level is to use `intro h` followed by `cases h`.  Notice that using `intro h`,\nintroduces the assumption `h : false`. Lean thinks of `false` as empty, i.e having no elements. \n`cases h` goes through each element in `h` and tries to prove our goal. \nBut since our assumption is `false` there are no cases, so the result is trivially true. \nTo make sense of this outside of Lean, we think that starting from a false statement we can have \nany outcome, both true and false (see levels 3 & 4 of \"True and False\" world).\n\n-/\n\n/-\n## The `exfalso` tactic \n\nA way to use this result in Lean is with the <mark style =\"background-color : #ebdef0 \"> `exfalso`</mark> tactic, \nwhich changes any goal to `false`. \n-/\n\n/-Tactic : exfalso\nThis changes any goal to `false`.\n-/\n\n", "height": 11, "editorText": "sorry", "lineOffset": 19, "name": "false_imp_P", "statement": "(P : Prop) : false \u2192 P"}, {"type": "hint", "content": "144", "title": "145"}, {"type": "text", "content": "146"}, {"type": "tactic", "content": "147", "name": "exfalso", "sideBar": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "148", "hidden": true}, {"type": "lean", "content": "149", "hidden": true}, {"type": "text", "content": "150"}, {"type": "lemma", "text": "151", "lean": "lemma P_not_P_false (P : Prop) : P \u2227 \u00ac P \u2192 false :=\n", "sideBar": true, "firstProofLineNumber": 13, "lastProofLineNumber": 20, "textBefore": "import tactic --hide\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n/-\nIn this level we will prove that `P \u2227 \u00ac P` is always false. This is an example of a *contradiction*.\n\n-/\n\n/-Lemma\nIf $P$ is a logical statement, then $P \u2227 \u00acP$ is false.\n-/\nlemma P_not_P_false (P : Prop) : P \u2227 \u00ac P \u2192 false :=\nbegin\n", "proof": "  intro h,\n  cases h with h1 h2,\n  rw not_iff_imp_false at h2,\n  apply h2,\n  exact h1,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 8, "editorText": "sorry", "lineOffset": 12, "name": "P_not_P_false", "statement": "(P : Prop) : P \u2227 \u00ac P \u2192 false"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "152", "hidden": true}, {"type": "lean", "content": "153", "hidden": true}, {"type": "text", "content": "154"}, {"type": "hint", "content": "155", "title": "156"}, {"type": "hint", "content": "157", "title": "158"}, {"type": "lemma", "text": "159", "lean": "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 35, "textBefore": "\nimport tactic --hide\n\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n\n/-\n##  Proof by contradiction. \n\nIn this level we will see why proofs by contradiction are valid. The key is to note that for any\nlogical statements `P,Q`, we have that ` P \u2227 (\u00ac P) \u2192 Q` is true.\n\n-/\n\n/-Hint : Why is this true?\nWe have just seen that `P \u2227 (\u00ac P)`is always false and `false \u2192 Q` is always true.\n-/\n\n/- Hint : Hint\nStart by introducing your assumption and then using `exfalso`.\n-/\n\n/- Lemma \nIf $P$ and $Q$ are logical statements, then\n$(P\\land(\\lnot P))\\implies Q.$\n-/\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q :=\nbegin\n", "proof": "  intro h,\n  exfalso,\n  cases h with p np,\n  rw not_iff_imp_false at np,\n  apply np,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-Hint : Tip\nIf you want to use to use this result later on then you can type <mark style =\"background-color : #ebdef0 \">`apply (contra P Q)`</mark> where `P,Q` are\nthe assumptions you want to use. You can also use the tactic <mark style =\"background-color : #ebdef0 \">`by_contra`</mark>  \nto achieve similar results. \n\n-/\n\n", "height": 8, "editorText": "sorry", "lineOffset": 27, "name": "contra", "statement": "(P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q"}, {"type": "hint", "content": "160", "title": "161"}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "162", "hidden": true}, {"type": "lean", "content": "163", "hidden": true}, {"type": "lean", "content": "164", "hidden": true}, {"type": "lean", "content": "165", "hidden": true}, {"type": "text", "content": "166"}, {"type": "hint", "content": "167", "title": "168"}, {"type": "text", "content": "169"}, {"type": "lemma", "text": "170", "lean": "lemma contrapositive_2 (P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q) :=\n", "sideBar": true, "firstProofLineNumber": 68, "lastProofLineNumber": 89, "textBefore": "\nimport tactic --hide\n\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\nlemma P_not_P_false (P : Prop) : P \u2227 \u00ac P \u2192 false := by {cc} --hide\n\n/-\nWe proved earlier that `(P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)`. The converse,\nthat `(\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q)` is certainly true, but trying to prove\nit using the tactics we've learnt so far is impossible. \n-/\n\n/-Hint : Why is this impossible?\n \nSuppose we tried to prove this with the tactics we have seen so far, then our proof might look \nsomething like:\n```\nintro h,\nintro p,\nrw not_iff_imp_false at h,\nrw not_iff_imp_false at h,\n```\nYou are then left with the following state:\n```\nP Q : Prop,\nh : (Q \u2192 false) \u2192 P \u2192 false\np : P\n\u22a2 Q\n```\nand now we are stuck. In fact, using tactics such as `intro` and `apply` you will never be able to \nprove this lemma as this is not provable in \"constructive logic\". The key in proving this is to use \nLean's version of a truth table!\n\n-/\n\n/-\nIn order to continue we need a new tactic.\n\n## The `by_cases` tactic\n\nThe tactic <mark style =\"background-color : #ebdef0 \">`by_cases`</mark> allows us to create Lean's \nversion of a truth table.\n\nFor example, if you have `P Q : Prop`, then <mark style =\"background-color : #ebdef0 \">`by_cases hp : P; by_cases hq : Q,`</mark>\nwill create four goals, one for each of the four  possibilities for `P,Q`, i.e., \n\n```md\n| `P`     | `Q`     |\n| --------|---------|\n| `true`  | `true`  | \n| `true`  | `false` |   \n| `false` | `true`  |   \n| `false` | `false` |   \n```\n\n**Note the semicolon**! It means \"do the next tactic to all the goals, not just the first\".\n\n-/\n\n\n/- Lemma :\nIf $P$ and $Q$ are logical statements, then\n$(\\lnot Q\\implies \\lnot P)\\implies(P\\implies Q).$\n-/\nlemma contrapositive_2 (P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q) :=\nbegin\n", "proof": "  by_cases p : P; by_cases q : Q,\n  intros h hh,\n  exact q,\n  intros h hh,\n  exfalso,\n  rw not_iff_imp_false at h,\n  rw not_iff_imp_false at h,\n  rw not_iff_imp_false at q,\n  apply h,\n  exact q,\n  apply p,\n  intros h hh,\n  exact q,\n  intros h hh,\n  exfalso,\n  apply P_not_P_false P,\n  split,\n  exact hh,\n  apply h,\n  exact q,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-Hint : +1 Intelligence\nThe `by_cases` tactic works by adding the assumption `P \u2228 \u00ac P` and then doing `cases` on this.\nThe fact that `P \u2228 \u00ac P` is true is called the *law of the excluded middle*, and it cannot be proven \nby just using tactics such as `intro` and `apply`.\n-/\n\n/-Tactic : by_cases\n \nThe ``by_cases`` tactic is a simple truth table tactic: ``by_cases P`` turns one goal into two goals, \nwith ``P`` is assumed in the first, and ``\u00acP`` in the second.\n\nExamples\n--------\n\n1) If ``P`` is a proposition, then ``by_cases P`` turns your goal into two goals, \nand in each of your new tactic states you have one extra hypothesis. \nIn the first one you have a new hypothesis ``h : P`` and in the second you have a new hypothesis ``h : \u00acP``.\n\n2) If you already have a hypothesis ``h`` then this can get a bit confusing, \nso you can also do ``by_cases hP : P``; then your new hypotheses will be ``hP : P`` and ``hP : \u00acP``.\n-/", "height": 22, "editorText": "sorry", "lineOffset": 67, "name": "contrapositive_2", "statement": "(P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q)"}, {"type": "hint", "content": "171", "title": "172"}, {"type": "tactic", "content": "173", "name": "by_cases", "sideBar": true}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "174", "hidden": true}, {"type": "lemma", "text": "175", "lean": "lemma P_imp_not_P_false (P : Prop) : P \u2192 \u00ac P \u2192 false :=\n", "sideBar": true, "firstProofLineNumber": 9, "lastProofLineNumber": 13, "textBefore": "import tactic --hide\n\n/-Lemma\nIf $P$ is a logical statement then $P \\implies \u00acP$ implies $\\mathrm{false}$.\n-/\n\nlemma P_imp_not_P_false (P : Prop) : P \u2192 \u00ac P \u2192 false :=\nbegin\n", "proof": "  intros h1 h2,\n  apply h2,\n  exact h1,\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 5, "editorText": "sorry", "lineOffset": 8, "name": "P_imp_not_P_false", "statement": "(P : Prop) : P \u2192 \u00ac P \u2192 false"}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "176", "hidden": true}, {"type": "lean", "content": "177", "hidden": true}, {"type": "hint", "content": "178", "title": "179"}, {"type": "lemma", "text": "180", "lean": "lemma P_not_not_P (P : Prop) : P \u2192 \u00ac (\u00ac P) :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 21, "textBefore": "import tactic --hide\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n\n\n/-Hint : Hint\nTry using `rw not_iff_imp_false,`.\n-/\n\n/-Lemma\nIf $P$ is a logical statement then $P \\implies \u00ac \u00acP$.\n-/\nlemma P_not_not_P (P : Prop) : P \u2192 \u00ac (\u00ac P) :=\nbegin\n", "proof": "  intro P,\n  rw not_iff_imp_false,\n  intro hp,\n  apply hp,\n  exact P,\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 8, "editorText": "sorry", "lineOffset": 13, "name": "P_not_not_P", "statement": "(P : Prop) : P \u2192 \u00ac (\u00ac P)"}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "181", "hidden": true}, {"type": "lean", "content": "182", "hidden": true}, {"type": "lean", "content": "183", "hidden": true}, {"type": "lemma", "text": "184", "lean": "lemma not_not_P_imp_P (P : Prop) :\u00ac (\u00ac P) \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 11, "lastProofLineNumber": 19, "textBefore": "import tactic --hide\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n\n\n/-Lemma\nIf $P$ is a logical statement then $\u00ac(\u00acP) \\implies P$.\n-/\nlemma not_not_P_imp_P (P : Prop) :\u00ac (\u00ac P) \u2192 P :=\nbegin\n", "proof": "  rw not_iff_imp_false,\n  intro hp,\n  by_cases hp2 : P,\n  exact hp2,\n  exfalso,\n  apply hp,\n  exact hp2,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 9, "editorText": "sorry", "lineOffset": 10, "name": "not_not_P_imp_P", "statement": "(P : Prop) :\u00ac (\u00ac P) \u2192 P"}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "185", "hidden": true}, {"type": "lean", "content": "186", "hidden": true}, {"type": "lean", "content": "187", "hidden": true}, {"type": "lemma", "text": "188", "lean": "lemma P_imp_Q_equiv_not_P_and_Q (P Q : Prop) : (P \u2192 Q) \u2194 \u00ac P \u2228 Q :=\n", "sideBar": true, "firstProofLineNumber": 11, "lastProofLineNumber": 26, "textBefore": "import tactic --hide\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n\n\n/-Lemma\nIf $P, Q$ are logical statements then $(P \\implies Q)$ is equivalent to $(\u00acP) \u2228 Q$.\n-/\nlemma P_imp_Q_equiv_not_P_and_Q (P Q : Prop) : (P \u2192 Q) \u2194 \u00ac P \u2228 Q :=\nbegin\n", "proof": "  split,\n  intro h,\n  by_cases p : P,\n  right,\n  apply h,\n  exact p,\n  left,\n  exact p,\n  intros h1 h2,\n  cases h1,\n  exfalso,\n  apply h1,\n  exact h2,\n  exact h1,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 16, "editorText": "sorry", "lineOffset": 10, "name": "P_imp_Q_equiv_not_P_and_Q", "statement": "(P Q : Prop) : (P \u2192 Q) \u2194 \u00ac P \u2228 Q"}]}], "parents": [3]}, {"name": "189", "levels": [{"name": "190", "problemIndex": 8, "objects": [{"type": "lean", "content": "191", "hidden": true}, {"type": "lean", "content": "192", "hidden": true}, {"type": "lean", "content": "193", "hidden": true}, {"type": "lean", "content": "194", "hidden": true}, {"type": "text", "content": "195"}, {"type": "hint", "content": "196", "title": "197"}, {"type": "hint", "content": "198", "title": "199"}, {"type": "hint", "content": "200", "title": "201"}, {"type": "lemma", "text": "202", "lean": "lemma DeMorgan_one (P Q : Prop) : \u00ac (P \u2228 Q) \u2194 \u00ac P \u2227 \u00ac Q :=\n", "sideBar": true, "firstProofLineNumber": 40, "lastProofLineNumber": 59, "textBefore": "import tactic --hide\n\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\nlemma P_not_P_false (P : Prop) : P \u2227 \u00ac P \u2192 false := by {cc} --hide\n\n-- Level name : De Morgan's laws, First Boss\n\n/-\nIt is time to tackle our final bosses, the *De Morgans laws*. Use your tactics wisely!\n\n-/\n\n/-Hint : First Aid\n\nYou can do this only using `split`, `intro`, `apply`, `left`, `right`.\n\n-/\n\n/- Hint : Second Aid\n\nIf you have a goal `\u00acP` then `intro h` will turn your goal into `false` and give you\nan extra assumption `h : P`.\n\n-/\n\n/- Hint : Third Aid\n\nIf you have a goal `false` and an assumption `h : \u00acP`, then `apply h` will turn your goal \ninto `P`.\n\n-/\n\n/-Lemma\nIf $P,Q$ are logical statements  $\u00ac(P \u2228 Q)$ is equivalent to $\u00ac P \u2227 \u00acQ$.\n-/\n\nlemma DeMorgan_one (P Q : Prop) : \u00ac (P \u2228 Q) \u2194 \u00ac P \u2227 \u00ac Q :=\nbegin\n", "proof": "  split,\n  { intro h,\n    split,\n    { intro hP,\n      apply h,\n      left, \n      exact hP },\n    { intro hQ,\n      apply h,\n      right,\n      exact hQ } },\n  { intro h,\n    intro h2,\n    cases h,\n    cases h2,\n    apply h_left,\n    exact h2,\n    apply h_right,\n    exact h2,}\n    ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 20, "editorText": "sorry", "lineOffset": 39, "name": "DeMorgan_one", "statement": "(P Q : Prop) : \u00ac (P \u2228 Q) \u2194 \u00ac P \u2227 \u00ac Q"}]}, {"name": "203", "problemIndex": 5, "objects": [{"type": "lean", "content": "204", "hidden": true}, {"type": "lean", "content": "205", "hidden": true}, {"type": "lean", "content": "206", "hidden": true}, {"type": "lean", "content": "207", "hidden": true}, {"type": "text", "content": "208"}, {"type": "lemma", "text": "209", "lean": "lemma DeMorgan_two (P Q : Prop) :  \u00ac (P \u2227 Q) \u2194 \u00ac P \u2228 \u00ac Q :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 34, "textBefore": "import tactic --hide\n\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\nlemma P_not_P_false (P : Prop) : P \u2227 \u00ac P \u2192 false := by {cc} --hide\n\n\n-- Level name : De Morgan's laws, Final Boss\n\n/-\nFor this final battle with De Morgan, you are on your own!\n-/\n\n/-Lemma\nIf $P,Q$ are logical statements then $\u00ac(P \u2227 Q)$ is equivalent to $\u00ac P \u2228 \u00acQ$.\n-/\n\nlemma DeMorgan_two (P Q : Prop) :  \u00ac (P \u2227 Q) \u2194 \u00ac P \u2228 \u00ac Q :=\nbegin\n", "proof": "  split,\n  { intro h,\n    by_cases hP : P,\n    { right,\n      intro hQ,\n      apply h,\n      exact \u27e8hP, hQ\u27e9 },\n    { left,\n      exact hP } },\n  { rintro (hnP | hnQ) \u27e8hP, hQ\u27e9,\n    { apply contra P false,\n      split,\n      exact hP,\n      exact hnP, },\n    { apply hnQ, exact hQ } }", "proof_hint": "sorry", "textAfter": "\nend", "height": 15, "editorText": "sorry", "lineOffset": 19, "name": "DeMorgan_two", "statement": "(P Q : Prop) :  \u00ac (P \u2227 Q) \u2194 \u00ac P \u2228 \u00ac Q"}]}], "parents": [4, 5]}, {"name": "210", "levels": [{"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "211", "hidden": true}, {"type": "lean", "content": "212", "hidden": true}, {"type": "lean", "content": "213", "hidden": true}, {"type": "lemma", "text": "214", "lean": "lemma not_false_imp_true : \u00ac false \u2192 true :=\n", "sideBar": true, "firstProofLineNumber": 11, "lastProofLineNumber": 15, "textBefore": "import tactic --hide\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n\n\n/-Lemma\n$\u00ac \\mathrm{false}$ implies $\\mathrm{true}$.\n-/\nlemma not_false_imp_true : \u00ac false \u2192 true :=\nbegin\n", "proof": "  intro h,\n  triv,\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 5, "editorText": "sorry", "lineOffset": 10, "name": "not_false_imp_true", "statement": "\u00ac false \u2192 true"}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "215", "hidden": true}, {"type": "lean", "content": "216", "hidden": true}, {"type": "lean", "content": "217", "hidden": true}, {"type": "lemma", "text": "218", "lean": "lemma not_true_imp_false : \u00ac true \u2192 false :=\n", "sideBar": true, "firstProofLineNumber": 11, "lastProofLineNumber": 17, "textBefore": "import tactic --hide\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n\n\n/-Lemma\n$\u00ac \\mathrm{true}$ implies $\\mathrm{false}$.\n-/\nlemma not_true_imp_false : \u00ac true \u2192 false :=\nbegin\n", "proof": "  rw not_iff_imp_false,\n  intro h,\n  apply h,\n  triv,\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 10, "name": "not_true_imp_false", "statement": "\u00ac true \u2192 false"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "219", "hidden": true}, {"type": "lemma", "text": "220", "lean": "lemma P_to_P_to_false_to_false (P : Prop) :  P \u2192 ((P \u2192 false) \u2192 false) :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 12, "textBefore": "import tactic --hide\n\n/-Lemma\nIf $P$ is a logical statement then $P$ implies $(P \\implies \\mathrm{false}) \\implies \\mathrm{false}$\n-/\nlemma P_to_P_to_false_to_false (P : Prop) :  P \u2192 ((P \u2192 false) \u2192 false) :=\nbegin\n", "proof": "   intros hp hpf, \n   apply hpf,\n   exact hp,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 5, "editorText": "sorry", "lineOffset": 7, "name": "P_to_P_to_false_to_false", "statement": "(P : Prop) :  P \u2192 ((P \u2192 false) \u2192 false)"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "221", "hidden": true}, {"type": "lemma", "text": "222", "lean": "lemma P_to_false_to_P_to_Q (P Q : Prop) : (P \u2192 false) \u2192 P \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-Lemma\nIf $P, Q$ are logical statements then $P \\implies \\mathrm{false}$ implies $P \\implies Q$. \n-/\nlemma P_to_false_to_P_to_Q (P Q : Prop) : (P \u2192 false) \u2192 P \u2192 Q :=\nbegin\n", "proof": "  intros hpf hp,\n  exfalso,\n  apply hpf,\n  exact hp,\n\n  \n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 7, "name": "P_to_false_to_P_to_Q", "statement": "(P Q : Prop) : (P \u2192 false) \u2192 P \u2192 Q"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "223", "hidden": true}, {"type": "lemma", "text": "224", "lean": "lemma true_to_false_imp_P (P : Prop) : (true \u2192 false) \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-Lemma\nFor any logical statement $P$, $(\\mathrm{true} \\implies \\mathrm{false})$ implies $P$. \n-/\nlemma true_to_false_imp_P (P : Prop) : (true \u2192 false) \u2192 P :=\nbegin\n", "proof": " intro h,\n exfalso,\n apply h,\n triv,\n\n  \n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 7, "name": "true_to_false_imp_P", "statement": "(P : Prop) : (true \u2192 false) \u2192 P"}]}], "parents": [5]}, {"name": "225", "levels": [{"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "226", "hidden": true}, {"type": "text", "content": "227"}, {"type": "lemma", "text": "228", "lean": "lemma lemma_6 (P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T :=\n", "sideBar": true, "firstProofLineNumber": 13, "lastProofLineNumber": 20, "textBefore": "import tactic --hide\n\n/-\nIf you're sad that the game is over, here is some bonus content to keep you going.\n-/\n\n\n/-Lemma \nA long chain of implications.\n-/\nlemma lemma_6 (P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T :=\nbegin\n", "proof": "  intros hPR hSQ hRT hQR hS,\n  apply hRT,\n  apply hQR,\n  apply hSQ,\n  exact hS,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 8, "editorText": "sorry", "lineOffset": 12, "name": "lemma_6", "statement": "(P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "229", "hidden": true}, {"type": "lemma", "text": "230", "lean": "lemma lemma_7 (P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-Lemma\nA nested chain ofimplications.\n-/\nlemma lemma_7 (P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q :=\nbegin\n", "proof": "  intros hPQ hPQP,\n  apply hPQ,\n  apply hPQP,\n  exact hPQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 7, "name": "lemma_7", "statement": "(P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "231", "hidden": true}, {"type": "lemma", "text": "232", "lean": "lemma lemma_8 (P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 9, "lastProofLineNumber": 17, "textBefore": "import tactic --hide\n\n\n/-Lemma\nAn even more nested implications\n-/\nlemma lemma_8 (P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P :=\nbegin\n", "proof": "  intros h1 h2 h3,\n  apply h2,\n  intro hQ,\n  apply h1,\n  intro hP,\n  exact hQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 8, "name": "lemma_8", "statement": "(P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "233", "hidden": true}, {"type": "lemma", "text": "234", "lean": "lemma lemma_9 (P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 16, "textBefore": "import tactic --hide\n\n/-Lemma\nThis is getting silly now!\n-/\nlemma lemma_9 (P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P :=\nbegin\n", "proof": "  intros h1 h2 h3,\n  apply h1,\n  intro hQ,\n  apply h3,\n  apply h2,\n  exact hQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 7, "name": "lemma_9", "statement": "(P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "235", "hidden": true}, {"type": "lemma", "text": "236", "lean": "lemma lemma_10 (P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q) :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-Lemma\nAre we there yet?\n-/\nlemma lemma_10 (P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q) :=\nbegin\n", "proof": "  intros h1 hP,\n  apply h1,\n  intro hPQ,\n  exact hPQ hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 7, "name": "lemma_10", "statement": "(P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q)"}]}, {"name": "237", "problemIndex": 1, "objects": [{"type": "lean", "content": "238", "hidden": true}, {"type": "lemma", "text": "239", "lean": "lemma boss_lemma_1 (P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R :=\n", "sideBar": true, "firstProofLineNumber": 13, "lastProofLineNumber": 21, "textBefore": "import tactic --hide\n\n-- Level name : Boss fight \n\n/-Lemma\nTime for another boss fight!\n-/\nlemma boss_lemma_1 (P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R :=\nbegin\n", "proof": "  intros h1 h2 h3,\n  apply h2,\n  intros h1 hP h2,\n  apply h1,\n  intro hP,\n  exact h2,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 12, "name": "boss_lemma_1", "statement": "(P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R"}]}, {"name": "240", "problemIndex": 1, "objects": [{"type": "lean", "content": "241", "hidden": true}, {"type": "lemma", "text": "242", "lean": "lemma and_impl_equiv (P Q R : Prop) : (P  \u2192 Q) \u2227 (Q \u2192 R) \u2194 (P \u2192 R) \u2227 ((P \u2194 Q) \u2228 (R \u2194 Q)) :=\n", "sideBar": true, "firstProofLineNumber": 11, "lastProofLineNumber": 13, "textBefore": "import tactic --hide\n\n-- Level name : Super Boss\n\n\n/-Lemma\nTime for a super boss fight!\n-/\nlemma and_impl_equiv (P Q R : Prop) : (P  \u2192 Q) \u2227 (Q \u2192 R) \u2194 (P \u2192 R) \u2227 ((P \u2194 Q) \u2228 (R \u2194 Q)) :=\nbegin\n", "proof": "  tauto!,\n  \n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-Hint : Cheat code\nCongratulations! If you are reading this you are about to unlock a cheat code!\nLean has more advanced tactics that can solve all of the levels very quickly. For example,\nusing the `tauto!` tactic should allow you to solve the whole game! (but what's the fun in that?)\n-/\n\n/-\nThat's all folks! If you enjoyed this then check out the\n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\" target=\"blank\">Natural Numbers Game</a>\nand Kevin Buzzard's <a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2022/\" target=\"blank\">Formalising mathematics</a> course.\n\n-/", "height": 3, "editorText": "sorry", "lineOffset": 10, "name": "and_impl_equiv", "statement": "(P Q R : Prop) : (P  \u2192 Q) \u2227 (Q \u2192 R) \u2194 (P \u2192 R) \u2227 ((P \u2194 Q) \u2228 (R \u2194 Q))"}, {"type": "hint", "content": "243", "title": "244"}, {"type": "text", "content": "245"}]}], "parents": [6]}], "texts": [["De Morgan's game", "# Dungeons and De Morgan's: The logic Game\n\n## By Chris Birkbeck and Niki Kalaydzhieva\n\nGo on a Mathemagical quest to learn some logic!\n\n# What is this game?\n\nThis is a game to teach you some mathematical logic using Lean.\n\nHave fun!\n\n# Credits\n\nSome levels have been shamelessly borrowed from Kevin Buzzard's and Mohammad Pedramfar's \n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\" target=\"blank\">Natural Numbers Game</a>\nas well  as Kevin Buzzard's <a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2022/\" target=\"blank\">Formalising mathematics</a> \ncourse at Imperial College London. \n\n\n\n", "Tutorial", "import tactic --hide\n", "\n#Logical statements \n\nIn Logic, a *statement* is a sentence that is either true of false, for example: \n\n```md\n1. The sum of two odd numbers is an even number\n2. 36 is divisible by 3\n3. x > 2\n```\n\nOne of the goals of this game is to show you how to work with logical statements on a computer, \nspecifically using a computer language called Lean. In Lean, logical staments live in a \nplace called `Prop` (which is short for \"Propositions\"). For example, if we write  <mark style =\"background-color :   #ebdef0 \">`P : Prop`</mark> \nwe mean \"`P` is a logical statement.\"  Think of the \"`:`\" symbol as saying `P` lives in `Prop` \n(in Maths this would be denoted by `P \u2208 Prop`, to mean `P` is an element of `Prop`).\n\n#Truth Values\n\nThe *truth value* of a logical statement (i.e. some `P : Prop` is whether the statement is true or \nfalse. For example, the truth value of the statement: \"For all integers $x \u2208 \u2124$, $0 \u2264 x^2$\" \nis *true*, while \"For all integers $x \u2208 \u2124$, $0 \u2264 x^3$\" is *false*. \n\nIn Lean we assign truth values as follows: We first think of a proposition $P$ as a set with \n*at most* one element. If this set is empty, then we say `P` is *false*. Otherwise, if this set has \nan element, lets call it `p`, then this statement is *true* and `p` is the proof. We will usually \nuse upper case letters for logical statements, and lower case for their proofs.\n\nTo recap, we write `P : Prop` to mean `P` is a \nproposition and we write  <mark style =\"background-color : #ebdef0 \">`p : P`</mark>  to mean \"`p` is a \nproof of `P`\".\n\nThe aim of this game is to learn how to prove logical statements, which we call *lemmas* through a\nseries of manipulations which we call *tactics*. \n \nLets start with a simple example of how a lemma looks like in Lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, \non the right you will see the following state: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere, the first two lines are our assumptions, where the first line `P : Prop` says \"$P$ is a \nlogical statement\" and the second line `p : P` says `p` is the proof of `P`.\n\nThe thing after the `\u22a2` symbol is what we need to prove to win the level (i.e. prove the lemma).\n\nIn this game our \"moves\" or, as we call them in Lean, *tactics*, are what will allow us to \nmanipulate our statements and produce proofs.\n\nThe first tactic we will use is called *exact*. It is used when you need to prove a \nstatement $P$ and you have the proof of it. In the example above we have `p : P` and we need to\nprove `P`, then typing <mark style =\"background-color :   #ebdef0 \">`exact p,`</mark>  will prove it. \n\n**Note:  We end each line with a comma `,` to tell Lean that this is the end of our move.** \n\nTry it for yourself now and see what happens!\n\n", "If $P$ is a logical stament and $p$ is a proof of $P$ then $P$ is true.\n", "## Summary \nIf the goal is `\u22a2 P` then `exact p,` will close the goal if\nand only if `p` is a proof of `P` (i.e. `p : P`) \n## Details\nSay $P$, $Q$ and $R$ are logical staments\nand your lemma looks like this: \n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\nThen you can solve the level by using `exact j(h(p)),`\n", "import tactic --hide \n", "If $P,Q$ are logical statements with respective proofs $p,q$, then $Q$ is true.\n", "import tactic --hide \n", "\n#Combining logical statements\n\nWe can combine basic statements to create new ones. For example, we can write `\u00acP` for the \nstatement \"Not `P`\" and if we have two statements `P Q : Prop` \nwe can write `P \u2192 Q` to mean `P` implies `Q`. \n\nSay we have the following state of our lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nAs in level one, the first line says `P` and `Q` are logical statements and the third line says\nthat `P` has a proof `p`.\n\nIn the second line we have the implication `P \u2192 Q`, \nwhich we have called `h`. We think of `h`  as a one-way road from the statement `P` to the \nstatement `Q` in `Prop`. In Maths, we would call `h` a function or a map. \n\nFinally, our goal is to prove `Q` is true.\n\nUsing <mark style =\"background-color :  #ebdef0 \">`exact h(p),`</mark> will prove our lemma.\n\nWhy does this work? We know that `P` is true, since we have a proof of it `p` and `h` tells us that\nif `P` is true then `Q` is true. So combining `h` and `p` results in a proof of `Q`.\n\n**Note: We use `h(p)` rather than `h(P)`, because we want to transform the proof of `P` into \na proof of `Q`.**\n\n\n\n", "Let $P,Q$ be logical statements and $P$ implies $Q$. If $P$ is true, then so is $Q$.\n", "import tactic --hide\n", "Let $P,Q,R$ be logical statements with $P$ implies $Q$ and $Q$ implies $R$. If $P$ is true, then so \nis $R$. \n", "Logical statements", "apply tactic", "import tactic --hide\n", "universe u --hide\n", "\n## The `apply` tactic\n\nIf your lemma has the following state: \n\n```\nh : P \u2192 Q\n\u22a2 Q\n```\n\nHere, we assume that `P` implies `Q` and our goal is to prove `Q`. Then the tactic  <mark style =\"background-color : #ebdef0 \">`apply h,`</mark> \nwill change our goal to `P` and leave our assumptions unchanged, i.e. your new state will be\n\n```\nh : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n\nHere's an example we have already done, but try and do it using the `apply` tactic:\n\n", "Let $P,Q$ be logical statements. If $P$ implies $Q$ and $P$ is true, then $Q$ is true. \n", "\n## The `apply` tactic\n\nIf your lemma looks like\n\n```\nh : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic `apply h,` will change it to\n\n```\nh : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n\n\n", "intro", "import tactic --hide\n", "universe u --hide\n", "\n## The `intro` tactic.\n\nIf your goal is \n\n```\n\u22a2 P \u2192 Q\n```\n\nmeaning we need to prove the `P` implies `Q` then the tactic <mark style =\"background-color : #ebdef0 \">`intro hp,`</mark> \nwill take `P` as true with proof `hp` and add `hp : P` to the assumptions. In addition, \nit turn your goal into `\u22a2 Q`. \n\nIn other words the state of the lemma becomes:  \n\n```\nhp : P\n\u22a2 Q\n```\n\nLets look at an example that needs the `intro` tactic: \n\n\n", "Start with `intro p`.\n", "Hint", " `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hp hq` if your goal is `P \u2192 Q \u2192 R`.\n", "Tip", "If $P$ is a logical statement then $P\\implies P$.\n", "\n## The `intro` tactic.\n\nIf your goal is to prove the implication\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill add `hp : P` as an assumption (i.e. `hp` is the proof of `P`) and turn your goal into `\u22a2 Q`. \nIn other words we get: \n\n```\nhP : P\n\u22a2 Q\n```\n\nTip : `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 R`.\n\n", "import tactic -- hide\n", "Let $P,Q$ be logical statement and assume $Q$ is true, then $P$ implies $Q$. \n", "This works because the implication `P \u2192 Q` is true unless `Q` is false and `P` is true. In this case\nwe are given that `Q` is always true, so the implication holds regardless of the truth value of `P`. \n", "Why is this true?", "import tactic -- hide\n", "If $P,Q$ are logical statements, then $P$ implies $(Q \\implies P)$\n", "\nNote that implies `\u2192` is not associative: in general `P \u2192 (Q \u2192 R)` and `(P \u2192 Q) \u2192 R`\nmight not be equivalent. This is like subtraction on numbers -- in general\n`a - (b - c)` and `(a - b) - c` might not be equal.\nSo if we write `P \u2192 Q \u2192 R` then we'd better know what this means.\nThe convention in Lean is that it means `P \u2192 (Q \u2192 R)`. If you think\nabout it, this means that to deduce `R` you will need to prove both `P`\nand `Q`. \n", "Caution", "import tactic -- hide\n", "If we know `P`, and we also know `P \u2192 Q`, we can deduce `Q`. \nThis is called \"Modus Ponens\" by logicians.\n", "If $P$ is true and $P \\implies Q$ is true, then $Q$ is true.\n", "import tactic --hide\n", "The goal for this level is to show that implications are transitive. \nThat is, if `P \u2192 Q` and `Q \u2192 R` are true, then so is `P \u2192 R`.\n", "It might be useful to start by using `intros hPQ hQR hP`.\n", "Hint", "If $P,Q,R$ are logical statements and $P \\implies Q$ and $Q \\implies R$ then $P \\implies R$.\n", "Boss level", "import tactic --hide\n", " Notice we have three implications, so we need to introduce all of them using `intros`.\n\n", "Hint 1", "When using `apply` we need to make sure that we use an assumption that contains our goal.\n\n", "Hint 2", "If we have more than one goal to prove, then we need to do them in order. By default the lean \napplies the tactics to the first goal until complete and then moves on to the next.  \n\n", "Hint 3", "If $P,Q,R$ are logical statements and\n $(P \\implies Q \\implies R)$  then $((P \\implies Q) \\implies (P \\implies R)$.\n", "To skip proving a goal you can  write `sorry,`. But don't forget to go back and prove it to solve the\nlevel.  \n\n", "Tip", "True and False", "import tactic --hide \n", "##  True and False\n\n `Prop` has two special inhabitants, the logical statements <mark style =\"background-color : #ebdef0 \">`true`</mark>,\nwith truth value true and <mark style =\"background-color : #ebdef0 \">`false`</mark> with truth value\nfalse.\n\n\nIn the following levels we will work with logical statements combining `true` and `false`.\n\nTo help us we need to introduce a new tactic:\n\n## The `triv` tactic\n\nIf your lemma has the goal: \n\n```\n\u22a2 true\n```\n\nthen <mark style =\"background-color : #ebdef0 \">`triv`</mark> will complete the proof for you. Try it out below:\n\n", "The logical statement `true` is true.\n", "\nIf your lemma has the goal: \n\n```\n\u22a2 true\n```\nthen `triv` will complete the proof for you.\n\n", "import tactic --hide\n", "True implies true.\n", "import tactic --hide\n", "False implies true.\n", "import tactic --hide\n", "False implies false.\n", "import tactic --hide\n", "$(\\mathrm{true} \\implies \\mathrm{false}) \\implies \\mathrm{false}$.\n", "And & Or", "import tactic --hide\n", "## The `split` tactic\n\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2227 Q\n```\n\nthen the  <mark style =\"background-color : #ebdef0 \">`split`</mark>  tactic will turn it\ninto *two* goals `\u22a2 P` and `\u22a2 Q`.\n\n", "It is best practice to indicate when you are working with two goals, either by using squiggly \nbrackets like this:\n\n```\n...\nsplit,\n{ working on P,\n  end of proof of P },\n{ working on Q,\n  end of proof of Q },\n```\n\nor by using indentation like this:\n\n```\nsplit,\n  working on P,\n  end of proof of P,\nworking on Q,\n...\n```\n", "Tip", "Let $P,Q$ be logical statements and assume that they are both true, then $P \u2227 Q$ is \ntrue.\n", "import tactic --hide\n", "`split` can also be used for if and only if statements. For example, if you have `\u22a2 P \u2194 Q` and apply\n`split`, then your goal will change from \n\n```\n\u22a2 P \u2194 Q\n```\nto two goals, `\u22a2 P \u2192 Q` and `\u22a2 Q \u2192 P`.\n", "Let $P$ be a logical statement, then $P$ is true if and only if $P$ is true.\n", "\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2227 Q\n```\n\nthen the  `split` tactic will turn it into *two* goals `\u22a2 P` and `\u22a2 Q`.\n\nMoreover, if you have an iff `P \u2194 Q` then splitting it will give you two goals, `P \u2192 Q` \n(i.e \"`P` only if `Q`\") and `P \u2190 Q ` (i.e \"`P` if `Q`\") to prove.\n\n", "import tactic --hide\n", "## `left` and `right`\n\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2228 Q\n```\n\nthen   <mark style =\"background-color : #ebdef0 \">`left`</mark>  changes the goal to `\u22a2 P`. \nSimilarly,  <mark style =\"background-color : #ebdef0 \">`right`</mark>  changes the goal to `\u22a2 Q`.\n", "The logic is that `P` implies `P \u2228 Q` so it is enough to prove `P`. \n\n", "Why does this work?", "Let $P,Q$ be logical statements and assume $P$ is true, then $P \u2228 Q$ is true.\n", "\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2228 Q\n```\n\nthen `left` changes the goal to `\u22a2 P`. Similarly `right` changes the goal to `\u22a2 Q`.\n\n", "import tactic --hide\n", "## The `cases` tactic\n\n`cases` is a very general-purpose tactic for \"deconstructing\" hypotheses.\nIf `h` is an assumption which somehow \"bundles up\" two pieces of information,\nthen  <mark style =\"background-color : #ebdef0 \">`cases h with h1 h2`</mark>  will make the \nassumption `h` vanish and will replace it with the two \"components\" which made the proof of `h` in the first place.\nAn example of this occurring is if you have the assumption `h : P \u2227 Q` which contains a \nproof of `P` and a proof of `Q`.\n\n\n\nFor example, if you have an assumption\n\n```\nh : P \u2227 Q\n```\n\nthen\n\n`cases h with hP hQ,`\n\nwill delete `h` and replace it with\n\n```\nhP : P\nhQ : Q\n```\nTry it out below.\n\n", "If $P,Q$ are logical statements and $P \u2227 Q$ is true then so is $P$.\n", "\nIf you have a hypothesis\n\n```\nh : P \u2227 Q\n```\n\nthen\n\n`cases h with hP hQ,`\n\nwill delete `h` and replace it with\n\n```\nhP : P\nhQ : Q\n```\n\nYou can also use it for \"or's\". Specifically, if you have `h : P \u2228 Q` then `cases h` will\ngive you two goals, one where `P` is true and one where `Q` is true.\n\n", "import tactic --hide\n", "You can also use `cases` when working with the `\u2228` (\"or\") connective. For example, if you have\nthe assumption\n\n```\nh : P \u2228 Q\n``` \n\nthen `cases h with hp hq` will convert your state into the following two states:\n\n```\nP : Prop\nhp : P\n\u22a2 P\n```\nand\n\n```\nP : Prop\nhq : Q\n\u22a2 Q\n```\none where `P` is true and one where `Q` is true.\n\nTry this in the lemma below.\n", "If $P$ is a logical statement and $P$ or $P$ is true, then $P$ is true.\n", "import tactic --hide\n", "This level proves that `\u2227` is a commutative operator. \n", "Let $P,Q$ be logical statements, then $P \u2227 Q$ is true iff $Q \u2227 P$ is true.\n", "import tactic --hide\n", "If $P,Q,R$ are logical statements then $P \u2227 Q$ implies that \n$(P \\implies R) \\implies (Q \\implies R) \\implies R$ \n", "import tactic --hide\n", "This level will show that `\u2227` is *transitive*.\n", "If $P,Q,R$ are logical statements, then $P \u2227 Q$ and $Q \u2227 R$ imples $P \u2227 R$.\n", "Logic laws", "absorption laws pt 1", "import tactic --hide\n", "This level proves the first *absorption* law.\n", "If $P,Q$ are logical statements then $P \u2227 (P \u2228 Q)$ is true if and only if $P$ is true.\n", "absorpsion laws pt 2", "import tactic --hide\n", "This level proves the second absorption law.\n", "If $P,Q$ are logical statements then $P \u2228 (P \u2227 Q)$ is true if and only if $P$ is true.\n", "Associative laws pt 1", "import tactic --hide\n", "This level proves that `\u2227` is *associative*.\n", "If $P,Q,R$ are logical statements, then $P \u2227 (Q \u2227 R)$ is true iff $(P \u2227 Q) \u2227 R$ is true.\n", "Associative laws pt 2", "import tactic --hide\n", "This level proves that `\u2228` is associative.\n", "If $P,Q,R$ are logical statements then $P \u2228 (Q \u2228 R)$ is true iff $(P \u2228 Q) \u2228 R$ is true.\n", "Distributive laws 1", "import tactic --hide\n", "This level proves the *distributivity* of `\u2227` over `\u2228`.\n", "If $P,Q,R$ are logical statements then $P \u2227 (Q \u2228 R)$ is true iff $(P \u2227 Q) \u2228 (P \u2227 R)$ is true.\n", "Distributive laws 2", "import tactic --hide\n", "This level proves the distributivity of `\u2228` over `\u2227`.\n", "If $P,Q,R$ are logical statements then $P \u2228 (Q \u2227 R)$ is true iff $(P \u2228 Q) \u2227 (P \u2228 R)$ is true.\n", "Not logic", "\u00ac P \u2194 P \u2192 false\n", "\n\nBy definition `\u00acQ` is equivalent to `Q \u2192 false`. Lets call this result\n\n`not_iff_imp_false (P : Prop) : \u00ac P \u2194 (P \u2192 false)`\n\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false :=iff.rfl-- hide\n", "\nYou can convince yourself this is true by writting out the truth table for `\u00ac P` and `P \u2192 false`.\n\n\nIn order to use it, lets look at a new tactic.\n\n## The `rw` tactic\n\nThe <mark style =\"background-color : #ebdef0 \">`rw`</mark> tactic (short for <mark style =\"background-color : #ebdef0 \">`rewrite`</mark>) \nis a tactic that allows you to do a substitution. For example, if we have the\nassumption `h : P \u2194 Q`, then `rw h` will replace the (first) `P` in the goal with `Q`. If instead you would like to \nturn the first `Q` in your goal to `P` then use `rw \u2190h`. (To get the `\u2190` arrow, type `\\l`).\n\nCombining `rw` and `not_iff_imp_false`, try to prove the following:\n\n", " Start by using `rw not_iff_imp_false,` and see what changes.\n", "Hint", "If $P$ and $Q$ are propositions, and $P\\implies Q$, then\n$\\lnot Q\\implies \\lnot P$. \n", "If you want to use the `rw` tactic on one of your assumptions then this can be done.\n\nFor example, if we have `h1 : P \u2194 Q` and `h2` is the assumption we want to change, then\n `rw h1 at h2` will substitute the first `P` in `h2` to `Q`. \n\n", "Tip", "\nThe `rw` tactic is a tactic that allows you to substitute in things. For example, if we have the\nassumption `h: P \u2194 Q`, then `rw h` will replace the `P`'s in the goal with `Q`'s. If instead you would like to \nturn all of the `Q`'s in your goal to `P`'s then using `rw \u2190h` will do this. (To get the `\u2190` arrow, type `\\l`).\n\nMoreover, if we have `h1 : P \u2194 Q` and `h2` is the assumption we want to change, then\n `rw h1 at h2` will substitute the first `P` in `h2` to `Q`. \n\n", "The `exfalso` tactic.", "import tactic --hide\n", "In this level we want to prove prove that `false` implies any proposition `P`.\n\n", "You can do this using only `intro` and `cases`.\n", "Hint", "If $P$ is a logical statement then $\\mathrm{false}$ implies $P$.\n", "One way to solve this level is to use `intro h` followed by `cases h`.  Notice that using `intro h`,\nintroduces the assumption `h : false`. Lean thinks of `false` as empty, i.e having no elements. \n`cases h` goes through each element in `h` and tries to prove our goal. \nBut since our assumption is `false` there are no cases, so the result is trivially true. \nTo make sense of this outside of Lean, we think that starting from a false statement we can have \nany outcome, both true and false (see levels 3 & 4 of \"True and False\" world).\n\n", "What is going on here?", "## The `exfalso` tactic \n\nA way to use this result in Lean is with the <mark style =\"background-color : #ebdef0 \"> `exfalso`</mark> tactic, \nwhich changes any goal to `false`. \n", "This changes any goal to `false`.\n", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "In this level we will prove that `P \u2227 \u00ac P` is always false. This is an example of a *contradiction*.\n\n", "If $P$ is a logical statement, then $P \u2227 \u00acP$ is false.\n", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "##  Proof by contradiction. \n\nIn this level we will see why proofs by contradiction are valid. The key is to note that for any\nlogical statements `P,Q`, we have that ` P \u2227 (\u00ac P) \u2192 Q` is true.\n\n", "We have just seen that `P \u2227 (\u00ac P)`is always false and `false \u2192 Q` is always true.\n", "Why is this true?", "Start by introducing your assumption and then using `exfalso`.\n", "Hint", "If $P$ and $Q$ are logical statements, then\n$(P\\land(\\lnot P))\\implies Q.$\n", "If you want to use to use this result later on then you can type <mark style =\"background-color : #ebdef0 \">`apply (contra P Q)`</mark> where `P,Q` are\nthe assumptions you want to use. You can also use the tactic <mark style =\"background-color : #ebdef0 \">`by_contra`</mark>  \nto achieve similar results. \n\n", "Tip", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "lemma P_not_P_false (P : Prop) : P \u2227 \u00ac P \u2192 false := by {cc} --hide\n", "We proved earlier that `(P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)`. The converse,\nthat `(\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q)` is certainly true, but trying to prove\nit using the tactics we've learnt so far is impossible. \n", " \nSuppose we tried to prove this with the tactics we have seen so far, then our proof might look \nsomething like:\n```\nintro h,\nintro p,\nrw not_iff_imp_false at h,\nrw not_iff_imp_false at h,\n```\nYou are then left with the following state:\n```\nP Q : Prop,\nh : (Q \u2192 false) \u2192 P \u2192 false\np : P\n\u22a2 Q\n```\nand now we are stuck. In fact, using tactics such as `intro` and `apply` you will never be able to \nprove this lemma as this is not provable in \"constructive logic\". The key in proving this is to use \nLean's version of a truth table!\n\n", "Why is this impossible?", "In order to continue we need a new tactic.\n\n## The `by_cases` tactic\n\nThe tactic <mark style =\"background-color : #ebdef0 \">`by_cases`</mark> allows us to create Lean's \nversion of a truth table.\n\nFor example, if you have `P Q : Prop`, then <mark style =\"background-color : #ebdef0 \">`by_cases hp : P; by_cases hq : Q,`</mark>\nwill create four goals, one for each of the four  possibilities for `P,Q`, i.e., \n\n```md\n| `P`     | `Q`     |\n| --------|---------|\n| `true`  | `true`  | \n| `true`  | `false` |   \n| `false` | `true`  |   \n| `false` | `false` |   \n```\n\n**Note the semicolon**! It means \"do the next tactic to all the goals, not just the first\".\n\n", "If $P$ and $Q$ are logical statements, then\n$(\\lnot Q\\implies \\lnot P)\\implies(P\\implies Q).$\n", "The `by_cases` tactic works by adding the assumption `P \u2228 \u00ac P` and then doing `cases` on this.\nThe fact that `P \u2228 \u00ac P` is true is called the *law of the excluded middle*, and it cannot be proven \nby just using tactics such as `intro` and `apply`.\n", "+1 Intelligence", " \nThe ``by_cases`` tactic is a simple truth table tactic: ``by_cases P`` turns one goal into two goals, \nwith ``P`` is assumed in the first, and ``\u00acP`` in the second.\n\nExamples\n--------\n\n1) If ``P`` is a proposition, then ``by_cases P`` turns your goal into two goals, \nand in each of your new tactic states you have one extra hypothesis. \nIn the first one you have a new hypothesis ``h : P`` and in the second you have a new hypothesis ``h : \u00acP``.\n\n2) If you already have a hypothesis ``h`` then this can get a bit confusing, \nso you can also do ``by_cases hP : P``; then your new hypotheses will be ``hP : P`` and ``hP : \u00acP``.\n", "import tactic --hide\n", "If $P$ is a logical statement then $P \\implies \u00acP$ implies $\\mathrm{false}$.\n", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "Try using `rw not_iff_imp_false,`.\n", "Hint", "If $P$ is a logical statement then $P \\implies \u00ac \u00acP$.\n", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "If $P$ is a logical statement then $\u00ac(\u00acP) \\implies P$.\n", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "If $P, Q$ are logical statements then $(P \\implies Q)$ is equivalent to $(\u00acP) \u2228 Q$.\n", "De Morgan's laws", "De Morgan's laws, First Boss", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "lemma P_not_P_false (P : Prop) : P \u2227 \u00ac P \u2192 false := by {cc} --hide\n", "It is time to tackle our final bosses, the *De Morgans laws*. Use your tactics wisely!\n\n", "\nYou can do this only using `split`, `intro`, `apply`, `left`, `right`.\n\n", "First Aid", "\nIf you have a goal `\u00acP` then `intro h` will turn your goal into `false` and give you\nan extra assumption `h : P`.\n\n", "Second Aid", "\nIf you have a goal `false` and an assumption `h : \u00acP`, then `apply h` will turn your goal \ninto `P`.\n\n", "Third Aid", "If $P,Q$ are logical statements  $\u00ac(P \u2228 Q)$ is equivalent to $\u00ac P \u2227 \u00acQ$.\n", "De Morgan's laws, Final Boss", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "lemma P_not_P_false (P : Prop) : P \u2227 \u00ac P \u2192 false := by {cc} --hide\n", "For this final battle with De Morgan, you are on your own!\n", "If $P,Q$ are logical statements then $\u00ac(P \u2227 Q)$ is equivalent to $\u00ac P \u2228 \u00acQ$.\n", "More true and false", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "$\u00ac \\mathrm{false}$ implies $\\mathrm{true}$.\n", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "$\u00ac \\mathrm{true}$ implies $\\mathrm{false}$.\n", "import tactic --hide\n", "If $P$ is a logical statement then $P$ implies $(P \\implies \\mathrm{false}) \\implies \\mathrm{false}$\n", "import tactic --hide\n", "If $P, Q$ are logical statements then $P \\implies \\mathrm{false}$ implies $P \\implies Q$. \n", "import tactic --hide\n", "For any logical statement $P$, $(\\mathrm{true} \\implies \\mathrm{false})$ implies $P$. \n", "Bonus content", "import tactic --hide\n", "If you're sad that the game is over, here is some bonus content to keep you going.\n", "A long chain of implications.\n", "import tactic --hide\n", "A nested chain ofimplications.\n", "import tactic --hide\n", "An even more nested implications\n", "import tactic --hide\n", "This is getting silly now!\n", "import tactic --hide\n", "Are we there yet?\n", "Boss fight", "import tactic --hide\n", "Time for another boss fight!\n", "Super Boss", "import tactic --hide\n", "Time for a super boss fight!\n", "Congratulations! If you are reading this you are about to unlock a cheat code!\nLean has more advanced tactics that can solve all of the levels very quickly. For example,\nusing the `tauto!` tactic should allow you to solve the whole game! (but what's the fun in that?)\n", "Cheat code", "That's all folks! If you enjoyed this then check out the\n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\" target=\"blank\">Natural Numbers Game</a>\nand Kevin Buzzard's <a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2022/\" target=\"blank\">Formalising mathematics</a> course.\n\n"]]}