{"name": "Niki's Logic", "version": "1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Niki's Logic-1.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "lemma", "text": "5", "lean": "lemma example1 (P : Prop) (p : P) : P :=\n", "sideBar": true, "firstProofLineNumber": 66, "lastProofLineNumber": 66, "textBefore": "import tactic --hide\n\n/-\n\n#Logical statements \n\nYou've seen logical statements already, these are statements that can be true or false, for example: \n\n-The sum of two odd numbers is an even number\n\n-$36$ is divisible by $3$\n\n-$x > 2$\n\n\nLets see how one does this a computer, specifically in lean. In lean, logical staments live in a world called `Prop`. So for example \nif we write `P : Prop` we mean \"$P$ is a logical statement.\" Think of the `:` symbol as saying $P$ is a resident of `Prop` world \n(in maths this would be denoted by something like `P \u2208 Prop`).\n\n#Truth Values\n\nThe truth value of a logical statement (i.e. some `P : Prop`) is whether the statement is true or false. For example, the truth value of the\nstatement \"For all integers x \u2208 \u2124,  0 \u2264 x\u00b2\" is *true* while  \"For all integers x \u2208 \u2124,  0 \u2264 x\u00b3\" is *false*. \n\nIn lean we assign truth values as follows: We first think of a proposition $P$ as a set with *at most* one element. If this set is empty, then\nwe say `P` is *false*. Otherwise, if this set has an element, lets call it $p$ (we will usually use upper case letters\nfor logical statements, and lower case for their proofs), then this statement is *true* and $p$ is the \nproof. \n\nSo to recap, if $P$ is the true/false statement (the statement of proposition), and $p$ is its proof.\nThe we It's like thinking $P$ being the set and $p$ being the element. In fact computer scientists\nsometimes think about the following analogy: propositions are like sets,\nand their proofs are like their elements. Just as above, where we had `P : Prop` to mean $P$ is a proposition, we write `p : P` to mean\n\"$p$ is a proof of $P$\".\n\nThe aim of this game is to learn how to manipulate logical statements and their proofs. Lets start with a super basic example of how a lemma \nlooks like in lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, on the right you will see the following: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere the first two lines are our assumptions and the thing after the `\u22a2` symbol is what we are being asked to prove. \n\nNow, in this game our \"moves\" or, as we call them in lean, *Tactics*, are what will allow us to manipulate our statement and produce proofs.\n\nThe first tactic we will look at is called *exact* and what it does is, if you need to prove a statement $P$ and you have proof of it,\nsay, `p: P`, then `exact p` will prove it. \n\nNote that at the end of each line we write we need to have a comma `,` to tell lean that this is the end of our move. \n\nSo if below you change the `sorry` for `exact p` you'll see that on the right it will change to say `Proof complete`. \n\n-/\n\n\n/- Lemma\nLets try and prove that if $P$ is a logical stament (i.e. `P : Prop`) and $p$ is a proof of $P$ (i.e. `p : P`) then $P$ is true.\n-/\nlemma example1 (P : Prop) (p : P) : P :=\nbegin\n", "proof": "  exact p,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nNow try the following one:\n\n-/\n\nlemma example2 (P Q : Prop) (p : P) (q : Q) : Q :=\nbegin\n  exact q,\nend\n\n/-\n\n\n\n#Combining logical statements\n\nNow, we can take these statements and create new ones. For example if we have two statements `P Q : Prop` we can write\n` P \u2192 Q` to mean $P$ implies $Q$. Similarly, we can write `\u00acP` for the statement \"Not $P$\". \n\nSay we have the following lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nThis asks us to prove: If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ (i.e. we have `p : P`). Then $Q$ is\ntrue (i.e. we have a proof of `Q`). \n\nHere we have given the name $h$ to the implication ` P \u2192 Q`. We think of $h$ as a map between statements in `Prop` world. \n\nNow this lemma is asking us to take a proof of $P$ and turn it into a proof of $Q$. Since we know that $P$ implies $Q$ then we know that if\n$P$ is true then so is $Q$. So we can use our map in `Prop` world to transform our proof of $P$ into a proof of $Q$. \n\nIf we write `exact h(p)` below we get what we want.\n\nNote that it has to be lower case $p$, since $P$ is the logical statement, but what we want to transform is the proof.\n\n\n\n-/\n\n/- Lemma\nIf $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ (i.e. we have `p : P`). Then $Q$ is\ntrue (i.e. we have a proof of `Q`)\n-/\nlemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\nbegin\n  exact h(p),\nend\n\n/-\nNow try the following one: \n\n-/\n\nlemma implications_two (P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R :=\nbegin\n  exact h2 (h1 (p)),\nend", "height": 1, "editorText": "sorry", "lineOffset": 65, "name": "example1", "statement": "(P : Prop) (p : P) : P"}, {"type": "text", "content": "6"}, {"type": "lean", "content": "7", "hidden": false}, {"type": "text", "content": "8"}, {"type": "lemma", "text": "10", "lean": "lemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\n", "sideBar": true, "firstProofLineNumber": 118, "lastProofLineNumber": 118, "textBefore": "import tactic --hide\n\n/-\n\n#Logical statements \n\nYou've seen logical statements already, these are statements that can be true or false, for example: \n\n-The sum of two odd numbers is an even number\n\n-$36$ is divisible by $3$\n\n-$x > 2$\n\n\nLets see how one does this a computer, specifically in lean. In lean, logical staments live in a world called `Prop`. So for example \nif we write `P : Prop` we mean \"$P$ is a logical statement.\" Think of the `:` symbol as saying $P$ is a resident of `Prop` world \n(in maths this would be denoted by something like `P \u2208 Prop`).\n\n#Truth Values\n\nThe truth value of a logical statement (i.e. some `P : Prop`) is whether the statement is true or false. For example, the truth value of the\nstatement \"For all integers x \u2208 \u2124,  0 \u2264 x\u00b2\" is *true* while  \"For all integers x \u2208 \u2124,  0 \u2264 x\u00b3\" is *false*. \n\nIn lean we assign truth values as follows: We first think of a proposition $P$ as a set with *at most* one element. If this set is empty, then\nwe say `P` is *false*. Otherwise, if this set has an element, lets call it $p$ (we will usually use upper case letters\nfor logical statements, and lower case for their proofs), then this statement is *true* and $p$ is the \nproof. \n\nSo to recap, if $P$ is the true/false statement (the statement of proposition), and $p$ is its proof.\nThe we It's like thinking $P$ being the set and $p$ being the element. In fact computer scientists\nsometimes think about the following analogy: propositions are like sets,\nand their proofs are like their elements. Just as above, where we had `P : Prop` to mean $P$ is a proposition, we write `p : P` to mean\n\"$p$ is a proof of $P$\".\n\nThe aim of this game is to learn how to manipulate logical statements and their proofs. Lets start with a super basic example of how a lemma \nlooks like in lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, on the right you will see the following: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere the first two lines are our assumptions and the thing after the `\u22a2` symbol is what we are being asked to prove. \n\nNow, in this game our \"moves\" or, as we call them in lean, *Tactics*, are what will allow us to manipulate our statement and produce proofs.\n\nThe first tactic we will look at is called *exact* and what it does is, if you need to prove a statement $P$ and you have proof of it,\nsay, `p: P`, then `exact p` will prove it. \n\nNote that at the end of each line we write we need to have a comma `,` to tell lean that this is the end of our move. \n\nSo if below you change the `sorry` for `exact p` you'll see that on the right it will change to say `Proof complete`. \n\n-/\n\n\n/- Lemma\nLets try and prove that if $P$ is a logical stament (i.e. `P : Prop`) and $p$ is a proof of $P$ (i.e. `p : P`) then $P$ is true.\n-/\nlemma example1 (P : Prop) (p : P) : P :=\nbegin\n  exact p,\nend\n\n/-\nNow try the following one:\n\n-/\n\nlemma example2 (P Q : Prop) (p : P) (q : Q) : Q :=\nbegin\n  exact q,\nend\n\n/-\n\n\n\n#Combining logical statements\n\nNow, we can take these statements and create new ones. For example if we have two statements `P Q : Prop` we can write\n` P \u2192 Q` to mean $P$ implies $Q$. Similarly, we can write `\u00acP` for the statement \"Not $P$\". \n\nSay we have the following lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nThis asks us to prove: If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ (i.e. we have `p : P`). Then $Q$ is\ntrue (i.e. we have a proof of `Q`). \n\nHere we have given the name $h$ to the implication ` P \u2192 Q`. We think of $h$ as a map between statements in `Prop` world. \n\nNow this lemma is asking us to take a proof of $P$ and turn it into a proof of $Q$. Since we know that $P$ implies $Q$ then we know that if\n$P$ is true then so is $Q$. So we can use our map in `Prop` world to transform our proof of $P$ into a proof of $Q$. \n\nIf we write `exact h(p)` below we get what we want.\n\nNote that it has to be lower case $p$, since $P$ is the logical statement, but what we want to transform is the proof.\n\n\n\n-/\n\n/- Lemma\nIf $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ (i.e. we have `p : P`). Then $Q$ is\ntrue (i.e. we have a proof of `Q`)\n-/\nlemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\nbegin\n", "proof": "  exact h(p),", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nNow try the following one: \n\n-/\n\nlemma implications_two (P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R :=\nbegin\n  exact h2 (h1 (p)),\nend", "height": 1, "editorText": "9", "lineOffset": 117, "name": "implications_one", "statement": "(P Q : Prop) (h : P \u2192 Q) (p : P) : Q"}, {"type": "text", "content": "11"}, {"type": "lean", "content": "12", "hidden": false}]}]}, {"name": "13", "levels": [{"name": "14", "problemIndex": 3, "objects": [{"type": "lean", "content": "15", "hidden": true}, {"type": "lean", "content": "16", "hidden": true}, {"type": "text", "content": "17"}, {"type": "lemma", "text": "18", "lean": "lemma implies_self (P : Prop) : P \u2192 P :=\n", "sideBar": false, "firstProofLineNumber": 38, "lastProofLineNumber": 41, "textBefore": "import tactic --hide\n\nuniverse u --hide\n\n-- Level name : Propositions\n\n/-\n\n\n\nIf your goal is to prove `P \u2192 Q` (i.e. that $P\\implies Q$)\nthen `intro p`, meaning \"assume $p$ is a proof of $P$\", will make progress.\nTo solve the goal below, you have to come up with a function from\n`P` (thought of as the set of proofs of $P$!) to itself. Start with\n`intro p,`\n(i.e. \"let $p$ be a proof of $P$\") and note that our\nlocal context now looks like this:\n```\nP : Prop,\np : P\n\u22a2 P\n```\nOur job now is to construct a proof of $P$. But $p$ is a proof of $P$.\nSo\n`exact p,`\nwill close the goal. Note that `exact P` will not work -- don't\nconfuse a true/false statement (which could be false!) with a proof.\nWe will stick with the convention of capital letters for propositions\nand small letters for proofs.\n-/ \n\n\n/- Lemma : no-side-bar\nIf $P$ is a proposition then $P\\implies P$.\n-/\nlemma implies_self (P : Prop) : P \u2192 P :=\nbegin\n", "proof": "  intro p,\n  exact p,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 37, "name": "implies_self", "statement": "(P : Prop) : P \u2192 P"}]}, {"name": "19", "problemIndex": 3, "objects": [{"type": "lean", "content": "20", "hidden": true}, {"type": "lean", "content": "21", "hidden": true}, {"type": "text", "content": "22"}, {"type": "lemma", "text": "23", "lean": "lemma l2 (P Q : Prop) : P \u2227 Q \u2192 Q \u2227 P :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 24, "textBefore": "import tactic --hide\n\nuniverse u --hide\n\n-- Level name : More propositions\n\n/-\nLets look at some other logical statements\n\n\n\n-/\n\n\n/- Lemma\nLets try and prove that if `P` implies `Q` (which is written ` P \u2192 Q`) and we have a proof of `P` (i.e. we have `p : P`). Then `Q` is\ntrue (i.e. we have a proof of `Q`)\n-/\n\nlemma l2 (P Q : Prop) : P \u2227 Q \u2192 Q \u2227 P :=\nbegin\n", "proof": "  intro h ,\n  rw and_comm,\n  exact h,", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 21, "name": "l2", "statement": "(P Q : Prop) : P \u2227 Q \u2192 Q \u2227 P"}]}], "parents": [0]}], "texts": [["Niki's Logic", "# Captain de Morgan's logic Game\n\n## By UCL\n\nLearn some logic yo\n\n# What is this game?\n\nThis is a game to teach you some mathematical logic using Lean.\n\nHave fun!\n\n# Credits\n\nSome levels have been shamelessly borrowed from Kevin Buzzard's and Mohammad Pedramfar's \"Natural Numbers Game\" as well as \nKevin Buzzard's \"Formalizing mathematics\" course at Imperial College. \n\n\n", "Tutorial", "import tactic --hide\n", "\n#Logical statements \n\nYou've seen logical statements already, these are statements that can be true or false, for example: \n\n-The sum of two odd numbers is an even number\n\n-$36$ is divisible by $3$\n\n-$x > 2$\n\n\nLets see how one does this a computer, specifically in lean. In lean, logical staments live in a world called `Prop`. So for example \nif we write `P : Prop` we mean \"$P$ is a logical statement.\" Think of the `:` symbol as saying $P$ is a resident of `Prop` world \n(in maths this would be denoted by something like `P \u2208 Prop`).\n\n#Truth Values\n\nThe truth value of a logical statement (i.e. some `P : Prop`) is whether the statement is true or false. For example, the truth value of the\nstatement \"For all integers x \u2208 \u2124,  0 \u2264 x\u00b2\" is *true* while  \"For all integers x \u2208 \u2124,  0 \u2264 x\u00b3\" is *false*. \n\nIn lean we assign truth values as follows: We first think of a proposition $P$ as a set with *at most* one element. If this set is empty, then\nwe say `P` is *false*. Otherwise, if this set has an element, lets call it $p$ (we will usually use upper case letters\nfor logical statements, and lower case for their proofs), then this statement is *true* and $p$ is the \nproof. \n\nSo to recap, if $P$ is the true/false statement (the statement of proposition), and $p$ is its proof.\nThe we It's like thinking $P$ being the set and $p$ being the element. In fact computer scientists\nsometimes think about the following analogy: propositions are like sets,\nand their proofs are like their elements. Just as above, where we had `P : Prop` to mean $P$ is a proposition, we write `p : P` to mean\n\"$p$ is a proof of $P$\".\n\nThe aim of this game is to learn how to manipulate logical statements and their proofs. Lets start with a super basic example of how a lemma \nlooks like in lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, on the right you will see the following: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere the first two lines are our assumptions and the thing after the `\u22a2` symbol is what we are being asked to prove. \n\nNow, in this game our \"moves\" or, as we call them in lean, *Tactics*, are what will allow us to manipulate our statement and produce proofs.\n\nThe first tactic we will look at is called *exact* and what it does is, if you need to prove a statement $P$ and you have proof of it,\nsay, `p: P`, then `exact p` will prove it. \n\nNote that at the end of each line we write we need to have a comma `,` to tell lean that this is the end of our move. \n\nSo if below you change the `sorry` for `exact p` you'll see that on the right it will change to say `Proof complete`. \n\n", "Lets try and prove that if $P$ is a logical stament (i.e. `P : Prop`) and $p$ is a proof of $P$ (i.e. `p : P`) then $P$ is true.\n", "Now try the following one:\n\n", "lemma example2 (P Q : Prop) (p : P) (q : Q) : Q :=\nbegin\n  exact q,\nend\n", "\n\n\n#Combining logical statements\n\nNow, we can take these statements and create new ones. For example if we have two statements `P Q : Prop` we can write\n` P \u2192 Q` to mean $P$ implies $Q$. Similarly, we can write `\u00acP` for the statement \"Not $P$\". \n\nSay we have the following lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nThis asks us to prove: If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ (i.e. we have `p : P`). Then $Q$ is\ntrue (i.e. we have a proof of `Q`). \n\nHere we have given the name $h$ to the implication ` P \u2192 Q`. We think of $h$ as a map between statements in `Prop` world. \n\nNow this lemma is asking us to take a proof of $P$ and turn it into a proof of $Q$. Since we know that $P$ implies $Q$ then we know that if\n$P$ is true then so is $Q$. So we can use our map in `Prop` world to transform our proof of $P$ into a proof of $Q$. \n\nIf we write `exact h(p)` below we get what we want.\n\nNote that it has to be lower case $p$, since $P$ is the logical statement, but what we want to transform is the proof.\n\n\n\n", "  exact h(p),", "If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ (i.e. we have `p : P`). Then $Q$ is\ntrue (i.e. we have a proof of `Q`)\n", "Now try the following one: \n\n", "lemma implications_two (P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R :=\nbegin\n  exact h2 (h1 (p)),\nend", "Logical statements", "Propositions", "import tactic --hide\n", "universe u --hide\n", "\n\n\nIf your goal is to prove `P \u2192 Q` (i.e. that $P\\implies Q$)\nthen `intro p`, meaning \"assume $p$ is a proof of $P$\", will make progress.\nTo solve the goal below, you have to come up with a function from\n`P` (thought of as the set of proofs of $P$!) to itself. Start with\n`intro p,`\n(i.e. \"let $p$ be a proof of $P$\") and note that our\nlocal context now looks like this:\n```\nP : Prop,\np : P\n\u22a2 P\n```\nOur job now is to construct a proof of $P$. But $p$ is a proof of $P$.\nSo\n`exact p,`\nwill close the goal. Note that `exact P` will not work -- don't\nconfuse a true/false statement (which could be false!) with a proof.\nWe will stick with the convention of capital letters for propositions\nand small letters for proofs.\n", "If $P$ is a proposition then $P\\implies P$.\n", "More propositions", "import tactic --hide\n", "universe u --hide\n", "Lets look at some other logical statements\n\n\n\n", "Lets try and prove that if `P` implies `Q` (which is written ` P \u2192 Q`) and we have a proof of `P` (i.e. we have `p : P`). Then `Q` is\ntrue (i.e. we have a proof of `Q`)\n"]]}