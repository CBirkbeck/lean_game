{"name": "Niki's Logic", "version": "1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Niki's Logic-1.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "lemma", "text": "5", "lean": "lemma example1 (P : Prop) (p : P) : P :=\n", "sideBar": true, "firstProofLineNumber": 72, "lastProofLineNumber": 74, "textBefore": "import tactic --hide\n\n/-\n\n#Logical statements \n\nYou've seen logical statements already, these are statements that can be true or false, for example: \n\n-The sum of two odd numbers is an even number\n\n-$36$ is divisible by $3$\n\n-$x > 2$\n\n\nLets see how one does this a computer, specifically in lean. In lean, logical staments live in a \nworld called `Prop`. So for example if we write `P : Prop` we mean \"$P$ is a logical statement.\" \nThink of the `:` symbol as saying $P$  is a resident of `Prop` world (in maths this would be denoted\nby something like `P \u2208 Prop`).\n\n#Truth Values\n\nThe truth value of a logical statement (i.e. some `P : Prop`) is whether the statement is true or \nfalse.  For example, the truth value of the statement: \"For all integers $x \u2208 \u2124$,  $0 \u2264 x^2$\" \nis *true* while  \"For all integers $x \u2208 \u2124$,  $0 \u2264 x^3$\" is *false*. \n\nIn lean we assign truth values as follows: We first think of a proposition $P$ as a set with \n*at most* one element.  If this set is empty, then we say `P` is *false*. Otherwise, if this set has \nan element, lets call it $p$ (we will usually use upper case letters for logical statements, \nand lower case for their proofs), then this  statement is *true* and $p$ is the proof. \n\nSo to recap, if $P$ is the true/false statement (the statement of proposition), and $p$ is its proof.\nIt's like thinking $P$ being the set and $p$ being the element. Just as above, where we had \n`P : Prop` to mean $P$  is a proposition, we write `p : P` to mean \"$p$ is a proof of $P$\".\n\nThe aim of this game is to learn how to manipulate logical statements and their proofs. \nLets start with a super basic example of how a lemma looks like in lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, \non the right you will  see the following: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere the first two lines are our assumptions and the thing after the `\u22a2` symbol is what we are \nbeing asked to prove. \n\nNow, in this game our \"moves\" or, as we call them in lean, *Tactics*, are what will allow us to \nmanipulate our statement and produce proofs.\n\nThe first tactic we will look at is called *exact* and what it does is, if you need to prove a \nstatement $P$ and you have proof of it, say, `p: P`, then `exact p` will prove it. \n\nNote that at the end of each line we write we need to have a comma `,` to tell lean that this is the \nend of our move. \n\nSo if below you change the `sorry` for \"`exact p,`\" (don't forget the comma!) you'll see that on the \nright it will change to say `Proof complete!`. \n\n-/\n\n\n/- Lemma\nLets try and prove that if $P$ is a logical stament (i.e. `P : Prop`) and $p$ is a proof of $P$ \n(i.e. `p : P`) then $P$ is true.\n-/\nlemma example1 (P : Prop) (p : P) : P :=\nbegin\n", "proof": "  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : exact\n## Summary \nIf the goal is `\u22a2 P` then `exact p` will close the goal if\nand only if `p` is a proof of `P` (i.e. `p : P`) \n## Details\nSay $P$, $Q$ and $R$ are logical staments\nand the local context looks like this: \n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n`exact j(h(p)),`\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n-/", "height": 3, "editorText": "sorry", "lineOffset": 71, "name": "example1", "statement": "(P : Prop) (p : P) : P"}, {"type": "tactic", "content": "6", "name": "exact", "sideBar": true}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "7", "hidden": true}, {"type": "text", "content": "8"}, {"type": "lean", "content": "9", "hidden": false}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "10", "hidden": true}, {"type": "text", "content": "11"}, {"type": "lemma", "text": "12", "lean": "lemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\n", "sideBar": true, "firstProofLineNumber": 44, "lastProofLineNumber": 47, "textBefore": "import tactic --hide \n\n/-\n\n#Combining logical statements\n\nNow, we can take these statements and create new ones. For example if we have two statements \n`P Q : Prop` we can write ` P \u2192 Q` to mean $P$ implies $Q$. Similarly, we can write `\u00acP` for the \nstatement \"Not $P$\". \n\nSay we have the following lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nThis asks us to prove: If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ \n(i.e. we have `p : P`). Then $Q$ is true (i.e. we have a proof of `Q`). \n\nHere we have given the name $h$ to the implication ` P \u2192 Q`. We think of $h$ as a map between \nstatements in `Prop` world. \n\nNow this lemma is asking us to take a proof of $P$ and turn it into a proof of $Q$. Since we know \nthat $P$ implies $Q$ then we know that if $P$ is true then so is $Q$. So we can use our map in \n`Prop` world to transform our proof of $P$ into a proof of $Q$. \n\nIf we write `exact h(p)` below we get what we want.\n\nNote that it has to be lower case $p$, since $P$ is the logical statement, but what we want to \ntransform is the proof.\n\n\n\n-/\n\n/- Lemma\nIf $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ (i.e. we have `p : P`). \nThen $Q$ is true (i.e. we have a proof of `Q`)\n-/\nlemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\nbegin\n", "proof": "  exact h(p),\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 43, "name": "implications_one", "statement": "(P Q : Prop) (h : P \u2192 Q) (p : P) : Q"}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "13", "hidden": false}, {"type": "text", "content": "14"}, {"type": "lean", "content": "15", "hidden": false}]}]}, {"name": "16", "levels": [{"name": "17", "problemIndex": -1, "objects": [{"type": "lean", "content": "18", "hidden": true}, {"type": "text", "content": "19"}]}, {"name": "20", "problemIndex": 3, "objects": [{"type": "lean", "content": "21", "hidden": true}, {"type": "lean", "content": "22", "hidden": true}, {"type": "text", "content": "23"}, {"type": "lemma", "text": "24", "lean": "lemma implies_self (P : Prop) : P \u2192 P :=\n", "sideBar": false, "firstProofLineNumber": 38, "lastProofLineNumber": 41, "textBefore": "import tactic --hide\n\nuniverse u --hide\n\n-- Level name : intro\n\n/-\n\nLets look at an example that needs the `intro` tactic: \n\nIf your goal is to prove `P \u2192 Q` (i.e. that $P\\implies Q$)\nthen `intro p`, meaning \"assume $p$ is a proof of $P$\", will make progress.\nTo solve the goal below, you have to come up with a function from\n`P` (thought of as the set of proofs of $P$!) to itself. Start with\n`intro p,`\n(i.e. \"let $p$ be a proof of $P$\") and note that our\nlocal context now looks like this:\n```\nP : Prop,\np : P\n\u22a2 P\n```\nOur job now is to construct a proof of $P$. But $p$ is a proof of $P$.\nSo\n`exact p,`\nwill close the goal. Note that `exact P` will not work -- don't\nconfuse a true/false statement (which could be false!) with a proof.\nWe will stick with the convention of capital letters for propositions\nand small letters for proofs.\n-/ \n\n\n/- Lemma : no-side-bar\nIf $P$ is a proposition then $P\\implies P$.\n-/\nlemma implies_self (P : Prop) : P \u2192 P :=\nbegin\n", "proof": "  intro p,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : intro\n\n## The `intro` tactic.\n\nIf your goal is\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill turn your tactic state into\n\n```\nhP : P\n\u22a2 Q\n```\n\nVariant: `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 <something else>`.\n\n-/", "height": 4, "editorText": "sorry", "lineOffset": 37, "name": "implies_self", "statement": "(P : Prop) : P \u2192 P"}, {"type": "tactic", "content": "25", "name": "intro", "sideBar": true}]}, {"name": "26", "problemIndex": 3, "objects": [{"type": "lean", "content": "27", "hidden": true}, {"type": "lean", "content": "28", "hidden": true}, {"type": "text", "content": "29"}, {"type": "lemma", "text": "30", "lean": "lemma implications_one_again (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 26, "textBefore": "import tactic --hide\n\nuniverse u --hide\n\n-- Level name : apply tactic\n\n/-\nLets look at using the apply tactic:\n\nHere's an example we have already done, but try and do it using the apply tactic:\n\n-/\n\n\n/- Lemma\nLets try and prove that if `P` implies `Q` (which is written ` P \u2192 Q`) and we have a proof of `P` \n(i.e. we have `p : P`). Then `Q` is true (i.e. we have a proof of `Q`)\n-/\n\nlemma implications_one_again (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\nbegin\n", "proof": "  apply h,\n  exact p,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : apply\n\n## The `apply` tactic\n\nIf your tactic state is\n\n```\nhPQ : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic\n\n`apply hPQ,`\n\nwill change it to\n\n```\nhPQ : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n-/", "height": 5, "editorText": "sorry", "lineOffset": 21, "name": "implications_one_again", "statement": "(P Q : Prop) (h : P \u2192 Q) (p : P) : Q"}, {"type": "tactic", "content": "31", "name": "apply", "sideBar": true}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "32", "hidden": true}, {"type": "text", "content": "33"}, {"type": "lean", "content": "34", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "35", "hidden": true}, {"type": "text", "content": "36"}, {"type": "lean", "content": "37", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "38", "hidden": true}, {"type": "lean", "content": "39", "hidden": false}, {"type": "text", "content": "40"}, {"type": "lean", "content": "41", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "42", "hidden": true}, {"type": "text", "content": "43"}, {"type": "text", "content": "44"}, {"type": "lean", "content": "45", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "46", "hidden": true}, {"type": "text", "content": "47"}, {"type": "text", "content": "48"}, {"type": "lean", "content": "49", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "50", "hidden": true}, {"type": "text", "content": "51"}, {"type": "text", "content": "52"}, {"type": "lean", "content": "53", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "54", "hidden": true}, {"type": "text", "content": "55"}, {"type": "lean", "content": "56", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "57", "hidden": true}, {"type": "text", "content": "58"}, {"type": "lean", "content": "59", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "60", "hidden": true}, {"type": "text", "content": "61"}, {"type": "lean", "content": "62", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "63", "hidden": true}, {"type": "text", "content": "64"}, {"type": "lean", "content": "65", "hidden": false}]}, {"name": "66", "problemIndex": -1, "objects": [{"type": "lean", "content": "67", "hidden": true}, {"type": "text", "content": "68"}, {"type": "lean", "content": "69", "hidden": false}]}], "parents": [0]}], "texts": [["Niki's Logic", "# de Morgan's logic Game\n\n## By UCL\n\nLearn some logic yo\n\n# What is this game?\n\nThis is a game to teach you some mathematical logic using Lean.\n\nHave fun!\n\n# Credits\n\nSome levels have been shamelessly borrowed from Kevin Buzzard's and Mohammad Pedramfar's \n\"Natural Numbers Game\" as well as  Kevin Buzzard's \"Formalizing mathematics\" course at \nImperial College. \n\n\n", "Tutorial", "import tactic --hide\n", "\n#Logical statements \n\nYou've seen logical statements already, these are statements that can be true or false, for example: \n\n-The sum of two odd numbers is an even number\n\n-$36$ is divisible by $3$\n\n-$x > 2$\n\n\nLets see how one does this a computer, specifically in lean. In lean, logical staments live in a \nworld called `Prop`. So for example if we write `P : Prop` we mean \"$P$ is a logical statement.\" \nThink of the `:` symbol as saying $P$  is a resident of `Prop` world (in maths this would be denoted\nby something like `P \u2208 Prop`).\n\n#Truth Values\n\nThe truth value of a logical statement (i.e. some `P : Prop`) is whether the statement is true or \nfalse.  For example, the truth value of the statement: \"For all integers $x \u2208 \u2124$,  $0 \u2264 x^2$\" \nis *true* while  \"For all integers $x \u2208 \u2124$,  $0 \u2264 x^3$\" is *false*. \n\nIn lean we assign truth values as follows: We first think of a proposition $P$ as a set with \n*at most* one element.  If this set is empty, then we say `P` is *false*. Otherwise, if this set has \nan element, lets call it $p$ (we will usually use upper case letters for logical statements, \nand lower case for their proofs), then this  statement is *true* and $p$ is the proof. \n\nSo to recap, if $P$ is the true/false statement (the statement of proposition), and $p$ is its proof.\nIt's like thinking $P$ being the set and $p$ being the element. Just as above, where we had \n`P : Prop` to mean $P$  is a proposition, we write `p : P` to mean \"$p$ is a proof of $P$\".\n\nThe aim of this game is to learn how to manipulate logical statements and their proofs. \nLets start with a super basic example of how a lemma looks like in lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, \non the right you will  see the following: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere the first two lines are our assumptions and the thing after the `\u22a2` symbol is what we are \nbeing asked to prove. \n\nNow, in this game our \"moves\" or, as we call them in lean, *Tactics*, are what will allow us to \nmanipulate our statement and produce proofs.\n\nThe first tactic we will look at is called *exact* and what it does is, if you need to prove a \nstatement $P$ and you have proof of it, say, `p: P`, then `exact p` will prove it. \n\nNote that at the end of each line we write we need to have a comma `,` to tell lean that this is the \nend of our move. \n\nSo if below you change the `sorry` for \"`exact p,`\" (don't forget the comma!) you'll see that on the \nright it will change to say `Proof complete!`. \n\n", "Lets try and prove that if $P$ is a logical stament (i.e. `P : Prop`) and $p$ is a proof of $P$ \n(i.e. `p : P`) then $P$ is true.\n", "## Summary \nIf the goal is `\u22a2 P` then `exact p` will close the goal if\nand only if `p` is a proof of `P` (i.e. `p : P`) \n## Details\nSay $P$, $Q$ and $R$ are logical staments\nand the local context looks like this: \n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n`exact j(h(p)),`\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n", "import tactic --hide \n", "Now try the following one:\n\n", "lemma example2 (P Q : Prop) (p : P) (q : Q) : Q :=\nbegin\n  exact q,\nend\n", "import tactic --hide \n", "\n#Combining logical statements\n\nNow, we can take these statements and create new ones. For example if we have two statements \n`P Q : Prop` we can write ` P \u2192 Q` to mean $P$ implies $Q$. Similarly, we can write `\u00acP` for the \nstatement \"Not $P$\". \n\nSay we have the following lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nThis asks us to prove: If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ \n(i.e. we have `p : P`). Then $Q$ is true (i.e. we have a proof of `Q`). \n\nHere we have given the name $h$ to the implication ` P \u2192 Q`. We think of $h$ as a map between \nstatements in `Prop` world. \n\nNow this lemma is asking us to take a proof of $P$ and turn it into a proof of $Q$. Since we know \nthat $P$ implies $Q$ then we know that if $P$ is true then so is $Q$. So we can use our map in \n`Prop` world to transform our proof of $P$ into a proof of $Q$. \n\nIf we write `exact h(p)` below we get what we want.\n\nNote that it has to be lower case $p$, since $P$ is the logical statement, but what we want to \ntransform is the proof.\n\n\n\n", "If $P$ implies $Q$ (which is written ` P \u2192 Q`) and we have a proof of $P$ (i.e. we have `p : P`). \nThen $Q$ is true (i.e. we have a proof of `Q`)\n", "import tactic\n", "Now try the following one: \n\n", "lemma implications_two (P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R :=\nbegin\n  exact h2 (h1 (p)),\nend", "Logical statements", "Tactics", "import tactic --hide\n", "\n## Tactics for Level 1\n\n## The `intro` tactic.\n\nIf your goal is\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill turn your tactic state into\n\n```\nhP : P\n\u22a2 Q\n```\n\nVariant: `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 <something else>`.\n\n## The `exact` tactic (we have already seen this)\n\nIf your tactic state is\n\n```\nhP : P\n\u22a2 P\n```\n\nthen the tactic\n\n`exact hP,`\n\nwill close your goal.\n\nNote: `exact P` does not work. Don't confuse\nthe *statement* `P` with its *proof* `hP`.\n\nVariant: The `assumption` tactic closes a goal if its proof is any one of the assumptions\nin the tactic state. \n\n## The `apply` tactic\n\nIf your tactic state is\n\n```\nhPQ : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic\n\n`apply hPQ,`\n\nwill change it to\n\n```\nhPQ : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n\n", "intro", "import tactic --hide\n", "universe u --hide\n", "\nLets look at an example that needs the `intro` tactic: \n\nIf your goal is to prove `P \u2192 Q` (i.e. that $P\\implies Q$)\nthen `intro p`, meaning \"assume $p$ is a proof of $P$\", will make progress.\nTo solve the goal below, you have to come up with a function from\n`P` (thought of as the set of proofs of $P$!) to itself. Start with\n`intro p,`\n(i.e. \"let $p$ be a proof of $P$\") and note that our\nlocal context now looks like this:\n```\nP : Prop,\np : P\n\u22a2 P\n```\nOur job now is to construct a proof of $P$. But $p$ is a proof of $P$.\nSo\n`exact p,`\nwill close the goal. Note that `exact P` will not work -- don't\nconfuse a true/false statement (which could be false!) with a proof.\nWe will stick with the convention of capital letters for propositions\nand small letters for proofs.\n", "If $P$ is a proposition then $P\\implies P$.\n", "\n## The `intro` tactic.\n\nIf your goal is\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill turn your tactic state into\n\n```\nhP : P\n\u22a2 Q\n```\n\nVariant: `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 <something else>`.\n\n", "apply tactic", "import tactic --hide\n", "universe u --hide\n", "Lets look at using the apply tactic:\n\nHere's an example we have already done, but try and do it using the apply tactic:\n\n", "Lets try and prove that if `P` implies `Q` (which is written ` P \u2192 Q`) and we have a proof of `P` \n(i.e. we have `p : P`). Then `Q` is true (i.e. we have a proof of `Q`)\n", "\n## The `apply` tactic\n\nIf your tactic state is\n\n```\nhPQ : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic\n\n`apply hPQ,`\n\nwill change it to\n\n```\nhPQ : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n", "import tactic -- hide\n", "Assume `Q` is true. Prove that `P \u2192 Q`. \n", "lemma lemma1 (P Q : Prop) (hQ : Q) : P \u2192 Q :=\nbegin\n  intro fish,\n  exact hQ,\nend", "import tactic -- hide\n", "Note that `\u2192` is not associative: in general `P \u2192 (Q \u2192 R)` and `(P \u2192 Q) \u2192 R`\nmight not be equivalent. This is like subtraction on numbers -- in general\n`a - (b - c)` and `(a - b) - c` might not be equal.\nSo if we write `P \u2192 Q \u2192 R` then we'd better know what this means.\nThe convention in Lean is that it means `P \u2192 (Q \u2192 R)`. If you think\nabout it, this means that to deduce `R` you will need to prove both `P`\nand `Q`. In general to prove `P1 \u2192 P2 \u2192 P3 \u2192 ... Pn` you can assume\n`P1`, `P2`,...,`P(n-1)` and then you have to prove `Pn`. \nSo the next level is asking you prove that `P \u2192 (Q \u2192 P)`.\n", "lemma lemma2 (P Q : Prop) : P \u2192 Q \u2192 P :=\nbegin\n  intro hP,\n  intro hQ,\n  exact hP,\nend", "import tactic -- hide\n", "/-If we know `P`, and we also know `P \u2192 Q`, we can deduce `Q`. \nThis is called \"Modus Ponens\" by logicians. -/\n", "Lemma : Modus_Ponens\n", "lemma Modus_Ponens (P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q :=\nbegin\n  intros hP hPQ,\n  apply hPQ,\n  exact hP,\nend", "import tactic --hide\n", " Lets show that implications are transitive. That is, if `P \u2192 Q` and `Q \u2192 R` are true, then\n  so is `P \u2192 R`.\n", "Lemma : implies is transitive\n", "lemma lemma4 (P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R) :=\nbegin\n  intros hPQ hQR hP,\n  apply hQR,\n  apply hPQ,\n  exact hP,\nend", "import tactic --hide\n", "If `h : P \u2192 Q \u2192 R` with goal `\u22a2 R` and you `apply h`, you'll get\ntwo goals! Note that tactics operate on only the first goal. So you'll have to first prove the \nfirst goal and then move onto the second. \nTip:  If you have multiple goals and you want to work on one that isnt the first one you can \nwrite `sorry,` to skip a proving a goal (although you will need to come back to it \neventually to complete the proof!)\n", "Lemma : lemma5\n", "lemma lemma5 (P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R) :=\nbegin\n  intros hPQR hPQ hP,\n  apply hPQR,\n  { exact hP },\n  { apply hPQ,\n    exact hP }\nend", "import tactic --hide\n", "Lets try some harder ones\n", "Lemma : lemma6\n", "lemma lemma6 (P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T :=\nbegin\n  intros hPR hSQ hRT hQR hS,\n  apply hRT,\n  apply hQR,\n  apply hSQ,\n  exact hS,\nend", "import tactic --hide\n", "Lemma : lemma7\n", "lemma lemma7 (P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q :=\nbegin\n  intros hPQ hPQP,\n  apply hPQ,\n  apply hPQP,\n  exact hPQ,\nend", "import tactic --hide\n", "Lemma : lemma8\n", "lemma lemma8 (P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P :=\nbegin\n  intros h1 h2 h3,\n  apply h2,\n  intro hQ,\n  apply h1,\n  intro hP,\n  exact hQ,\nend", "import tactic --hide\n", "Lemma : lemma9\n", "lemma lemma9 (P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P :=\nbegin\n  intros h1 h2 h3,\n  apply h1,\n  intro hQ,\n  apply h3,\n  apply h2,\n  exact hQ,\nend", "import tactic --hide\n", "Lemma : lemma10\n", "lemma lemma10 (P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q) :=\nbegin\n  intros h1 hP,\n  apply h1,\n  intro hPQ,\n  exact hPQ hP,\nend", "Boss fight 1", "import tactic --hide\n", "Lemma : boss_lemma_1\n", "lemma boss_lemma_1 (P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R :=\nbegin\n  intros h1 h2 h3,\n  apply h2,\n  intros h1 hP h2,\n  apply h1,\n  intro hP,\n  exact h2,\nend"]]}