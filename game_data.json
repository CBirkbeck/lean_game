{"name": "De Morgan's game", "version": "1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "De Morgan's game-1.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "lemma", "text": "5", "lean": "lemma example_one (P : Prop) (p : P) : P :=\n", "sideBar": true, "firstProofLineNumber": 74, "lastProofLineNumber": 76, "textBefore": "import tactic --hide\n\n/-\n\n#Logical statements \n\nYou've seen logical statements already, these are statements that can be true or false, for example: \n\n```md\n1. The sum of two odd numbers is an even number\n2. 36 is divisible by 3\n3. x > 2\n```\n\n\nLets see how one does this on a computer, specifically in lean. In lean, logical staments live in a \nworld called `Prop`. So for example if we write <mark style =\"background-color :   #ebdef0 \">`P : Prop`</mark> we mean \"$P$ is a logical statement.\" \nThink of the \"`:`\" symbol as saying $P$ lives in `Prop` world (in Maths this would be denoted\nby `P \u2208 Prop`, to mean `P` is an element of `Prop`).\n\n#Truth Values\n\nThe *truth value* of a logical statement (i.e. some <mark style =\"background-color :   #ebdef0 \">`P : Prop`</mark>) is whether the statement is true or \nfalse. For example, the truth value of the statement: \"For all integers $x \u2208 \u2124$, $0 \u2264 x^2$\" \nis *true*, while \"For all integers $x \u2208 \u2124$, $0 \u2264 x^3$\" is *false*. \n\nIn lean we assign truth values as follows: We first think of a proposition $P$ as a set with \n*at most* one element. If this set is empty, then we say `P` is *false*. Otherwise, if this set has \nan element, lets call it `p`, then this statement is *true* and `p` is the proof. We will usually \nuse upper case letters for logical statements, and lower case for their proofs.\n\nTo recap, we write  <mark style =\"background-color :   #ebdef0 \">`P : Prop`</mark>  to mean `P` is a \nproposition and we write  <mark style =\"background-color :   #ebdef0 \">`p : P`</mark>  to mean \"`p` is a \nproof of `P`\".\n\nThe aim of this game is to learn how to prove logical statements, which we call *lemmas* through a\nseries of manipulations which we call *tactics*. \n \nLets start with a simple example of how a lemma looks like in lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, \non the right you will see the following state: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere, the first two lines are our assumptions, where the first line <mark style =\"background-color :   #ebdef0 \">`P : Prop`</mark> says \"$P$ is a \nlogical statement\" and the second line <mark style =\"background-color :   #ebdef0 \">`p : P`</mark> says `p` is the proof of `P`.\n\nThe thing after the `\u22a2` symbol is what we need to prove to win the level (i.e. prove the lemma).\n\nIn this game our \"moves\" or, as we call them in lean, *tactics*, are what will allow us to \nmanipulate our statements and produce proofs.\n\nThe first tactic we will use is called *exact*. It is used when you need to prove a \nstatement $P$ and you have the proof of it. In the example above we have <mark style =\"background-color :   #ebdef0 \">`p : P`</mark> and we need to\nprove `P`, then <mark style =\"background-color :   #ebdef0 \">`exact p,`</mark>  will prove it. \n\n**Note:  We end each line with a comma `,` to tell lean that this is the end of our move.** \n\nTry it for yourself now and see what happens!\n\n-/\n\n\n/- Lemma\nIf $P$ is a logical stament and $p$ is a proof of $P$ then $P$ is true.\n-/\nlemma example_one (P : Prop) (p : P) : P :=\nbegin\n", "proof": "  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : exact\n## Summary \nIf the goal is `\u22a2 P` then `exact p,` will close the goal if\nand only if `p` is a proof of `P` (i.e. `p : P`) \n## Details\nSay $P$, $Q$ and $R$ are logical staments\nand your lemma looks like this: \n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\nThen you can solve the level by using `exact j(h(p)),`\n-/\n", "height": 3, "editorText": "sorry", "lineOffset": 73, "name": "example_one", "statement": "(P : Prop) (p : P) : P"}, {"type": "tactic", "content": "6", "name": "exact", "sideBar": true}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "7", "hidden": true}, {"type": "lemma", "text": "8", "lean": "lemma example_two (P Q : Prop) (p : P) (q : Q) : Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 10, "textBefore": "import tactic --hide \n\n/-Lemma\nIf $P,Q$ are logical statements with respective proofs $p,q$, then $Q$ is true.\n-/\nlemma example_two (P Q : Prop) (p : P) (q : Q) : Q :=\nbegin\n", "proof": "  exact q,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 7, "name": "example_two", "statement": "(P Q : Prop) (p : P) (q : Q) : Q"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "9", "hidden": true}, {"type": "text", "content": "10"}, {"type": "lemma", "text": "11", "lean": "lemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\n", "sideBar": true, "firstProofLineNumber": 45, "lastProofLineNumber": 48, "textBefore": "import tactic --hide \n\n/-\n\n#Combining logical statements\n\nWe can combine basic statements to create new ones. For example, we can write `\u00acP` for the \nstatement \"Not `P`\" and if we have two statements <mark style =\"background-color : #ebdef0 \">`P Q : Prop`</mark> \nwe can write <mark style =\"background-color :  #ebdef0 \">`P \u2192 Q`</mark> to mean `P` implies `Q`. \n\nSay we have the following state of our lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nAs in level one, the first line says `P` and `Q` are logical statements and the third line says\nthat `P` has a proof `p`.\n\nIn the second line we have the implication <mark style =\"background-color :  #ebdef0 \">`P \u2192 Q`</mark>, which we have called `h`. We think of `h` \nas a one-way road from the statement `P` to the statement `Q` in `Prop` world. \nIn Maths, we would call `h` a function or a map. \n\nFinally, our goal is to prove `Q` is true.\n\nUsing <mark style =\"background-color :  #ebdef0 \">`exact h(p),`</mark> will prove our lemma.\n\nWhy does this work? We know that `P` is true, since we have a proof of it `p` and `h` tells us that\nif `P` is true then `Q` is true. So combining `h` and `p` results in a proof of `Q`.\n\n**Note: We use `h(p)` rather than `h(P)`, because we want to transform the proof of `P` into \na proof of `Q`.**\n\n\n\n-/\n\n/- Lemma\nLet $P,Q$ be logical statements and $P$ implies $Q$. If $P$ is true, then so is $Q$.\n-/\nlemma implications_one (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\nbegin\n", "proof": "  exact h(p),\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 44, "name": "implications_one", "statement": "(P Q : Prop) (h : P \u2192 Q) (p : P) : Q"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "12", "hidden": true}, {"type": "lemma", "text": "13", "lean": "lemma implications_two (P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 12, "textBefore": "import tactic --hide\n\n\n/-Lemma\nLet $P,Q,R$ be logical statements with $P$ implies $Q$ and $Q$ implies $R$. If $P$ is true, then so \nis $R$. \n-/\nlemma implications_two (P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R :=\nbegin\n", "proof": "  exact h2 (h1 (p)),\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 3, "editorText": "sorry", "lineOffset": 9, "name": "implications_two", "statement": "(P Q R : Prop) (h1 : P \u2192 Q) (h2 : Q \u2192 R) (p : P) : R"}]}]}, {"name": "14", "levels": [{"name": "15", "problemIndex": 3, "objects": [{"type": "lean", "content": "16", "hidden": true}, {"type": "lean", "content": "17", "hidden": true}, {"type": "text", "content": "18"}, {"type": "lemma", "text": "19", "lean": "lemma implications_one_again (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\n", "sideBar": true, "firstProofLineNumber": 40, "lastProofLineNumber": 44, "textBefore": "import tactic --hide\n\nuniverse u --hide\n\n-- Level name : apply tactic\n\n/-\n\n## The `apply` tactic\n\nIf your lemma has the following state: \n\n```\nh : P \u2192 Q\n\u22a2 Q\n```\n\nHere, we assume that `P` implies `Q` and our goal is to prove `Q`. Then the tactic  <mark style =\"background-color : #ebdef0 \">`apply h,`</mark> \nwill change our goal to `P` and leave our assumptions unchanged, i.e. your new state will be\n\n```\nh : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n\nHere's an example we have already done, but try and do it using the `apply` tactic:\n\n-/\n\n\n/- Lemma\nLet $P,Q$ be logical statements. If $P$ implies $Q$ and $P$ is true, then $Q$ is true. \n-/\n\nlemma implications_one_again (P Q : Prop) (h : P \u2192 Q) (p : P) : Q :=\nbegin\n", "proof": "  apply h,\n  exact p,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : apply\n\n## The `apply` tactic\n\nIf your lemma looks like\n\n```\nh : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic `apply h,` will change it to\n\n```\nh : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n\n\n-/", "height": 5, "editorText": "sorry", "lineOffset": 39, "name": "implications_one_again", "statement": "(P Q : Prop) (h : P \u2192 Q) (p : P) : Q"}, {"type": "tactic", "content": "20", "name": "apply", "sideBar": true}]}, {"name": "21", "problemIndex": 5, "objects": [{"type": "lean", "content": "22", "hidden": true}, {"type": "lean", "content": "23", "hidden": true}, {"type": "text", "content": "24"}, {"type": "hint", "content": "25", "title": "26"}, {"type": "hint", "content": "27", "title": "28"}, {"type": "lemma", "text": "29", "lean": "lemma implies_self (P : Prop) : P \u2192 P :=\n", "sideBar": false, "firstProofLineNumber": 49, "lastProofLineNumber": 52, "textBefore": "import tactic --hide\n\nuniverse u --hide\n\n-- Level name : intro\n\n/-\n\n## The `intro` tactic.\n\nIf your goal is \n\n```\n\u22a2 P \u2192 Q\n```\n\nmeaning we need to prove the `P` implies `Q` then the tactic <mark style =\"background-color : #ebdef0 \">`intro hp,`</mark> \nwill take `P` as true with proof `hp` and add `hp : P` to the assumptions. In addition, \nit turn your goal into `\u22a2 Q`. \n\nIn other words the state of the lemma becomes:  \n\n```\nhp : P\n\u22a2 Q\n```\n\nLets look at an example that needs the `intro` tactic: \n\n\n-/ \n\n\n/-Hint : Hint\nStart with `intro p`.\n-/\n\n/-Hint : Tip\n `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hp hq` if your goal is `P \u2192 Q \u2192 R`.\n-/\n\n/- Lemma : no-side-bar\nIf $P$ is a logical statement then $P\\implies P$.\n-/\nlemma implies_self (P : Prop) : P \u2192 P :=\nbegin\n", "proof": "  intro p,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : intro\n\n## The `intro` tactic.\n\nIf your goal is to prove the implication\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill add `hp : P` as an assumption (i.e. `hp` is the proof of `P`) and turn your goal into `\u22a2 Q`. \nIn other words we get: \n\n```\nhP : P\n\u22a2 Q\n```\n\nTip : `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 R`.\n\n-/", "height": 4, "editorText": "sorry", "lineOffset": 48, "name": "implies_self", "statement": "(P : Prop) : P \u2192 P"}, {"type": "tactic", "content": "30", "name": "intro", "sideBar": true}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "31", "hidden": true}, {"type": "lemma", "text": "32", "lean": "lemma lemma_1 (P Q : Prop) (hQ : Q) : P \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 13, "textBefore": "import tactic -- hide\n\n/-Lemma\nLet $P,Q$ be logical statement and assume $Q$ is true, then $P$ implies $Q$. \n-/\nlemma lemma_1 (P Q : Prop) (hQ : Q) : P \u2192 Q :=\nbegin\n", "proof": "  intro fish,\n  exact hQ,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-Hint : Why is this true?\nThis works because the implication `P \u2192 Q` is true unless `Q` is false and `P` is true. In this case\nwe are given that `Q` is always true, so the implication holds regardless of the truth value of `P`. \n-/\n", "height": 6, "editorText": "sorry", "lineOffset": 7, "name": "lemma_1", "statement": "(P Q : Prop) (hQ : Q) : P \u2192 Q"}, {"type": "hint", "content": "33", "title": "34"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "35", "hidden": true}, {"type": "lemma", "text": "36", "lean": "lemma lemma_2 (P Q : Prop) : P \u2192 Q \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 9, "lastProofLineNumber": 14, "textBefore": "import tactic -- hide\n\n\n/-Lemma \nIf $P,Q$ are logical statements, then $P$ implies $(Q \\implies P)$\n-/\nlemma lemma_2 (P Q : Prop) : P \u2192 Q \u2192 P :=\nbegin\n", "proof": "  intro hP,\n  intro hQ,\n  exact hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-Hint : Caution\n\nNote that implies `\u2192` is not associative: in general `P \u2192 (Q \u2192 R)` and `(P \u2192 Q) \u2192 R`\nmight not be equivalent. This is like subtraction on numbers -- in general\n`a - (b - c)` and `(a - b) - c` might not be equal.\nSo if we write `P \u2192 Q \u2192 R` then we'd better know what this means.\nThe convention in Lean is that it means `P \u2192 (Q \u2192 R)`. If you think\nabout it, this means that to deduce `R` you will need to prove both `P`\nand `Q`. \n-/", "height": 6, "editorText": "sorry", "lineOffset": 8, "name": "lemma_2", "statement": "(P Q : Prop) : P \u2192 Q \u2192 P"}, {"type": "hint", "content": "37", "title": "38"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "39", "hidden": true}, {"type": "text", "content": "40"}, {"type": "lemma", "text": "41", "lean": "lemma Modus_Ponens (P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 13, "lastProofLineNumber": 18, "textBefore": "import tactic -- hide\n\n/-\nIf we know `P`, and we also know `P \u2192 Q`, we can deduce `Q`. \nThis is called \"Modus Ponens\" by logicians.\n-/\n\n/- Lemma  \nIf $P$ is true and $P \\implies Q$ is true, then $Q$ is true.\n-/\nlemma Modus_Ponens (P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q :=\nbegin\n", "proof": "  intros hP hPQ,\n  apply hPQ,\n  exact hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 12, "name": "Modus_Ponens", "statement": "(P Q : Prop) : P \u2192 (P \u2192 Q) \u2192 Q"}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "42", "hidden": true}, {"type": "text", "content": "43"}, {"type": "hint", "content": "44", "title": "45"}, {"type": "lemma", "text": "46", "lean": "lemma implicationss_are_transitive (P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 24, "textBefore": "import tactic --hide\n\n/-\nThe goal for this level is to show that implications are transitive. \nThat is, if `P \u2192 Q` and `Q \u2192 R` are true, then so is `P \u2192 R`.\n-/\n\n/- Hint: Hint\nIt might be useful to start by using `intros hPQ hQR hP`.\n-/\n\n\n/-Lemma  \nIf $P,Q,R$ are logical statements and $P \\implies Q$ and $Q \\implies R$ then $P \\implies R$.\n-/\nlemma implicationss_are_transitive (P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R) :=\nbegin\n", "proof": "  intros hPQ hQR hP,\n  apply hQR,\n  apply hPQ,\n  exact hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 17, "name": "implicationss_are_transitive", "statement": "(P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R)"}]}, {"name": "47", "problemIndex": 4, "objects": [{"type": "lean", "content": "48", "hidden": true}, {"type": "hint", "content": "49", "title": "50"}, {"type": "hint", "content": "51", "title": "52"}, {"type": "hint", "content": "53", "title": "54"}, {"type": "lemma", "text": "55", "lean": "lemma lemma_5 (P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R) :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 35, "textBefore": "import tactic --hide\n\n-- Level name : Boss level\n\n/- Hint : Hint 1\n Notice we have three implications, so we need to introduce all of them using `intros`.\n\n-/\n\n/-Hint : Hint 2\nWhen using `apply` we need to make sure that we use an assumption that contains our goal.\n\n-/\n\n/-Hint : Hint 3\nIf we have more than one goal to prove, then we need to do them in order. By default the lean \napplies the tactics to the first goal until complete and then moves on to the next.  \n\n-/\n\n\n/-Lemma \nIf $P,Q,R$ are logical statements and\n $(P \\implies Q \\implies R)$  then $((P \\implies Q) \\implies (P \\implies R)$.\n-/\nlemma lemma_5 (P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R) :=\nbegin\n", "proof": "  intros hPQR hPQ hP,\n  apply hPQR,\n  { exact hP },\n  { apply hPQ,\n    exact hP }\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Hint : Tip\nTo skip proving a goal you can  write `sorry,`. But don't forget to go back and prove it to solve the\nlevel.  \n\n-/", "height": 8, "editorText": "sorry", "lineOffset": 27, "name": "lemma_5", "statement": "(P Q R : Prop) : (P \u2192 Q \u2192 R) \u2192 (P \u2192 Q) \u2192 (P \u2192 R)"}, {"type": "hint", "content": "56", "title": "57"}]}], "parents": [0]}, {"name": "58", "levels": [{"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "59", "hidden": true}, {"type": "text", "content": "60"}, {"type": "lemma", "text": "61", "lean": "lemma lemma_6 (P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T :=\n", "sideBar": true, "firstProofLineNumber": 13, "lastProofLineNumber": 20, "textBefore": "import tactic --hide\n\n/-\nLets try some harder implication statements. \n-/\n\n\n/-Lemma \nThis is a long chain of implications.\n-/\nlemma lemma_6 (P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T :=\nbegin\n", "proof": "  intros hPR hSQ hRT hQR hS,\n  apply hRT,\n  apply hQR,\n  apply hSQ,\n  exact hS,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 8, "editorText": "sorry", "lineOffset": 12, "name": "lemma_6", "statement": "(P Q R S T : Prop) : (P \u2192 R) \u2192 (S \u2192 Q) \u2192 (R \u2192 T) \u2192 (Q \u2192 R) \u2192 S \u2192 T"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "62", "hidden": true}, {"type": "lemma", "text": "63", "lean": "lemma lemma_7 (P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-Lemma\nMore nested implications\n-/\nlemma lemma_7 (P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q :=\nbegin\n", "proof": "  intros hPQ hPQP,\n  apply hPQ,\n  apply hPQP,\n  exact hPQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 7, "name": "lemma_7", "statement": "(P Q: Prop) : (P \u2192 Q) \u2192 ((P \u2192 Q) \u2192 P) \u2192 Q"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "64", "hidden": true}, {"type": "lemma", "text": "65", "lean": "lemma lemma_8 (P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 9, "lastProofLineNumber": 17, "textBefore": "import tactic --hide\n\n\n/-Lemma\nEven more nested implications\n-/\nlemma lemma_8 (P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P :=\nbegin\n", "proof": "  intros h1 h2 h3,\n  apply h2,\n  intro hQ,\n  apply h1,\n  intro hP,\n  exact hQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 8, "name": "lemma_8", "statement": "(P Q R : Prop) : ((P \u2192 Q) \u2192 R) \u2192 ((Q \u2192 R) \u2192 P) \u2192 ((R \u2192 P) \u2192 Q) \u2192 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "66", "hidden": true}, {"type": "lemma", "text": "67", "lean": "lemma lemma_9 (P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 16, "textBefore": "import tactic --hide\n\n/-Lemma\nThis is getting silly now\n-/\nlemma lemma_9 (P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P :=\nbegin\n", "proof": "  intros h1 h2 h3,\n  apply h1,\n  intro hQ,\n  apply h3,\n  apply h2,\n  exact hQ,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 7, "name": "lemma_9", "statement": "(P Q R : Prop) : ((Q \u2192 P) \u2192 P) \u2192 (Q \u2192 R) \u2192 (R \u2192 P) \u2192 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "68", "hidden": true}, {"type": "lemma", "text": "69", "lean": "lemma lemma_10 (P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q) :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-Lemma\nHow hard could it be?\n-/\nlemma lemma_10 (P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q) :=\nbegin\n", "proof": "  intros h1 hP,\n  apply h1,\n  intro hPQ,\n  exact hPQ hP,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 7, "name": "lemma_10", "statement": "(P Q : Prop) : (((P \u2192 Q) \u2192 Q) \u2192 Q) \u2192 (P \u2192 Q)"}]}, {"name": "70", "problemIndex": 1, "objects": [{"type": "lean", "content": "71", "hidden": true}, {"type": "lemma", "text": "72", "lean": "lemma boss_lemma_1 (P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R :=\n", "sideBar": true, "firstProofLineNumber": 13, "lastProofLineNumber": 21, "textBefore": "import tactic --hide\n\n-- Level name : Boss fight 1\n\n/-Lemma\nTime for a boss fight!\n-/\nlemma boss_lemma_1 (P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R :=\nbegin\n", "proof": "  intros h1 h2 h3,\n  apply h2,\n  intros h1 hP h2,\n  apply h1,\n  intro hP,\n  exact h2,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 12, "name": "boss_lemma_1", "statement": "(P Q R : Prop) :\n  (((P \u2192 Q \u2192 Q) \u2192 ((P \u2192 Q) \u2192 Q)) \u2192 R) \u2192\n  ((((P \u2192 P) \u2192 Q) \u2192 (P \u2192 P \u2192 Q)) \u2192 R) \u2192\n  (((P \u2192 P \u2192 Q) \u2192 ((P \u2192 P) \u2192 Q)) \u2192 R) \u2192 R"}]}], "parents": [1]}, {"name": "73", "levels": [{"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "74", "hidden": true}, {"type": "text", "content": "75"}, {"type": "hint", "content": "76", "title": "77"}, {"type": "lemma", "text": "78", "lean": "lemma split_example_one (P Q : Prop) (p : P) (q : Q) : P \u2227 Q :=\n", "sideBar": true, "firstProofLineNumber": 47, "lastProofLineNumber": 49, "textBefore": "import tactic --hide\n\n/-\n## The `split` tactic\n\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2227 Q\n```\n\nthen the  <mark style =\"background-color : #ebdef0 \">`split`</mark>  tactic will turn it\ninto *two* goals `\u22a2 P` and `\u22a2 Q`.\n\n-/\n\n/-Hint : Tip\nIt is best practice to indicate when you are working with two goals, either by using squiggly \nbrackets like this:\n\n```\n...\nsplit,\n{ working on P,\n  end of proof of P },\n{ working on Q,\n  end of proof of Q },\n```\n\nor by using indentation like this:\n\n```\nsplit,\n  working on P,\n  end of proof of P,\nworking on Q,\n...\n```\n-/\n\n/- Lemma\nLet $P,Q$ be logical statements and assume that they are both true, then $P \u2227 Q$ is \ntrue.\n-/\nlemma split_example_one (P Q : Prop) (p : P) (q : Q) : P \u2227 Q :=\nbegin\n", "proof": "  split,\n  exact p,\n  exact q,", "proof_hint": "sorry", "textAfter": "\nend", "height": 3, "editorText": "sorry", "lineOffset": 46, "name": "split_example_one", "statement": "(P Q : Prop) (p : P) (q : Q) : P \u2227 Q"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "79", "hidden": true}, {"type": "text", "content": "80"}, {"type": "lemma", "text": "81", "lean": "lemma split_examle_two (P : Prop) : P \u2194 P :=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 23, "textBefore": "import tactic --hide\n\n\n/-\n`split` can also be used for if and only if statements. For example, if you have `\u22a2 P \u2194 Q` and apply\n`split`, then your goal will change from \n\n```\n\u22a2 P \u2194 Q\n```\nto two goals, `\u22a2 P \u2192 Q` and `\u22a2 Q \u2192 P`.\n-/\n\n/- Lemma\nLet $P$ be a logical statement, then $P$ is true if and only if $P$ is true.\n-/\nlemma split_examle_two (P : Prop) : P \u2194 P :=\nbegin\n", "proof": "  split,\n  intro p,\n  exact p,\n  intro p,\n  exact p,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : split\n\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2227 Q\n```\n\nthen the  `split` tactic will turn it into *two* goals `\u22a2 P` and `\u22a2 Q`.\n\nMoreover, if you have an iff `P \u2194 Q` then splitting it will give you two goals, `P \u2192 Q` \n(i.e \"`P` only if `Q`\") and `P \u2190 Q ` (i.e \"`P` if `Q`\") to prove.\n\n-/", "height": 5, "editorText": "sorry", "lineOffset": 18, "name": "split_examle_two", "statement": "(P : Prop) : P \u2194 P"}, {"type": "tactic", "content": "82", "name": "split", "sideBar": true}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "83", "hidden": true}, {"type": "text", "content": "84"}, {"type": "hint", "content": "85", "title": "86"}, {"type": "lean", "content": "87", "hidden": false}, {"type": "tactic", "content": "88", "name": "left and right", "sideBar": true}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "89", "hidden": true}, {"type": "text", "content": "90"}, {"type": "lemma", "text": "91", "lean": "lemma cases_and_example (P Q : Prop) (h : P \u2227 Q) : P :=\n", "sideBar": true, "firstProofLineNumber": 42, "lastProofLineNumber": 43, "textBefore": "import tactic --hide\n\n/-\n## The `cases` tactic\n\n`cases` is a very general-purpose tactic for \"deconstructing\" hypotheses.\nIf `h` is an assumption which somehow \"bundles up\" two pieces of information,\nthen  <mark style =\"background-color : #ebdef0 \">`cases h with h1 h2`</mark>  will make the assumption `h` vanish and will replace it\nwith the two \"components\" which made the proof of `h` in the first place.\nAn example of this occurring is if you have the assumption `h : P \u2227 Q` which contains a \nproof of `P` and a proof of `Q`.\n\n\n\nFor example, if you have an assumption\n\n```\nh : P \u2227 Q\n```\n\nthen\n\n`cases h with hP hQ,`\n\nwill delete `h` and replace it with\n\n```\nhP : P\nhQ : Q\n```\nTry it out below.\n\n-/\n\n\n/- Lemma\nIf $P,Q$ are logical statements and $P \u2227 Q$ is true then so is $P$.\n-/\n\nlemma cases_and_example (P Q : Prop) (h : P \u2227 Q) : P :=\nbegin \n", "proof": "  cases h with hP hQ,\n  exact hP,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : cases\n\nIf you have a hypothesis\n\n```\nh : P \u2227 Q\n```\n\nthen\n\n`cases h with hP hQ,`\n\nwill delete `h` and replace it with\n\n```\nhP : P\nhQ : Q\n```\n\nYou can also use it for \"or's\". Specifically, if you have `h : P \u2228 Q` then `cases h` will\ngive you two goals, one where `P` is true and one where `Q` is true.\n\n-/", "height": 2, "editorText": "sorry", "lineOffset": 41, "name": "cases_and_example", "statement": "(P Q : Prop) (h : P \u2227 Q) : P"}, {"type": "tactic", "content": "92", "name": "cases", "sideBar": true}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "93", "hidden": true}, {"type": "text", "content": "94"}, {"type": "lemma", "text": "95", "lean": "lemma cases_or_example (P : Prop) (hp : P \u2228 P) : P :=\n", "sideBar": true, "firstProofLineNumber": 37, "lastProofLineNumber": 39, "textBefore": "import tactic --hide\n\n\n/-\nYou can also use `cases` when working with the `\u2228` (\"or\") connective.For example, if you have\nthe assumption\n\n```\nh : P \u2228 Q\n``` \n\nthen `cases h with hp hq` will convert your state into the following two states:\n\n```\nP : Prop\nhp : P\n\u22a2 P\n```\nand\n\n```\nP : Prop\nhq : Q\n\u22a2 Q\n```\none where `P` is true and one where `Q` is true.\n\nTry this in the lemma below\n-/\n\n/- Lemma\nIf $P$ is a logical statement and $P$ or $P$ is true, then $P$ is true.\n-/\n\nlemma cases_or_example (P : Prop) (hp : P \u2228 P) : P :=\nbegin\n", "proof": "  cases hp with hp hp,\n  exact hp,\n  exact hp,", "proof_hint": "sorry", "textAfter": "\nend", "height": 3, "editorText": "sorry", "lineOffset": 36, "name": "cases_or_example", "statement": "(P : Prop) (hp : P \u2228 P) : P"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "96", "hidden": true}, {"type": "text", "content": "97"}, {"type": "lemma", "text": "98", "lean": "lemma and_commutative (P Q : Prop) : P \u2227 Q \u2194 Q \u2227 P :=\n", "sideBar": true, "firstProofLineNumber": 12, "lastProofLineNumber": 23, "textBefore": "import tactic --hide\n\n/-\nThis level proves that `\u2227` is a commutative operator. \n-/\n\n/-Lemma\nLet $P,Q$ be logical statements, then $P \u2227 Q$ is true iff $Q \u2227 P$ is true.\n-/\nlemma and_commutative (P Q : Prop) : P \u2227 Q \u2194 Q \u2227 P :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h,\n  split,\n  exact h_right,\n  exact h_left,\n  intro h,\n  split,\n  exact h.2,\n  exact h.1,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 12, "editorText": "sorry", "lineOffset": 11, "name": "and_commutative", "statement": "(P Q : Prop) : P \u2227 Q \u2194 Q \u2227 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "99", "hidden": true}, {"type": "lemma", "text": "100", "lean": "lemma and_implication (P Q R : Prop) :  P \u2228 Q \u2192 (P \u2192 R) \u2192 (Q \u2192 R) \u2192 R :=\n", "sideBar": true, "firstProofLineNumber": 9, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-Lemma\nIf $P,Q,R$ are logical statements then $P \u2227 Q$ implies that \n$(P \\implies R) \\implies (Q \\implies R) \\implies R$ \n-/\nlemma and_implication (P Q R : Prop) :  P \u2228 Q \u2192 (P \u2192 R) \u2192 (Q \u2192 R) \u2192 R :=\nbegin\n", "proof": "  intros hPoQ hPR hQR,\n  cases hPoQ with hP hQ,\n  { apply hPR,\n    exact hP },\n  { exact hQR hQ }\n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 8, "name": "and_implication", "statement": "(P Q R : Prop) :  P \u2228 Q \u2192 (P \u2192 R) \u2192 (Q \u2192 R) \u2192 R"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "101", "hidden": true}, {"type": "text", "content": "102"}, {"type": "lemma", "text": "103", "lean": "lemma and_transitive (P Q R: Prop) : (P \u2227 Q) \u2192 (Q \u2227 R) \u2192 (P \u2227 R)  :=\n", "sideBar": true, "firstProofLineNumber": 12, "lastProofLineNumber": 14, "textBefore": "import tactic --hide\n\n/-\nThis level will show that `\u2227` is *transitive*.\n-/\n\n/-Lemma\nIf $P,Q,R$ are logical statements, then $P \u2227 Q$ and $Q \u2227 R$ imples $P \u2227 R$.\n-/\nlemma and_transitive (P Q R: Prop) : (P \u2227 Q) \u2192 (Q \u2227 R) \u2192 (P \u2227 R)  :=\nbegin\n", "proof": "  rintro \u27e8hP, hQ\u27e9 \u27e8-, hR\u27e9,\n  exact \u27e8hP, hR\u27e9,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 3, "editorText": "sorry", "lineOffset": 11, "name": "and_transitive", "statement": "(P Q R: Prop) : (P \u2227 Q) \u2192 (Q \u2227 R) \u2192 (P \u2227 R)"}]}], "parents": [1]}, {"name": "104", "levels": [{"name": "105", "problemIndex": 2, "objects": [{"type": "lean", "content": "106", "hidden": true}, {"type": "text", "content": "107"}, {"type": "lemma", "text": "108", "lean": "lemma absorption_one (P Q : Prop) : P \u2227 (P \u2228 Q) \u2194 P :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 22, "textBefore": "import tactic --hide\n\n-- Level name : absorpsion laws pt 1\n\n/-\nLets try and prove that $P \u2227 (P \u2228 Q)$ is equivalent to $P$\n-/\n\n/-Lemma\nIf $P,Q$ are logical statements then $P \u2227 (P \u2228 Q)$ is true if and only if $P$ is true.\n-/\nlemma absorption_one (P Q : Prop) : P \u2227 (P \u2228 Q) \u2194 P :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with hP hPQ,\n  exact hP,\n  intro h,\n  split,\n  exact h,\n  left,\n  exact h,  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 9, "editorText": "sorry", "lineOffset": 13, "name": "absorption_one", "statement": "(P Q : Prop) : P \u2227 (P \u2228 Q) \u2194 P"}]}, {"name": "109", "problemIndex": 2, "objects": [{"type": "lean", "content": "110", "hidden": true}, {"type": "lean", "content": "111", "hidden": false}, {"type": "lemma", "text": "112", "lean": "lemma absorption_two (P Q : Prop) : P \u2228 (P \u2227 Q) \u2194 P :=\n", "sideBar": true, "firstProofLineNumber": 13, "lastProofLineNumber": 21, "textBefore": "import tactic --hide\n\n-- Level name : absorpsion laws pt 2\n\n/-Lets try and prove that $P \u2228 (P \u2227 Q)$ is equivalent to $P$\n-/\n\n/-Lemma\nIf $P,Q$ are logical statements then $P \u2228 (P \u2227 Q)$ is true if and only if $P$ is true.\n-/\nlemma absorption_two (P Q : Prop) : P \u2228 (P \u2227 Q) \u2194 P :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h,\n  exact h,\n  cases h,\n  exact h_left,\n  intro h,\n  left,\n  exact h,", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 12, "name": "absorption_two", "statement": "(P Q : Prop) : P \u2228 (P \u2227 Q) \u2194 P"}]}, {"name": "113", "problemIndex": 2, "objects": [{"type": "lean", "content": "114", "hidden": true}, {"type": "text", "content": "115"}, {"type": "lemma", "text": "116", "lean": "lemma associativity_one (P Q R : Prop) : P \u2227 (Q \u2227 R) \u2194 (P \u2227 Q) \u2227 R :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 31, "textBefore": "import tactic --hide\n\n-- Level name : Associative laws pt 1\n\n/-\nLets prove that $P \u2227 (Q \u2227 R)$ is equivalent to $(P \u2227 Q) \u2227 R$. We call this *associativity* of `\u2227`.\n-/\n\n/-Lemma\nIf $P,Q,R$ are logical statements, then $P \u2227 (Q \u2227 R)$ is true iff $(P \u2227 Q) \u2227 R$ is true.\n-/\nlemma associativity_one (P Q R : Prop) : P \u2227 (Q \u2227 R) \u2194 (P \u2227 Q) \u2227 R :=\nbegin\n", "proof": "  split,\n  intro h,\n  split,\n  cases h with hl hr,\n  split,\n  exact hl,\n  cases hr,\n  exact hr_left,\n  cases h with h1 h2,\n  cases h2 with h2 h3,\n  exact h3,\n  intro h,\n  split,\n  cases h,\n  exact h_left.1,\n  split,\n  exact h.1.2,\n  exact h.2,", "proof_hint": "sorry", "textAfter": "\nend", "height": 18, "editorText": "sorry", "lineOffset": 13, "name": "associativity_one", "statement": "(P Q R : Prop) : P \u2227 (Q \u2227 R) \u2194 (P \u2227 Q) \u2227 R"}]}, {"name": "117", "problemIndex": 2, "objects": [{"type": "lean", "content": "118", "hidden": true}, {"type": "text", "content": "119"}, {"type": "lemma", "text": "120", "lean": "lemma associativity_two (P Q R : Prop) : P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 36, "textBefore": "import tactic --hide\n\n-- Level name : Associative laws pt 2\n\n/-\nLets prove that `\u2228` is also associative.\n-/\n\n/-Lemma\nIf $P,Q,R$ are logical statements then $P \u2228 (Q \u2228 R)$ is true iff $(P \u2228 Q) \u2228 R$ is true.\n-/\nlemma associativity_two (P Q R : Prop) : P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with h1 h2,\n  left,\n  left,\n  exact h1,\n  cases h2 with h2 h3,\n  left,\n  right,\n  exact h2,\n  right,\n  exact h3,\n  intro h,\n  cases h with h1 h2,\n  cases h1 with h1 h3,\n  left,\n  exact h1,\n  right,\n  left,\n  exact h3,\n  right,\n  right,\n  exact h2,", "proof_hint": "sorry", "textAfter": "\nend", "height": 23, "editorText": "sorry", "lineOffset": 13, "name": "associativity_two", "statement": "(P Q R : Prop) : P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R"}]}, {"name": "121", "problemIndex": 2, "objects": [{"type": "lean", "content": "122", "hidden": true}, {"type": "text", "content": "123"}, {"type": "lemma", "text": "124", "lean": "lemma distributivity_one (P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R) :=\n", "sideBar": true, "firstProofLineNumber": 15, "lastProofLineNumber": 36, "textBefore": "import tactic --hide\n\n-- Level name : Distributive laws 1\n\n/-\nLets prove that $P \u2227 (Q \u2228 R)$ is equivalent to $(P \u2227 Q) \u2228 (P \u2227 R)$. We call this property of `\u2227` \nand `\u2228`, *distributivity*. \n-/\n\n/-Lemma\nIf $P,Q,R$ are logical statements then $P \u2227 (Q \u2228 R)$ is true iff $(P \u2227 Q) \u2228 (P \u2227 R)$ is true.\n-/\nlemma distributivity_one (P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R) :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with h1 h2,\n  cases h2 with h2 h3,\n  left,\n  split,\n  exact h1,\n  exact h2,\n  right,\n  split,\n  exact h1,\n  exact h3,\n  intro h,\n  cases h with h1 h2,\n  split,\n  exact h1.1,\n  left,\n  exact h1.2,\n  split,\n  exact h2.1,\n  right,\n  exact h2.2,", "proof_hint": "sorry", "textAfter": "\nend ", "height": 22, "editorText": "sorry", "lineOffset": 14, "name": "distributivity_one", "statement": "(P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R)"}]}, {"name": "125", "problemIndex": 1, "objects": [{"type": "lean", "content": "126", "hidden": true}, {"type": "lemma", "text": "127", "lean": "lemma distributivity_two (P Q R : Prop) : P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R) :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 34, "textBefore": "import tactic --hide\n\n-- Level name : Distributive laws 2\n\n/-Lemma\nIf $P,Q,R$ are logical statements then $P \u2228 (Q \u2227 R)$ is true iff $(P \u2228 Q) \u2227 (P \u2228 R)$ is true.\n-/\nlemma distributivity_two (P Q R : Prop) : P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R) :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h,\n  split,\n  left,\n  exact h,\n  left,\n  exact h,\n  split,\n  right,\n  exact h.1,\n  right,\n  exact h.2,\n  intro h,\n  cases h,\n  cases h_left with h1 h2,\n  left,\n  exact h1,\n  cases h_right with h4 h5,\n  left,\n  exact h4,\n  right,\n  split,\n  exact h2,\n  exact h5,", "proof_hint": "sorry", "textAfter": "\nend", "height": 25, "editorText": "sorry", "lineOffset": 9, "name": "distributivity_two", "statement": "(P Q R : Prop) : P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R)"}]}], "parents": [3]}, {"name": "128", "levels": [{"name": "", "problemIndex": 5, "objects": [{"type": "axiom", "content": "129", "name": "not_iff_imp_false (P : Prop) :", "sideBar": true}, {"type": "text", "content": "130"}, {"type": "lean", "content": "131", "hidden": true}, {"type": "text", "content": "132"}, {"type": "hint", "content": "133", "title": "134"}, {"type": "lemma", "text": "135", "lean": "lemma contrapositive (P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P) :=\n", "sideBar": true, "firstProofLineNumber": 42, "lastProofLineNumber": 51, "textBefore": "/- Axiom : not_iff_imp_false (P : Prop) :\n\u00ac P \u2194 P \u2192 false\n-/\n\n/-\nThere is a false proposition `false`, with no proof. It is\neasy to check that $\\lnot Q$ is equivalent to $Q\\implies {\\tt false}$. Lets call this\n\n`not_iff_imp_false (P : Prop) : \u00ac P \u2194 (P \u2192 false)`\n\n-/\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n/-\n\nIn order to use it, lets look at a new tactic.\n\n## The `rw` tactic\n\nThe `rw` tactic or ``rewrite`` is a tactic that allows you to substitute in things. For example, if we have the\nassumption `h: P \u2194 Q`, then `rw h` will replace the `P`'s in the goal with `Q`'s. If instead you would like to \nturn all of the `Q`'s in your goal to `P`'s then using `rw \u2190h` will do this. (To get the `\u2190` arrow, type `\\l`)\n\n\n(This also works for equalities, but we won't see them in this game).\n\n\nUsing `rw` and `not_iff_imp_false`, try to prove the following:\n\n-/\n\n/- Hint : using rw\n Start by using `rw not_iff_imp_false,` and see what changes.\n-/\n\n\n/- Lemma \nIf $P$ and $Q$ are propositions, and $P\\implies Q$, then\n$\\lnot Q\\implies \\lnot P$. \n-/\nlemma contrapositive (P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P) :=\nbegin\n", "proof": "  rw not_iff_imp_false,\n  rw not_iff_imp_false,\n  intro f,\n  intro h,\n  intro p,\n  apply h,\n  apply f,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n\n\n-/\n\n\n/- Tactic : rw \n\nThe `rw` tactic or ``rewrite`` is a tactic that allows you to substitute in things. For example, if we have the\nassumption `h: P \u2194 Q`, then `rw h` will replace the `P`'s in the goal with `Q`'s. If instead you would like to \nturn all of the `Q`'s in your goal to `P`'s then using `rw \u2190h` will do this. (To get the `\u2190` arrow, type `\\l`)\n\n-/", "height": 10, "editorText": "sorry", "lineOffset": 41, "name": "contrapositive", "statement": "(P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)"}, {"type": "text", "content": "136"}, {"type": "tactic", "content": "137", "name": "rw", "sideBar": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "138", "hidden": true}, {"type": "lean", "content": "139", "hidden": true}, {"type": "text", "content": "140"}, {"type": "lemma", "text": "141", "lean": "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 32, "textBefore": "\nimport tactic --hide\n\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n\n/-\n##  `exfalso` and proof by contradiction. \nIt's certainly true that $P\\land(\\lnot P)\\implies Q$ for any propositions $P$\nand $Q$, because the left hand side of the implication is false. But how do\nwe prove that `false` implies any proposition $Q$? A cheap way of doing it in\nLean is using the `exfalso` tactic, which changes any goal at all to `false`. \nYou might think this is a step backwards, but if you have a hypothesis `h : \u00ac P`\nthen after `rw not_iff_imp_false at h,` you can `apply h,` to make progress. \nTry solving this level using `exfalso.\n-/\n\n\n\n/- Lemma \nIf $P$ and $Q$ are true/false statements, then\n$$(P\\land(\\lnot P))\\implies Q.$$\n-/\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q :=\nbegin\n", "proof": "  intro h,\n  cases h with p np,\n  rw not_iff_imp_false at np,\n  exfalso,\n  apply np,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-Tactic : exofalso\nThis changes any goal to `false`.\n-/", "height": 8, "editorText": "sorry", "lineOffset": 24, "name": "contra", "statement": "(P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q"}, {"type": "tactic", "content": "142", "name": "exofalso", "sideBar": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "143", "hidden": true}, {"type": "lean", "content": "144", "hidden": true}, {"type": "lean", "content": "145", "hidden": true}, {"type": "text", "content": "146"}, {"type": "hint", "content": "147", "title": "148"}, {"type": "lemma", "text": "149", "lean": "lemma contrapositive2 (P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q) :=\n", "sideBar": false, "firstProofLineNumber": 54, "lastProofLineNumber": 74, "textBefore": "\nimport tactic --hide\n\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n\n/-\nWe proved earlier that `(P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)`. The converse,\nthat `(\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q)` is certainly true, but trying to prove\nit using what we've learnt so far is impossible (because it is not provable in\nconstructive logic). For example, after\n```\nintro h,\nintro p,\nrepeat {rw not_iff_imp_false at h},\n```\nin the below, you are left with\n```\nP Q : Prop,\nh : (Q \u2192 false) \u2192 P \u2192 false\np : P\n\u22a2 Q\n```\nThe tools you have are not sufficient to continue. But you can just\nprove this, and any other basic lemmas of this form like `\u00ac \u00ac P \u2192 P`,\nusing the `by_cases` tactic. Instead of starting with all the `intro`s,\ntry this instead:\n`by_cases p : P; by_cases q : Q,`\n**Note the semicolon**! It means \"do the next tactic to all the goals, not just the top one\".\nAfter it, there are four goals, one for each of the four possibilities PQ=TT, TF, FT, FF.\nYou can see that `p` is a proof of `P` in some of the goals, and a proof of `\u00ac P` in others.\nSimilar comments apply to `q`. \n\nNote that using `by_cases` is the same as doing a truth table for the result you want to prove.\n\nYou may also want to use some of the previous results we have used, for example the `contra` lemma we proved\nin the previous level. To use this try something like `apply contra P Q`. Alternatively, there is a tactic \n`contradiction` that will look at your assumptions and try and close the goal for you.\n\n\n-/\n\n/-Hint : Hint\nAlong with `by_cases p : P; by_cases q : Q,` you may also want to use `apply contra P false`\n-/\n\n\n/- Lemma : no-side-bar\nIf $P$ and $Q$ are true/false statements, then\n$$(\\lnot Q\\implies \\lnot P)\\implies(P\\implies Q).$$ \n-/\nlemma contrapositive2 (P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q) :=\nbegin\n", "proof": "  by_cases p : P; by_cases q : Q,\n  intros h hh,\n  exact q,\n  intros h hh,\n  exfalso,\n  apply contra P false,\n  split,\n  exact hh,\n  apply h,\n  exact q,\n  intros h hh,\n  exact q,\n  intros h hh,\n  exfalso,\n  apply contra P false,\n  split,\n  exact hh,\n  apply h,\n  exact q,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nThis approach assumed that `P \u2228 \u00ac P` was true; the `by_cases` tactic just does `cases` on\nthis result. This is called the law of the excluded middle, and it cannot be proved just\nusing tactics such as `intro` and `apply`.\n-/\n\n/-Tactic : by_cases\n\nAll propositional logic problems can in theory be solved by just throwing a truth table at them. \nThe ``by_cases`` tactic is a simple truth table tactic: ``by_cases P`` turns one goal into two goals, \nwith ``P`` is assumed in the first, and ``\u00c2\u00acP`` in the second.\n\nExamples\n--------\n\n1) If ``P`` is a proposition, then ``by_cases P`` turns your goal into two goals, \nand in each of your new tactic states you have one extra hypothesis. \nIn the first one you have a new hypothesis ``h : P`` and in the second you have a new hypothesis ``h : \u00acP``.\n\n2) If you already have a hypothesis ``h`` then this can get a bit confusing, \nso you can also do ``by_cases hP : P``; then your new hypotheses will be ``hP : P`` and ``hP : \u00acP``.\n-/", "height": 21, "editorText": "sorry", "lineOffset": 53, "name": "contrapositive2", "statement": "(P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q)"}, {"type": "text", "content": "150"}, {"type": "tactic", "content": "151", "name": "by_cases", "sideBar": true}]}], "parents": [3]}, {"name": "152", "levels": [{"name": "153", "problemIndex": 7, "objects": [{"type": "lean", "content": "154", "hidden": true}, {"type": "lean", "content": "155", "hidden": true}, {"type": "lean", "content": "156", "hidden": true}, {"type": "text", "content": "157"}, {"type": "hint", "content": "158", "title": "159"}, {"type": "hint", "content": "160", "title": "161"}, {"type": "hint", "content": "162", "title": "163"}, {"type": "lemma", "text": "164", "lean": "lemma DeMorgan_one (P Q : Prop) : \u00ac (P \u2228 Q) \u2194 \u00ac P \u2227 \u00ac Q :=\n", "sideBar": true, "firstProofLineNumber": 38, "lastProofLineNumber": 51, "textBefore": "import tactic --hide\n\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n\n-- Level name : De Morgan's laws, First Boss\n\n/-\nOk time to use everything we have leaned to prove the first of De Morgans laws.\n\n-/\n\n/-Hint : First hint\n\nYou can do this only using `split`, `intro`, `apply`, `left`, `right`.\n\n-/\n\n/- Hint : Second hint\n\nNote that if you have a goal `\u00acP` then `intro h` will turn your goal into `false`.\n\n-/\n\n/- Hint : Last hint\n\nNote that if you have a goal `false` and an assumption `h : \u00acP`, then `apply h` will turn your goal \ninto `P`.\n\n-/\n\n/-Lemma\nNot $P$ or $Q$ is equivalent to $\u00ac P$ and $\u00acQ$.\n-/\n\nlemma DeMorgan_one (P Q : Prop) : \u00ac (P \u2228 Q) \u2194 \u00ac P \u2227 \u00ac Q :=\nbegin\n", "proof": "  split,\n  { intro h,\n    split,\n    { intro hP,\n      apply h,\n      left, \n      exact hP },\n    { intro hQ,\n      apply h,\n      right,\n      exact hQ } },\n  { rintro \u27e8hnP, hnQ\u27e9 (hP | hQ),\n    { apply hnP, exact hP },\n    { exact hnQ hQ } }", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 14, "editorText": "sorry", "lineOffset": 37, "name": "DeMorgan_one", "statement": "(P Q : Prop) : \u00ac (P \u2228 Q) \u2194 \u00ac P \u2227 \u00ac Q"}]}, {"name": "165", "problemIndex": 3, "objects": [{"type": "lean", "content": "166", "hidden": true}, {"type": "lean", "content": "167", "hidden": true}, {"type": "lean", "content": "168", "hidden": true}, {"type": "lemma", "text": "169", "lean": "lemma DeMorgan_two (P Q : Prop) :  \u00ac (P \u2227 Q) \u2194 \u00ac P \u2228 \u00ac Q :=\n", "sideBar": true, "firstProofLineNumber": 15, "lastProofLineNumber": 29, "textBefore": "import tactic --hide\n\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n\n\n-- Level name : De Morgan's laws, Final Boss\n\n/-Lemma\nNot $P$ and $Q$ is equivalent to $\u00ac P$ or $\u00acQ$.\n-/\n\nlemma DeMorgan_two (P Q : Prop) :  \u00ac (P \u2227 Q) \u2194 \u00ac P \u2228 \u00ac Q :=\nbegin\n", "proof": "  split,\n  { intro h,\n    by_cases hP : P,\n    { right,\n      intro hQ,\n      apply h,\n      exact \u27e8hP, hQ\u27e9 },\n    { left,\n      exact hP } },\n  { rintro (hnP | hnQ) \u27e8hP, hQ\u27e9,\n    { apply contra P false,\n      split,\n      exact hP,\n      exact hnP, },\n    { apply hnQ, exact hQ } }", "proof_hint": "sorry", "textAfter": "\nend", "height": 15, "editorText": "sorry", "lineOffset": 14, "name": "DeMorgan_two", "statement": "(P Q : Prop) :  \u00ac (P \u2227 Q) \u2194 \u00ac P \u2228 \u00ac Q"}]}], "parents": [5]}], "texts": [["De Morgan's game", "# Captain De Morgan's logic Game\n\n## By Chris Birkbeck and Niki Kalaydzhieva\n\nLearn some logic yo\n\n# What is this game?\n\nThis is a game to teach you some mathematical logic using Lean.\n\nHave fun!\n\n# Credits\n\nSome levels have been shamelessly borrowed from Kevin Buzzard's and Mohammad Pedramfar's \n\"Natural Numbers Game\" as well as  Kevin Buzzard's \"Formalizing mathematics\" course at \nImperial College. \n\n\n", "Tutorial", "import tactic --hide\n", "\n#Logical statements \n\nYou've seen logical statements already, these are statements that can be true or false, for example: \n\n```md\n1. The sum of two odd numbers is an even number\n2. 36 is divisible by 3\n3. x > 2\n```\n\n\nLets see how one does this on a computer, specifically in lean. In lean, logical staments live in a \nworld called `Prop`. So for example if we write <mark style =\"background-color :   #ebdef0 \">`P : Prop`</mark> we mean \"$P$ is a logical statement.\" \nThink of the \"`:`\" symbol as saying $P$ lives in `Prop` world (in Maths this would be denoted\nby `P \u2208 Prop`, to mean `P` is an element of `Prop`).\n\n#Truth Values\n\nThe *truth value* of a logical statement (i.e. some <mark style =\"background-color :   #ebdef0 \">`P : Prop`</mark>) is whether the statement is true or \nfalse. For example, the truth value of the statement: \"For all integers $x \u2208 \u2124$, $0 \u2264 x^2$\" \nis *true*, while \"For all integers $x \u2208 \u2124$, $0 \u2264 x^3$\" is *false*. \n\nIn lean we assign truth values as follows: We first think of a proposition $P$ as a set with \n*at most* one element. If this set is empty, then we say `P` is *false*. Otherwise, if this set has \nan element, lets call it `p`, then this statement is *true* and `p` is the proof. We will usually \nuse upper case letters for logical statements, and lower case for their proofs.\n\nTo recap, we write  <mark style =\"background-color :   #ebdef0 \">`P : Prop`</mark>  to mean `P` is a \nproposition and we write  <mark style =\"background-color :   #ebdef0 \">`p : P`</mark>  to mean \"`p` is a \nproof of `P`\".\n\nThe aim of this game is to learn how to prove logical statements, which we call *lemmas* through a\nseries of manipulations which we call *tactics*. \n \nLets start with a simple example of how a lemma looks like in lean.\n\nThis is where the window on the right will come into play. If you delete the *sorry* below, \non the right you will see the following state: \n\n```\nP : Prop,\np : P,\n\u22a2 P\n```\n\nHere, the first two lines are our assumptions, where the first line <mark style =\"background-color :   #ebdef0 \">`P : Prop`</mark> says \"$P$ is a \nlogical statement\" and the second line <mark style =\"background-color :   #ebdef0 \">`p : P`</mark> says `p` is the proof of `P`.\n\nThe thing after the `\u22a2` symbol is what we need to prove to win the level (i.e. prove the lemma).\n\nIn this game our \"moves\" or, as we call them in lean, *tactics*, are what will allow us to \nmanipulate our statements and produce proofs.\n\nThe first tactic we will use is called *exact*. It is used when you need to prove a \nstatement $P$ and you have the proof of it. In the example above we have <mark style =\"background-color :   #ebdef0 \">`p : P`</mark> and we need to\nprove `P`, then <mark style =\"background-color :   #ebdef0 \">`exact p,`</mark>  will prove it. \n\n**Note:  We end each line with a comma `,` to tell lean that this is the end of our move.** \n\nTry it for yourself now and see what happens!\n\n", "If $P$ is a logical stament and $p$ is a proof of $P$ then $P$ is true.\n", "## Summary \nIf the goal is `\u22a2 P` then `exact p,` will close the goal if\nand only if `p` is a proof of `P` (i.e. `p : P`) \n## Details\nSay $P$, $Q$ and $R$ are logical staments\nand your lemma looks like this: \n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\nThen you can solve the level by using `exact j(h(p)),`\n", "import tactic --hide \n", "If $P,Q$ are logical statements with respective proofs $p,q$, then $Q$ is true.\n", "import tactic --hide \n", "\n#Combining logical statements\n\nWe can combine basic statements to create new ones. For example, we can write `\u00acP` for the \nstatement \"Not `P`\" and if we have two statements <mark style =\"background-color : #ebdef0 \">`P Q : Prop`</mark> \nwe can write <mark style =\"background-color :  #ebdef0 \">`P \u2192 Q`</mark> to mean `P` implies `Q`. \n\nSay we have the following state of our lemma:\n\n```\nP Q : Prop\nh : P \u2192 Q\np : P\n\u22a2 Q\n```\nAs in level one, the first line says `P` and `Q` are logical statements and the third line says\nthat `P` has a proof `p`.\n\nIn the second line we have the implication <mark style =\"background-color :  #ebdef0 \">`P \u2192 Q`</mark>, which we have called `h`. We think of `h` \nas a one-way road from the statement `P` to the statement `Q` in `Prop` world. \nIn Maths, we would call `h` a function or a map. \n\nFinally, our goal is to prove `Q` is true.\n\nUsing <mark style =\"background-color :  #ebdef0 \">`exact h(p),`</mark> will prove our lemma.\n\nWhy does this work? We know that `P` is true, since we have a proof of it `p` and `h` tells us that\nif `P` is true then `Q` is true. So combining `h` and `p` results in a proof of `Q`.\n\n**Note: We use `h(p)` rather than `h(P)`, because we want to transform the proof of `P` into \na proof of `Q`.**\n\n\n\n", "Let $P,Q$ be logical statements and $P$ implies $Q$. If $P$ is true, then so is $Q$.\n", "import tactic --hide\n", "Let $P,Q,R$ be logical statements with $P$ implies $Q$ and $Q$ implies $R$. If $P$ is true, then so \nis $R$. \n", "Logical statements", "apply tactic", "import tactic --hide\n", "universe u --hide\n", "\n## The `apply` tactic\n\nIf your lemma has the following state: \n\n```\nh : P \u2192 Q\n\u22a2 Q\n```\n\nHere, we assume that `P` implies `Q` and our goal is to prove `Q`. Then the tactic  <mark style =\"background-color : #ebdef0 \">`apply h,`</mark> \nwill change our goal to `P` and leave our assumptions unchanged, i.e. your new state will be\n\n```\nh : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n\nHere's an example we have already done, but try and do it using the `apply` tactic:\n\n", "Let $P,Q$ be logical statements. If $P$ implies $Q$ and $P$ is true, then $Q$ is true. \n", "\n## The `apply` tactic\n\nIf your lemma looks like\n\n```\nh : P \u2192 Q\n\u22a2 Q\n```\n\nthen the tactic `apply h,` will change it to\n\n```\nh : P \u2192 Q\n\u22a2 P\n```\n\nThe `apply` tactic is useful for *arguing backwards*. It reduces the goal to a potentially easier \ngoal, without changing any hypotheses.\n\n\n", "intro", "import tactic --hide\n", "universe u --hide\n", "\n## The `intro` tactic.\n\nIf your goal is \n\n```\n\u22a2 P \u2192 Q\n```\n\nmeaning we need to prove the `P` implies `Q` then the tactic <mark style =\"background-color : #ebdef0 \">`intro hp,`</mark> \nwill take `P` as true with proof `hp` and add `hp : P` to the assumptions. In addition, \nit turn your goal into `\u22a2 Q`. \n\nIn other words the state of the lemma becomes:  \n\n```\nhp : P\n\u22a2 Q\n```\n\nLets look at an example that needs the `intro` tactic: \n\n\n", "Start with `intro p`.\n", "Hint", " `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hp hq` if your goal is `P \u2192 Q \u2192 R`.\n", "Tip", "If $P$ is a logical statement then $P\\implies P$.\n", "\n## The `intro` tactic.\n\nIf your goal is to prove the implication\n\n```\n\u22a2 P \u2192 Q\n```\n\nthen the tactic\n\n`intro hP,`\n\nwill add `hp : P` as an assumption (i.e. `hp` is the proof of `P`) and turn your goal into `\u22a2 Q`. \nIn other words we get: \n\n```\nhP : P\n\u22a2 Q\n```\n\nTip : `intros` can be used to introduce\nmore than one assumption at once. Don't forget\nto name your hypotheses, e.g. `intros hP hQ` if your goal is `P \u2192 Q \u2192 R`.\n\n", "import tactic -- hide\n", "Let $P,Q$ be logical statement and assume $Q$ is true, then $P$ implies $Q$. \n", "This works because the implication `P \u2192 Q` is true unless `Q` is false and `P` is true. In this case\nwe are given that `Q` is always true, so the implication holds regardless of the truth value of `P`. \n", "Why is this true?", "import tactic -- hide\n", "If $P,Q$ are logical statements, then $P$ implies $(Q \\implies P)$\n", "\nNote that implies `\u2192` is not associative: in general `P \u2192 (Q \u2192 R)` and `(P \u2192 Q) \u2192 R`\nmight not be equivalent. This is like subtraction on numbers -- in general\n`a - (b - c)` and `(a - b) - c` might not be equal.\nSo if we write `P \u2192 Q \u2192 R` then we'd better know what this means.\nThe convention in Lean is that it means `P \u2192 (Q \u2192 R)`. If you think\nabout it, this means that to deduce `R` you will need to prove both `P`\nand `Q`. \n", "Caution", "import tactic -- hide\n", "If we know `P`, and we also know `P \u2192 Q`, we can deduce `Q`. \nThis is called \"Modus Ponens\" by logicians.\n", "If $P$ is true and $P \\implies Q$ is true, then $Q$ is true.\n", "import tactic --hide\n", "The goal for this level is to show that implications are transitive. \nThat is, if `P \u2192 Q` and `Q \u2192 R` are true, then so is `P \u2192 R`.\n", "It might be useful to start by using `intros hPQ hQR hP`.\n", "Hint", "If $P,Q,R$ are logical statements and $P \\implies Q$ and $Q \\implies R$ then $P \\implies R$.\n", "Boss level", "import tactic --hide\n", " Notice we have three implications, so we need to introduce all of them using `intros`.\n\n", "Hint 1", "When using `apply` we need to make sure that we use an assumption that contains our goal.\n\n", "Hint 2", "If we have more than one goal to prove, then we need to do them in order. By default the lean \napplies the tactics to the first goal until complete and then moves on to the next.  \n\n", "Hint 3", "If $P,Q,R$ are logical statements and\n $(P \\implies Q \\implies R)$  then $((P \\implies Q) \\implies (P \\implies R)$.\n", "To skip proving a goal you can  write `sorry,`. But don't forget to go back and prove it to solve the\nlevel.  \n\n", "Tip", "Bonus logical statements", "import tactic --hide\n", "Lets try some harder implication statements. \n", "This is a long chain of implications.\n", "import tactic --hide\n", "More nested implications\n", "import tactic --hide\n", "Even more nested implications\n", "import tactic --hide\n", "This is getting silly now\n", "import tactic --hide\n", "How hard could it be?\n", "Boss fight 1", "import tactic --hide\n", "Time for a boss fight!\n", "And & Or", "import tactic --hide\n", "## The `split` tactic\n\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2227 Q\n```\n\nthen the  <mark style =\"background-color : #ebdef0 \">`split`</mark>  tactic will turn it\ninto *two* goals `\u22a2 P` and `\u22a2 Q`.\n\n", "It is best practice to indicate when you are working with two goals, either by using squiggly \nbrackets like this:\n\n```\n...\nsplit,\n{ working on P,\n  end of proof of P },\n{ working on Q,\n  end of proof of Q },\n```\n\nor by using indentation like this:\n\n```\nsplit,\n  working on P,\n  end of proof of P,\nworking on Q,\n...\n```\n", "Tip", "Let $P,Q$ be logical statements and assume that they are both true, then $P \u2227 Q$ is \ntrue.\n", "import tactic --hide\n", "`split` can also be used for if and only if statements. For example, if you have `\u22a2 P \u2194 Q` and apply\n`split`, then your goal will change from \n\n```\n\u22a2 P \u2194 Q\n```\nto two goals, `\u22a2 P \u2192 Q` and `\u22a2 Q \u2192 P`.\n", "Let $P$ be a logical statement, then $P$ is true if and only if $P$ is true.\n", "\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2227 Q\n```\n\nthen the  `split` tactic will turn it into *two* goals `\u22a2 P` and `\u22a2 Q`.\n\nMoreover, if you have an iff `P \u2194 Q` then splitting it will give you two goals, `P \u2192 Q` \n(i.e \"`P` only if `Q`\") and `P \u2190 Q ` (i.e \"`P` if `Q`\") to prove.\n\n", "import tactic --hide\n", "## `left` and `right`\n\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2228 Q\n```\n\nthen   <mark style =\"background-color : #ebdef0 \">`left`</mark>  changes the goal to `\u22a2 P`. \nSimilarly,  <mark style =\"background-color : #ebdef0 \">`right`</mark>  changes the goal to `\u22a2 Q`.\n\n", " The logic is that `P` implies `P \u2228 Q` so it is enough to prove `P`. \n -/\n\n\n/-Lemma\nLet $P,Q$ be logical statements and assume $P$ is true, then $P \u2228 Q$ is true.\n", "Why does this work?", "lemma left_example (P Q : Prop) (p : P) : P \u2228 Q :=\nbegin\n  left,\n  exact p,\nend\n", "\nIf your lemma has the goal: \n\n```\n\u22a2 P \u2228 Q\n```\n\nthen `left` changes the goal to `\u22a2 P`. Similarly `right` changes the goal to `\u22a2 Q`.\n\n", "import tactic --hide\n", "## The `cases` tactic\n\n`cases` is a very general-purpose tactic for \"deconstructing\" hypotheses.\nIf `h` is an assumption which somehow \"bundles up\" two pieces of information,\nthen  <mark style =\"background-color : #ebdef0 \">`cases h with h1 h2`</mark>  will make the assumption `h` vanish and will replace it\nwith the two \"components\" which made the proof of `h` in the first place.\nAn example of this occurring is if you have the assumption `h : P \u2227 Q` which contains a \nproof of `P` and a proof of `Q`.\n\n\n\nFor example, if you have an assumption\n\n```\nh : P \u2227 Q\n```\n\nthen\n\n`cases h with hP hQ,`\n\nwill delete `h` and replace it with\n\n```\nhP : P\nhQ : Q\n```\nTry it out below.\n\n", "If $P,Q$ are logical statements and $P \u2227 Q$ is true then so is $P$.\n", "\nIf you have a hypothesis\n\n```\nh : P \u2227 Q\n```\n\nthen\n\n`cases h with hP hQ,`\n\nwill delete `h` and replace it with\n\n```\nhP : P\nhQ : Q\n```\n\nYou can also use it for \"or's\". Specifically, if you have `h : P \u2228 Q` then `cases h` will\ngive you two goals, one where `P` is true and one where `Q` is true.\n\n", "import tactic --hide\n", "You can also use `cases` when working with the `\u2228` (\"or\") connective.For example, if you have\nthe assumption\n\n```\nh : P \u2228 Q\n``` \n\nthen `cases h with hp hq` will convert your state into the following two states:\n\n```\nP : Prop\nhp : P\n\u22a2 P\n```\nand\n\n```\nP : Prop\nhq : Q\n\u22a2 Q\n```\none where `P` is true and one where `Q` is true.\n\nTry this in the lemma below\n", "If $P$ is a logical statement and $P$ or $P$ is true, then $P$ is true.\n", "import tactic --hide\n", "This level proves that `\u2227` is a commutative operator. \n", "Let $P,Q$ be logical statements, then $P \u2227 Q$ is true iff $Q \u2227 P$ is true.\n", "import tactic --hide\n", "If $P,Q,R$ are logical statements then $P \u2227 Q$ implies that \n$(P \\implies R) \\implies (Q \\implies R) \\implies R$ \n", "import tactic --hide\n", "This level will show that `\u2227` is *transitive*.\n", "If $P,Q,R$ are logical statements, then $P \u2227 Q$ and $Q \u2227 R$ imples $P \u2227 R$.\n", "Logic laws", "absorpsion laws pt 1", "import tactic --hide\n", "Lets try and prove that $P \u2227 (P \u2228 Q)$ is equivalent to $P$\n", "If $P,Q$ are logical statements then $P \u2227 (P \u2228 Q)$ is true if and only if $P$ is true.\n", "absorpsion laws pt 2", "import tactic --hide\n", "/-Lets try and prove that $P \u2228 (P \u2227 Q)$ is equivalent to $P$\n-/\n", "If $P,Q$ are logical statements then $P \u2228 (P \u2227 Q)$ is true if and only if $P$ is true.\n", "Associative laws pt 1", "import tactic --hide\n", "Lets prove that $P \u2227 (Q \u2227 R)$ is equivalent to $(P \u2227 Q) \u2227 R$. We call this *associativity* of `\u2227`.\n", "If $P,Q,R$ are logical statements, then $P \u2227 (Q \u2227 R)$ is true iff $(P \u2227 Q) \u2227 R$ is true.\n", "Associative laws pt 2", "import tactic --hide\n", "Lets prove that `\u2228` is also associative.\n", "If $P,Q,R$ are logical statements then $P \u2228 (Q \u2228 R)$ is true iff $(P \u2228 Q) \u2228 R$ is true.\n", "Distributive laws 1", "import tactic --hide\n", "Lets prove that $P \u2227 (Q \u2228 R)$ is equivalent to $(P \u2227 Q) \u2228 (P \u2227 R)$. We call this property of `\u2227` \nand `\u2228`, *distributivity*. \n", "If $P,Q,R$ are logical statements then $P \u2227 (Q \u2228 R)$ is true iff $(P \u2227 Q) \u2228 (P \u2227 R)$ is true.\n", "Distributive laws 2", "import tactic --hide\n", "If $P,Q,R$ are logical statements then $P \u2228 (Q \u2227 R)$ is true iff $(P \u2228 Q) \u2227 (P \u2228 R)$ is true.\n", "Not logic", "\u00ac P \u2194 P \u2192 false\n", "There is a false proposition `false`, with no proof. It is\neasy to check that $\\lnot Q$ is equivalent to $Q\\implies {\\tt false}$. Lets call this\n\n`not_iff_imp_false (P : Prop) : \u00ac P \u2194 (P \u2192 false)`\n\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "\nIn order to use it, lets look at a new tactic.\n\n## The `rw` tactic\n\nThe `rw` tactic or ``rewrite`` is a tactic that allows you to substitute in things. For example, if we have the\nassumption `h: P \u2194 Q`, then `rw h` will replace the `P`'s in the goal with `Q`'s. If instead you would like to \nturn all of the `Q`'s in your goal to `P`'s then using `rw \u2190h` will do this. (To get the `\u2190` arrow, type `\\l`)\n\n\n(This also works for equalities, but we won't see them in this game).\n\n\nUsing `rw` and `not_iff_imp_false`, try to prove the following:\n\n", " Start by using `rw not_iff_imp_false,` and see what changes.\n", "using rw", "If $P$ and $Q$ are propositions, and $P\\implies Q$, then\n$\\lnot Q\\implies \\lnot P$. \n", "\n\n", "\nThe `rw` tactic or ``rewrite`` is a tactic that allows you to substitute in things. For example, if we have the\nassumption `h: P \u2194 Q`, then `rw h` will replace the `P`'s in the goal with `Q`'s. If instead you would like to \nturn all of the `Q`'s in your goal to `P`'s then using `rw \u2190h` will do this. (To get the `\u2190` arrow, type `\\l`)\n\n", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "##  `exfalso` and proof by contradiction. \nIt's certainly true that $P\\land(\\lnot P)\\implies Q$ for any propositions $P$\nand $Q$, because the left hand side of the implication is false. But how do\nwe prove that `false` implies any proposition $Q$? A cheap way of doing it in\nLean is using the `exfalso` tactic, which changes any goal at all to `false`. \nYou might think this is a step backwards, but if you have a hypothesis `h : \u00ac P`\nthen after `rw not_iff_imp_false at h,` you can `apply h,` to make progress. \nTry solving this level using `exfalso.\n", "If $P$ and $Q$ are true/false statements, then\n$$(P\\land(\\lnot P))\\implies Q.$$\n", "This changes any goal to `false`.\n", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "We proved earlier that `(P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)`. The converse,\nthat `(\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q)` is certainly true, but trying to prove\nit using what we've learnt so far is impossible (because it is not provable in\nconstructive logic). For example, after\n```\nintro h,\nintro p,\nrepeat {rw not_iff_imp_false at h},\n```\nin the below, you are left with\n```\nP Q : Prop,\nh : (Q \u2192 false) \u2192 P \u2192 false\np : P\n\u22a2 Q\n```\nThe tools you have are not sufficient to continue. But you can just\nprove this, and any other basic lemmas of this form like `\u00ac \u00ac P \u2192 P`,\nusing the `by_cases` tactic. Instead of starting with all the `intro`s,\ntry this instead:\n`by_cases p : P; by_cases q : Q,`\n**Note the semicolon**! It means \"do the next tactic to all the goals, not just the top one\".\nAfter it, there are four goals, one for each of the four possibilities PQ=TT, TF, FT, FF.\nYou can see that `p` is a proof of `P` in some of the goals, and a proof of `\u00ac P` in others.\nSimilar comments apply to `q`. \n\nNote that using `by_cases` is the same as doing a truth table for the result you want to prove.\n\nYou may also want to use some of the previous results we have used, for example the `contra` lemma we proved\nin the previous level. To use this try something like `apply contra P Q`. Alternatively, there is a tactic \n`contradiction` that will look at your assumptions and try and close the goal for you.\n\n\n", "Along with `by_cases p : P; by_cases q : Q,` you may also want to use `apply contra P false`\n", "Hint", "If $P$ and $Q$ are true/false statements, then\n$$(\\lnot Q\\implies \\lnot P)\\implies(P\\implies Q).$$ \n", "This approach assumed that `P \u2228 \u00ac P` was true; the `by_cases` tactic just does `cases` on\nthis result. This is called the law of the excluded middle, and it cannot be proved just\nusing tactics such as `intro` and `apply`.\n", "\nAll propositional logic problems can in theory be solved by just throwing a truth table at them. \nThe ``by_cases`` tactic is a simple truth table tactic: ``by_cases P`` turns one goal into two goals, \nwith ``P`` is assumed in the first, and ``\u00c2\u00acP`` in the second.\n\nExamples\n--------\n\n1) If ``P`` is a proposition, then ``by_cases P`` turns your goal into two goals, \nand in each of your new tactic states you have one extra hypothesis. \nIn the first one you have a new hypothesis ``h : P`` and in the second you have a new hypothesis ``h : \u00acP``.\n\n2) If you already have a hypothesis ``h`` then this can get a bit confusing, \nso you can also do ``by_cases hP : P``; then your new hypotheses will be ``hP : P`` and ``hP : \u00acP``.\n", "De Morgan's laws", "De Morgan's laws, First Boss", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "Ok time to use everything we have leaned to prove the first of De Morgans laws.\n\n", "\nYou can do this only using `split`, `intro`, `apply`, `left`, `right`.\n\n", "First hint", "\nNote that if you have a goal `\u00acP` then `intro h` will turn your goal into `false`.\n\n", "Second hint", "\nNote that if you have a goal `false` and an assumption `h : \u00acP`, then `apply h` will turn your goal \ninto `P`.\n\n", "Last hint", "Not $P$ or $Q$ is equivalent to $\u00ac P$ and $\u00acQ$.\n", "De Morgan's laws, Final Boss", "import tactic --hide\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q := by {cc} --hide\n", "Not $P$ and $Q$ is equivalent to $\u00ac P$ or $\u00acQ$.\n"]]}