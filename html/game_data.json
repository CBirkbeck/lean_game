{"name": "Lean Topology game2", "version": "1.1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Lean Topology game2-1.1.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "3", "name": "refl", "sideBar": true}, {"type": "text", "content": "4"}, {"type": "hint", "content": "5", "title": "6"}, {"type": "lean", "content": "7", "hidden": true}, {"type": "lemma", "text": "8", "lean": "lemma union_is_union (A B : set X) : A \u222a B = A \u222a B :=\n", "sideBar": false, "firstProofLineNumber": 43, "lastProofLineNumber": 44, "textBefore": "/- Tactic : refl\n\n## Summary\n\n`refl` is a tactic which proves goals of the form `X = X`.\n\n## Details\n\nThe `refl` tactic will close any goal of the form `A = B`\nwhere `A` and `B` are *exactly the same thing*.\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B : set X\n\u22a2 A \u222a B = A \u222a B\n```\n\nthen\n\n`refl,`\n\nwill close the goal and solve the level. Don't forget the comma.\n\n-/\n\n/-\nWe will start by practising with the simplest tactic, namely *refl*. This just proves goals\nof the form $A = A$, no matter how complicated $A$ is. Let's see it in action!\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nJust delete `sorry` and type `refl,` (don't forget the comma!).\n-/\n\nvariables {X : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A and B are sets, then A \u222a B = A \u222a B.\n-/\nlemma union_is_union (A B : set X) : A \u222a B = A \u222a B :=\nbegin\n", "proof": "  refl,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 2, "editorText": "sorry", "lineOffset": 42, "name": "union_is_union", "statement": "(A B : set X) : A \u222a B = A \u222a B"}]}]}, {"name": "9", "levels": [{"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "10", "hidden": true}, {"type": "lean", "content": "11", "hidden": true}, {"type": "text", "content": "12"}, {"type": "lean", "content": "13", "hidden": true}, {"type": "lean", "content": "14", "hidden": true}, {"type": "lemma", "text": "15", "lean": "lemma image_union (f : X \u2192 Y) (A B : set X) : f '' (A \u222a B) = f '' A \u222a f '' B :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 62, "textBefore": "import data.set.basic -- hide\nimport tactic -- hide\n\n/-\n# Level 1: The image of a union\n\nIn this level we prove that the image of a union of two sets if the union of their images.\n-/\n\nopen set -- hide\nvariables{X Y: Type} -- hide\n\n/- Lemma\n$ f(A \u222a B) = f(A) \u222a f(B) $\n-/\nlemma image_union (f : X \u2192 Y) (A B : set X) : f '' (A \u222a B) = f '' A \u222a f '' B :=\nbegin\n", "proof": "  ext y,\n  split,\n  {\n    intro h1,\n    cases h1,\n    cases h1_h,\n    cases h1_h_left,\n    {\n      left, \n      rw <-h1_h_right,\n      use [h1_w, h1_h_left],\n    },\n    {right,\n    rw <-h1_h_right,\n    use [h1_w, h1_h_left],\n    },\n\n  },\n  {\n    intro h1,\n    cases h1,\n    {\n      cases h1,\n      cases h1_h,\n      rw <-h1_h_right,\n      have h : h1_w \u2208 A \u222a B,\n      {\n        left,\n        exact h1_h_left,\n      },\n      use [h1_w, h],\n    },\n    {\n      cases h1,\n      cases h1_h,\n      rw <-h1_h_right,\n      have h : h1_w \u2208 A \u222a B,\n      {\n        right,\n        exact h1_h_left,\n      },\n      use [h1_w, h],\n    },\n  },\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 45, "editorText": "sorry", "lineOffset": 17, "name": "image_union", "statement": "(f : X \u2192 Y) (A B : set X) : f '' (A \u222a B) = f '' A \u222a f '' B"}]}], "parents": [0]}, {"name": "16", "levels": [{"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "17", "hidden": true}, {"type": "axiom", "content": "18", "name": "The total set (called `univ`) is open.", "sideBar": true}, {"type": "axiom", "content": "19", "name": "The intersection of two open sets is open.", "sideBar": true}, {"type": "axiom", "content": "20", "name": "The union of an arbitrary set of open sets is open.", "sideBar": true}, {"type": "axiom", "content": "21", "name": "The union over the empty set is empty.", "sideBar": true}, {"type": "text", "content": "22"}, {"type": "lean", "content": "23", "hidden": true}, {"type": "lean", "content": "24", "hidden": true}, {"type": "text", "content": "25"}, {"type": "lean", "content": "26", "hidden": true}, {"type": "hint", "content": "27", "title": "28"}, {"type": "lemma", "text": "29", "lean": "lemma is_open_empty {X : Type} [topological_space X] : is_open (\u2205 : set X) :=\n", "sideBar": true, "firstProofLineNumber": 43, "lastProofLineNumber": 50, "textBefore": "import basic_defs_world.definition -- hide\n\n/- Axiom : The total set (called `univ`) is open.\nuniv_mem : is_open set.univ\n-/\n\n/- Axiom : The intersection of two open sets is open.\ninter : \u2200 (U V : set X) (hA : is_open U) (hB : is_open V), is_open (U \u2229 V)\n-/\n\n/- Axiom : The union of an arbitrary set of open sets is open.\nunion : \u2200 (Y : set (set X)) (h : \u2200 U \u2208 Y, is_open U), is_open (\u22c3\u2080 Y)\n-/\n\n/- Axiom : The union over the empty set is empty.\nsUnion_empty : \u22c3\u2080 \u2205 = \u2205\n-/\n\n/-\n# Level 1 : The empty set is open.\n-/\nnoncomputable theory -- hide\nopen set -- hide\n\n/-\nIn many textbooks, one of the axioms of a topological space is that the empty set is open. This actually follows from the other axioms!\n-/\n\nnamespace topological_space -- hide\n\n\n/- Hint : Click here for a hint, in case you get stuck.\nIn Lean, sets are notation for logical statements. That is, the set\n`a \u2208 { x : X | P x }` means *the same as* `P a`. As a somewhat degenerate\nexample, `a \u2208 \u2205` means `false`.\n-/\n\n/- Lemma\nProve that the empty set is open.\n-/\nlemma is_open_empty {X : Type} [topological_space X] : is_open (\u2205 : set X) :=\nbegin\n", "proof": "  rw \u2190sUnion_empty,\n  apply union,\n  tauto,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 42, "name": "is_open_empty", "statement": "{X : Type} [topological_space X] : is_open (\u2205 : set X)"}, {"type": "lean", "content": "30", "hidden": true}]}], "parents": [1]}, {"name": "31", "levels": [{"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "32", "hidden": true}, {"type": "axiom", "content": "33", "name": "A set A is the neighborhood of a point x if there is an open U such that x \u2208 U \u2286 A.", "sideBar": true}, {"type": "axiom", "content": "34", "name": "A point x is an interior point of A if A is a neighborhood of x.", "sideBar": true}, {"type": "axiom", "content": "35", "name": "The interior of a set A is the set of all its interior points.", "sideBar": true}, {"type": "text", "content": "36"}, {"type": "lean", "content": "37", "hidden": true}, {"type": "lean", "content": "38", "hidden": true}, {"type": "lean", "content": "39", "hidden": true}, {"type": "lean", "content": "40", "hidden": true}, {"type": "lemma", "text": "41", "lean": "lemma interior_is_subset: interior A \u2286 A :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 45, "textBefore": "import basic_defs_world.level1 -- hide\n\n/- Axiom : A set A is the neighborhood of a point x if there is an open U such that x \u2208 U \u2286 A.\nis_neighborhood : \u2203 U, is_open U \u2227 x \u2208 U \u2227 U \u2286 A\n-/\n\n/- Axiom : A point x is an interior point of A if A is a neighborhood of x.\nis_interior_point : is_neighborhood x A\n-/\n\n/- Axiom : The interior of a set A is the set of all its interior points. \ninterior := { x : X | is_interior_point x A }\n-/\n\n/-\nIn this world we will end up having three alternative definitions of the interior of a set. \nThis will be very useful, because at any point we will be able to choose the one that better fits our needs.\n\nFirst of all we need to figure out what properties does the interior of an arbitrary set have... So we start with an easy one:\n\n# Level 1: The interior is contained in the original set\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] (x : X)  (A : set X) -- hide\n\nnamespace topological_space -- hide\n\n@[simp]  -- hide\n/- Lemma\nThe interior of any set A is contained in the set A.\n-/\nlemma interior_is_subset: interior A \u2286 A :=\nbegin\n", "proof": "  rintros x \u27e8_, _\u27e9,\n  tauto,\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 11, "editorText": "sorry", "lineOffset": 34, "name": "interior_is_subset", "statement": "interior A \u2286 A"}, {"type": "lean", "content": "42", "hidden": true}]}], "parents": [2]}], "texts": [["Lean Topology game2", "# The Topology Game, version 1.0.0.\n\n## By the Barcelona Lean Seminar\n\nLearn topology with Lean!\n\n# What is this game?\n\nIn this game, you will learn topology and Lean at the same time. Travel through different worlds solving challenges. On the left side \nof the screen you will find tactics and theorems you can use.\n\nHave fun!\n\n# Credits\n\nThe Topology Game is brought to you by the Barcelona Lean Seminar, a project based at Universitat Aut\u00f2noma de Barcelona.\n\nLean is a computer theorem prover being developed at Microsoft Research.\n\nProve a theorem. Write a function. <a href=\"https://twitter.com/XenaProject\" target=\"blank\">@XenaProject</a>.\n", "Set theory", "\n## Summary\n\n`refl` is a tactic which proves goals of the form `X = X`.\n\n## Details\n\nThe `refl` tactic will close any goal of the form `A = B`\nwhere `A` and `B` are *exactly the same thing*.\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B : set X\n\u22a2 A \u222a B = A \u222a B\n```\n\nthen\n\n`refl,`\n\nwill close the goal and solve the level. Don't forget the comma.\n\n", "We will start by practising with the simplest tactic, namely *refl*. This just proves goals\nof the form $A = A$, no matter how complicated $A$ is. Let's see it in action!\n", "Just delete `sorry` and type `refl,` (don't forget the comma!).\n", "Click here for a hint, in case you get stuck.", "variables {X : Type} -- hide\n", "If A and B are sets, then A \u222a B = A \u222a B.\n", "Functions", "import data.set.basic -- hide\n", "import tactic -- hide\n", "# Level 1: The image of a union\n\nIn this level we prove that the image of a union of two sets if the union of their images.\n", "open set -- hide\n", "variables{X Y: Type} -- hide\n", "$ f(A \u222a B) = f(A) \u222a f(B) $\n", "Basic definitions", "import basic_defs_world.definition -- hide\n", "univ_mem : is_open set.univ\n", "inter : \u2200 (U V : set X) (hA : is_open U) (hB : is_open V), is_open (U \u2229 V)\n", "union : \u2200 (Y : set (set X)) (h : \u2200 U \u2208 Y, is_open U), is_open (\u22c3\u2080 Y)\n", "sUnion_empty : \u22c3\u2080 \u2205 = \u2205\n", "# Level 1 : The empty set is open.\n", "noncomputable theory -- hide\n", "open set -- hide\n", "In many textbooks, one of the axioms of a topological space is that the empty set is open. This actually follows from the other axioms!\n", "namespace topological_space -- hide\n", "In Lean, sets are notation for logical statements. That is, the set\n`a \u2208 { x : X | P x }` means *the same as* `P a`. As a somewhat degenerate\nexample, `a \u2208 \u2205` means `false`.\n", "Click here for a hint, in case you get stuck.", "Prove that the empty set is open.\n", "end topological_space -- hide\n", "Interior world", "import basic_defs_world.level1 -- hide\n", "is_neighborhood : \u2203 U, is_open U \u2227 x \u2208 U \u2227 U \u2286 A\n", "is_interior_point : is_neighborhood x A\n", "interior := { x : X | is_interior_point x A }\n", "In this world we will end up having three alternative definitions of the interior of a set. \nThis will be very useful, because at any point we will be able to choose the one that better fits our needs.\n\nFirst of all we need to figure out what properties does the interior of an arbitrary set have... So we start with an easy one:\n\n# Level 1: The interior is contained in the original set\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] (x : X)  (A : set X) -- hide\n", "namespace topological_space -- hide\n", "@[simp]  -- hide\n", "The interior of any set A is contained in the set A.\n", "end topological_space -- hide\n"]]}